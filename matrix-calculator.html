<!-- ********************************************************************** -->
<!--                                                                        -->
<!--  matrix-calculator.html                            TTTTTTTT SSSSSSS II -->
<!--                                                       TT    SS      II -->
<!--  By: st93642@students.tsi.lv                          TT    SSSSSSS II -->
<!--                                                       TT         SS II -->
<!--  Created: Oct 28 2025 18:46 st93642                   TT    SSSSSSS II -->
<!--  Updated: Nov 17 2025 09:35 st93642                                    -->
<!--                                                                        -->
<!--   Transport and Telecommunication Institute - Riga, Latvia             -->
<!--                       https://tsi.lv                                   -->
<!-- ********************************************************************** -->

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Matrix Calculator</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
      background: white;
      border-radius: 20px;
      padding: 30px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
    }
    
    h1 {
      text-align: center;
      color: #667eea;
      margin-bottom: 30px;
      font-size: 2.5em;
    }
    
    .tab-content {
      display: none;
    }
    
    .tab-content.active {
      display: block;
    }
    
    .controls {
      display: flex;
      gap: 20px;
      margin-bottom: 30px;
      flex-wrap: wrap;
    }
    
    .control-group {
      flex: 1;
      min-width: 200px;
    }
    
    label {
      display: block;
      margin-bottom: 5px;
      color: #555;
      font-weight: 600;
    }
    
    select, input {
      width: 100%;
      padding: 10px;
      border: 2px solid #e0e0e0;
      border-radius: 8px;
      font-size: 16px;
      transition: border-color 0.3s;
    }
    
    select:focus, input:focus {
      outline: none;
      border-color: #667eea;
    }
    
    .matrices-container {
      display: flex;
      gap: 30px;
      margin-bottom: 30px;
      flex-wrap: wrap;
    }
    
    .matrix-section {
      flex: 1;
      min-width: 250px;
    }
    
    .matrix-section h3 {
      color: #764ba2;
      margin-bottom: 15px;
    }
    
    .matrix-grid {
      display: inline-grid;
      gap: 8px;
      padding: 20px;
      background: #f8f9fa;
      border-radius: 12px;
      border: 3px solid #667eea;
    }
    
    .matrix-grid input {
      width: 60px;
      height: 50px;
      text-align: center;
      font-size: 18px;
      font-weight: 600;
      border: 2px solid #ddd;
    }
    
    .buttons {
      display: flex;
      gap: 15px;
      flex-wrap: wrap;
      margin-bottom: 30px;
    }
    
    button {
      flex: 1;
      min-width: 120px;
      padding: 15px 25px;
      font-size: 16px;
      font-weight: 600;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.3s;
      color: white;
    }
    
    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
    }
    
    .btn-multiply { background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); }
    .btn-determinant { background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%); }
    .btn-inverse { background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%); }
    
    .result-section {
      margin-top: 30px;
      padding: 25px;
      background: #f8f9fa;
      border-radius: 12px;
      border-left: 5px solid #667eea;
    }
    
    .result-left, .result-right {
      min-width: 0;
      box-sizing: border-box;
      max-height: 70vh;
      overflow-y: auto;
      padding-right: 10px;
    }
    
    .result-left h3, .result-right h3 {
      color: #764ba2;
      margin-bottom: 20px;
    }
    
    .steps {
      max-height: 60vh;
      overflow-y: auto;
      padding-right: 10px;
    }
    

    
    .step {
      padding: 15px;
      margin-bottom: 15px;
      background: white;
      border-radius: 8px;
      border-left: 4px solid #667eea;
      animation: slideIn 0.5s ease-out;
      opacity: 0;
      animation-fill-mode: forwards;
    }
    
    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateX(-20px);
      }
      to {
        opacity: 1;
        transform: translateX(0);
      }
    }
    
    .step-title {
      font-weight: 600;
      color: #667eea;
      margin-bottom: 8px;
    }
    
    .step-content {
      color: #555;
      font-family: 'Courier New', monospace;
      line-height: 1.6;
    }
    
    .matrix-display {
      display: inline-block;
      margin: 10px 0;
      padding: 15px;
      background: white;
      border-radius: 8px;
      border: 2px solid #667eea;
    }
    
    .matrix-row {
      display: flex;
      gap: 12px;
      justify-content: center;
    }
    
    .matrix-cell {
      width: 85px;
      min-width: 85px;
      height: 45px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      color: #333;
      background: #f0f0f0;
      border-radius: 5px;
      transition: all 0.3s ease;
      font-size: 16px;
    }
    
    .matrix-separator {
      width: 20px !important;
      background: transparent !important;
      border: none !important;
      padding: 0 !important;
    }
    
    .highlight {
      background: #ffe066 !important;
      animation: pulse 0.5s ease-in-out;
      transform: scale(1.15);
      box-shadow: 0 0 15px rgba(255, 224, 102, 0.8);
    }
    
    .highlight-row {
      background: #a8e6cf !important;
      transform: scale(1.1);
    }
    
    .highlight-col {
      background: #ffd3b6 !important;
      transform: scale(1.1);
    }
    
    .highlight-cell {
      background: #ff8c69 !important;
      transform: scale(1.3);
      animation: pulse-cell 0.6s ease-in-out;
      box-shadow: 0 0 15px rgba(255, 140, 105, 0.8);
      z-index: 10;
      position: relative;
    }
    
    @keyframes pulse-cell {
      0%, 100% { transform: scale(1.3); }
      50% { transform: scale(1.5); }
    }
    
    .highlight-processing {
      background: #ff6b6b !important;
      animation: pulse 0.8s ease-in-out infinite;
      transform: scale(1.2);
      box-shadow: 0 0 20px rgba(255, 107, 107, 0.9);
      border: 2px solid #ff4757;
    }
    
    @keyframes pulse {
      0%, 100% { transform: scale(1.15); }
      50% { transform: scale(1.25); }
    }
    
    .formula-display {
      font-size: 18px;
      padding: 15px;
      background: linear-gradient(135deg, #667eea20 0%, #764ba220 100%);
      border-radius: 8px;
      margin: 15px 0;
      font-family: 'Courier New', monospace;
      font-weight: 600;
      color: #764ba2;
      text-align: center;
      border: 2px solid #667eea;
    }
    
    .visual-calculation {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 20px;
      margin: 20px 0;
      flex-wrap: wrap;
      max-width: 100%;
    }
    
    .calc-arrow {
      font-size: 30px;
      color: #667eea;
      animation: bounce 1s infinite;
    }
    
    @keyframes bounce {
      0%, 100% { transform: translateX(0); }
      50% { transform: translateX(10px); }
    }
    
    .error {
      color: #f5576c;
      padding: 15px;
      background: #ffe0e0;
      border-radius: 8px;
      margin-top: 10px;
    }
    
    .theoretical-explanation {
      background: linear-gradient(135deg, #e8f4fd 0%, #d1e7f0 100%);
      border-left-color: #4a90e2;
    }
    
    .theoretical-content {
      font-style: italic;
      color: #2c5282;
      line-height: 1.6;
    }
    
    .test-section {
      margin-top: 20px;
      padding: 20px;
      background: #f8f9fa;
      border-radius: 12px;
      border-left: 5px solid #28a745;
    }
    
    .test-result {
      margin-bottom: 15px;
      padding: 10px;
      border-radius: 8px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .test-pass {
      background: #d4edda;
      border-left: 4px solid #28a745;
    }
    
    .test-fail {
      background: #f8d7da;
      border-left: 4px solid #dc3545;
    }
    
    .test-name {
      font-weight: 600;
    }
    
    .test-status {
      font-weight: 600;
      padding: 4px 8px;
      border-radius: 4px;
    }
    
    .test-pass .test-status {
      background: #28a745;
      color: white;
    }
    
    .test-fail .test-status {
      background: #dc3545;
      color: white;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üßÆ Matrix Calculator</h1>
    
    <!-- Matrix Operations -->
    <div id="matrix-tab" class="tab-content active">
      <div class="controls">
        <div class="control-group">
          <label>Matrix A Size:</label>
          <select id="sizeA" onchange="updateMatrices()">
            <option value="1x1">1√ó1</option>
            <option value="1x2">1√ó2</option>
            <option value="1x3">1√ó3</option>
            <option value="1x4">1√ó4</option>
            <option value="1x5">1√ó5</option>
            <option value="2x1">2√ó1</option>
            <option value="2x2">2√ó2</option>
            <option value="2x3">2√ó3</option>
            <option value="2x4">2√ó4</option>
            <option value="2x5">2√ó5</option>
            <option value="3x1">3√ó1</option>
            <option value="3x2">3√ó2</option>
            <option value="3x3" selected>3√ó3</option>
            <option value="3x4">3√ó4</option>
            <option value="3x5">3√ó5</option>
            <option value="4x1">4√ó1</option>
            <option value="4x2">4√ó2</option>
            <option value="4x3">4√ó3</option>
            <option value="4x4">4√ó4</option>
            <option value="4x5">4√ó5</option>
            <option value="5x1">5√ó1</option>
            <option value="5x2">5√ó2</option>
            <option value="5x3">5√ó3</option>
            <option value="5x4">5√ó4</option>
            <option value="5x5">5√ó5</option>
          </select>
        </div>
        <div class="control-group">
          <label>Matrix B Size:</label>
          <select id="sizeB" onchange="updateMatrices()">
            <option value="1x1">1√ó1</option>
            <option value="1x2">1√ó2</option>
            <option value="1x3">1√ó3</option>
            <option value="1x4">1√ó4</option>
            <option value="1x5">1√ó5</option>
            <option value="2x1">2√ó1</option>
            <option value="2x2">2√ó2</option>
            <option value="2x3">2√ó3</option>
            <option value="2x4">2√ó4</option>
            <option value="2x5">2√ó5</option>
            <option value="3x1">3√ó1</option>
            <option value="3x2">3√ó2</option>
            <option value="3x3" selected>3√ó3</option>
            <option value="3x4">3√ó4</option>
            <option value="3x5">3√ó5</option>
            <option value="4x1">4√ó1</option>
            <option value="4x2">4√ó2</option>
            <option value="4x3">4√ó3</option>
            <option value="4x4">4√ó4</option>
            <option value="4x5">4√ó5</option>
            <option value="5x1">5√ó1</option>
            <option value="5x2">5√ó2</option>
            <option value="5x3">5√ó3</option>
            <option value="5x4">5√ó4</option>
            <option value="5x5">5√ó5</option>
          </select>
        </div>
      </div>
      
      <div class="matrices-container">
        <div class="matrix-section">
          <h3>Matrix A</h3>
          <div class="matrix-grid" id="matrixA"></div>
        </div>
        <div class="matrix-section">
          <h3>Matrix B</h3>
          <div class="matrix-grid" id="matrixB"></div>
        </div>
      </div>
      
      <div class="buttons">
        <button class="btn-multiply" onclick="calculate('multiply')">‚úñÔ∏è Multiply A √ó B</button>
        <button class="btn-determinant" onclick="calculate('determinant')">üìä Det(A)</button>
        <button class="btn-inverse" onclick="calculate('inverse')">üîÑ‚Åª¬π Inverse A‚Åª¬π</button>
      </div>
    </div>
    
    <div class="result-section" id="result" style="display: none;">
      <div class="row">
        <div class="col-12">
          <h3>Step-by-Step Process</h3>
          <div id="processContainer"></div>
        </div>
      </div>
    </div>
  </div>
  
  <script>
    let stepDelay = 0;

    function updateMatrices() {
      const sizeA = document.getElementById('sizeA').value.split('x');
      const sizeB = document.getElementById('sizeB').value.split('x');
      
      createMatrixInputs('matrixA', parseInt(sizeA[0]), parseInt(sizeA[1]));
      createMatrixInputs('matrixB', parseInt(sizeB[0]), parseInt(sizeB[1]));
      
      document.getElementById('result').style.display = 'none';
    }
    
    function createMatrixInputs(id, rows, cols) {
      const container = document.getElementById(id);
      container.innerHTML = '';
      container.style.gridTemplateColumns = `repeat(${cols}, 60px)`;
      
      for (let i = 0; i < rows * cols; i++) {
        const input = document.createElement('input');
        input.type = 'number';
        input.value = Math.floor(Math.random() * 10);
        input.step = 'any';
        container.appendChild(input);
      }
    }
    
    function getMatrix(id) {
      const sizeStr = id === 'matrixA' ? 
        document.getElementById('sizeA').value :
        document.getElementById('sizeB').value;
      
      const size = sizeStr.split('x');
      const rows = parseInt(size[0]);
      const cols = parseInt(size[1]);
      
      const inputs = document.getElementById(id).getElementsByTagName('input');
      const matrix = [];
      
      for (let i = 0; i < rows; i++) {
        matrix[i] = [];
        for (let j = 0; j < cols; j++) {
          matrix[i][j] = parseFloat(inputs[i * cols + j].value) || 0;
        }
      }
      
      return matrix;
    }
    
    function displayMatrix(matrix, label = '') {
      const div = document.createElement('div');
      div.className = 'matrix-display';
      
      if (label) {
        const labelDiv = document.createElement('div');
        labelDiv.style.marginBottom = '10px';
        labelDiv.style.fontWeight = '600';
        labelDiv.textContent = label;
        div.appendChild(labelDiv);
      }
      
      matrix.forEach(row => {
        const rowDiv = document.createElement('div');
        rowDiv.className = 'matrix-row';
        row.forEach(val => {
          const cell = document.createElement('div');
          cell.className = 'matrix-cell';
          if (val instanceof Fraction) {
            cell.textContent = val.toString();
          } else if (isNaN(val) || !isFinite(val)) {
            cell.textContent = '0.00'; // Handle NaN/Infinity
          } else {
            cell.textContent = Number.isInteger(val) ? val : val.toFixed(2);
          }
          rowDiv.appendChild(cell);
        });
        div.appendChild(rowDiv);
      });
      
      return div;
    }
    
    function displayAugmented(matrix, label = '') {
      const div = document.createElement('div');
      div.className = 'matrix-display';
      
      if (label) {
        const labelDiv = document.createElement('div');
        labelDiv.style.marginBottom = '10px';
        labelDiv.style.fontWeight = '600';
        labelDiv.textContent = label;
        div.appendChild(labelDiv);
      }
      
      const n = matrix.length; // Size of square matrix A
      
      matrix.forEach(row => {
        const rowDiv = document.createElement('div');
        rowDiv.className = 'matrix-row';
        
        // Left side: original matrix A
        for (let j = 0; j < n; j++) {
          const cell = document.createElement('div');
          cell.className = 'matrix-cell';
          const val = row[j];
          if (val instanceof Fraction) {
            cell.textContent = val.toString();
          } else if (isNaN(val) || !isFinite(val)) {
            cell.textContent = '0.00'; // Handle NaN/Infinity
          } else {
            cell.textContent = Number.isInteger(val) ? val : val.toFixed(2);
          }
          rowDiv.appendChild(cell);
        }

        // Vertical separator
        const separator = document.createElement('div');
        separator.className = 'matrix-cell matrix-separator';
        separator.textContent = '|';
        separator.style.fontWeight = 'bold';
        separator.style.color = '#667eea';
        rowDiv.appendChild(separator);

        // Right side: identity matrix I
        for (let j = n; j < 2 * n; j++) {
          const cell = document.createElement('div');
          cell.className = 'matrix-cell';
          const val = row[j];
          if (val instanceof Fraction) {
            cell.textContent = val.toString();
          } else if (isNaN(val) || !isFinite(val)) {
            cell.textContent = '0.00'; // Handle NaN/Infinity
          } else {
            cell.textContent = Number.isInteger(val) ? val : val.toFixed(2);
          }
          rowDiv.appendChild(cell);
        }
        
        div.appendChild(rowDiv);
      });
      
      return div;
    }
    
    function addStep(title, content, delay = 500) {
      setTimeout(() => {
        const container = document.getElementById('processContainer');
        const step = document.createElement('div');
        step.className = 'step';
        step.style.animationDelay = '0s';
        
        const titleDiv = document.createElement('div');
        titleDiv.className = 'step-title';
        titleDiv.textContent = title;
        
        const contentDiv = document.createElement('div');
        contentDiv.className = 'step-content';
        if (typeof content === 'string') {
          contentDiv.innerHTML = content;
        } else {
          contentDiv.appendChild(content);
        }
        
        step.appendChild(titleDiv);
        step.appendChild(contentDiv);
        container.appendChild(step);
        
        // Auto-scroll to keep the latest step visible
        setTimeout(() => {
          step.scrollIntoView({ behavior: 'smooth', block: 'end' });
        }, 100);
      }, stepDelay);
      
      stepDelay += delay;
    }
    
    function addTheoreticalExplanation(title, content) {
      setTimeout(() => {
        const container = document.getElementById('processContainer');
        const explanation = document.createElement('div');
        explanation.className = 'theoretical-explanation';
        
        const titleDiv = document.createElement('div');
        titleDiv.className = 'step-title';
        titleDiv.textContent = title;
        
        const contentDiv = document.createElement('div');
        contentDiv.className = 'theoretical-content';
        contentDiv.textContent = content;
        
        explanation.appendChild(titleDiv);
        explanation.appendChild(contentDiv);
        container.appendChild(explanation);
        
        // Auto-scroll to keep the latest explanation visible
        setTimeout(() => {
          explanation.scrollIntoView({ behavior: 'smooth', block: 'end' });
        }, 100);
      }, stepDelay);
      
      stepDelay += 1000; // Give more time for theoretical explanations
    }
    
    function calculate(operation) {
      stepDelay = 0;
      const resultDiv = document.getElementById('result');
      const container = document.getElementById('processContainer');
      
      resultDiv.style.display = 'block';
      container.innerHTML = '';
      
      const matrixA = getMatrix('matrixA');
      const matrixB = getMatrix('matrixB');
      
      try {
        switch(operation) {
          case 'multiply':
            multiplyMatrices(matrixA, matrixB);
            break;
          case 'determinant':
            calculateDeterminant(matrixA);
            break;
          case 'inverse':
            calculateInverse(matrixA);
            break;
        }
      } catch (error) {
        container.innerHTML = `<div class="error">${error.message}</div>`;
      }
    }
    
    function multiplyMatrices(A, B) {
      const result = multiplyMatricesCalc(A, B);
      
      addStep('Step 1: Matrix Multiplication Setup', `Multiplying ${A.length}√ó${A[0].length} matrix with ${B.length}√ó${B[0].length} matrix`, 750);
      
      // Create visual multiplication display - synchronized with first step
      setTimeout(() => {
        const visualDiv = document.createElement('div');
        visualDiv.className = 'visual-calculation';
        visualDiv.innerHTML = `
          <div id="matrixA-visual">${displayMatrix(A, 'Matrix A').outerHTML}</div>
          <div class="calc-arrow">√ó</div>
          <div id="matrixB-visual">${displayMatrix(B, 'Matrix B').outerHTML}</div>
          <div class="calc-arrow">=</div>
          <div id="result-visual">${displayMatrix(result, 'Result C').outerHTML}</div>
        `;
        addVisualElement(visualDiv);
      }, stepDelay);
      
      for (let i = 0; i < A.length; i++) {
        for (let j = 0; j < B[0].length; j++) {
          let calculation = '';
          
          // Start processing this result cell
          setTimeout(() => {
            highlightResultProcessing('result-visual', i, j);
            highlightRow('matrixA-visual', i);
            highlightCol('matrixB-visual', j);
          }, stepDelay);
          
          addStep(`Computing C[${i+1},${j+1}]`, `Row ${i+1} of A √ó Column ${j+1} of B`, 1800);
          
          for (let k = 0; k < A[0].length; k++) {
            calculation += `${A[i][k]}√ó${B[k][j]}`;
            if (k < A[0].length - 1) calculation += ' + ';
            
            // Animate individual multiplication - highlight specific cells being multiplied
            setTimeout(() => {
              highlightCell('matrixA-visual', i, k);
              highlightCell('matrixB-visual', k, j); // This is the specific digit in the column
            }, stepDelay);
            
            addStep(
              `Step: A[${i+1},${k+1}] √ó B[${k+1},${j+1}]`,
              `${A[i][k]} √ó ${B[k][j]} = ${A[i][k] * B[k][j]}`,
              1500
            );
          }
          
          // Update result matrix with final value
          setTimeout(() => {
            updateResultCell('result-visual', i, j, result[i][j]);
            clearHighlights();
          }, stepDelay);
          
          addStep(
            `C[${i+1},${j+1}] Complete`,
            `${calculation} = ${result[i][j]}`,
            1800
          );
        }
      }
      
      setTimeout(() => {
        addVisualElement(displayMatrix(result, 'Final Result: A √ó B'));
        
        // Add theoretical explanation
        setTimeout(() => {
          addTheoreticalExplanation('Matrix Multiplication Theory', 
            'Matrix multiplication combines rows from the first matrix with columns from the second matrix using dot products. For element C·µ¢‚±º, take row i from matrix A and column j from matrix B, multiply corresponding elements, and sum the results. The inner dimensions must match (columns of A = rows of B). Result dimensions are (rows of A) √ó (columns of B). Matrix multiplication is not commutative (A √ó B ‚â† B √ó A in general).');
        }, 750);
      }, stepDelay + 1500);
      
      return result;
    }
    
    function calculateDeterminant(A) {
      const n = A.length;

      // For 2√ó2 matrices, use special formula first for quick reference
      if (n === 2) {
        const det = A[0][0] * A[1][1] - A[0][1] * A[1][0];
        addStep('Step 1: 2√ó2 Determinant Formula', `det([${A[0][0]} ${A[0][1]}; ${A[1][0]} ${A[1][1]}]) = (${A[0][0]} √ó ${A[1][1]}) - (${A[0][1]} √ó ${A[1][0]}) = ${det}`, 750);

        // Visual 2x2 determinant calculation - synchronized with step
        setTimeout(() => {
          const visualDiv = document.createElement('div');
          visualDiv.className = 'visual-calculation';
          visualDiv.innerHTML = `
            <div>${displayMatrix(A, 'Matrix A').outerHTML}</div>
            <div class="calc-arrow">det</div>
            <div class="formula-display">
              (${A[0][0]} √ó ${A[1][1]}) - (${A[0][1]} √ó ${A[1][0]}) = ${det}
            </div>
          `;

          addVisualElement(visualDiv);
        }, stepDelay);

        setTimeout(() => {
          const finalResultDiv = document.createElement('div');
          finalResultDiv.style.fontSize = '24px';
          finalResultDiv.style.fontWeight = '600';
          finalResultDiv.style.color = '#667eea';
          finalResultDiv.textContent = `Determinant = ${det}`;
          addVisualElement(finalResultDiv);

          // Add theoretical explanation
          setTimeout(() => {
            addTheoreticalExplanation('2√ó2 Determinant Theory',
              'For a 2√ó2 matrix [a b; c d], the determinant is ad - bc. This formula comes from the area of the parallelogram formed by the column vectors. A non-zero determinant indicates the matrix is invertible. If determinant is zero, the matrix is singular and has no inverse.');
          }, 750);
        }, stepDelay + 1000);
        return det;
      }

      // For larger matrices, use Gaussian elimination method
      addStep('Step 1: Gaussian Elimination Setup',
        `Using Gaussian elimination to find determinant of ${n}√ó${n} matrix via row reduction to upper triangular form`, 750);

      // Create a copy of the matrix to work with
      const working = deepCopyMatrix(A);

      // Display original matrix
      const initialCopy = deepCopyMatrix(working);
      addStep('Original Matrix', displayMatrix(initialCopy, 'Matrix A'), 1000);

      let rowSwaps = 0;
      let useFractions = false;

      // Convert to upper triangular form using Gaussian elimination
      for (let col = 0; col < n; col++) {
        // Find best pivot
        let bestRow = col;
        let bestValue = working[col][col];

        // First pass: look for ¬±1 pivots
        for (let row = col; row < n; row++) {
          const val = working[row][col];
          if (Math.abs(val) === 1) {
            bestRow = row;
            bestValue = val;
            break;
          }
        }

        // Second pass: if no ¬±1, prefer smallest non-zero absolute value
        if (Math.abs(bestValue) !== 1) {
          for (let row = col; row < n; row++) {
            const val = working[row][col];
            if (val !== 0 && (bestValue === 0 || Math.abs(val) < Math.abs(bestValue))) {
              bestRow = row;
              bestValue = val;
            }
          }
        }

        if (bestValue === 0) {
          addStep('Singular Matrix', 'Found zero column - matrix is singular, determinant = 0', 1000);
          return 0;
        }

        // Swap rows if needed
        if (bestRow !== col) {
          [working[col], working[bestRow]] = [working[bestRow], working[col]];
          rowSwaps++;

          addStep(`Column ${col + 1}: Row Swap`,
            `Interchanging Row ${col + 1} ‚Üî Row ${bestRow + 1} (determinant sign will flip)`, 1000);

          const swapCopy = deepCopyMatrix(working);
          setTimeout(() => {
            addVisualElement(displayMatrix(swapCopy, `Matrix after row ${col + 1} ‚Üî ${bestRow + 1} swap`));
          }, stepDelay);
        }

        // Check if fractions will be needed for elimination
        const pivotValue = working[col][col];

        if (!useFractions) {
          let needsFractions = false;
          for (let row = col + 1; row < n; row++) {
            const factor = working[row][col];
            if (factor !== 0 && factor % pivotValue !== 0) {
              needsFractions = true;
              break;
            }
          }

          if (needsFractions) {
            addStep('Introducing Fractions', 'Elimination will create non-integer results. Switching to fraction arithmetic for exact calculations.', 1000);
            useFractions = true;
            convertToFractionMatrix(working);
          }
        }

        // Eliminate entries below the diagonal (for upper triangular form)
        for (let row = col + 1; row < n; row++) {
          const factor = working[row][col];
          const isNonZero = useFractions ? !factor.isZero() : (factor !== 0);
          if (isNonZero) {
            let eliminationFactor;
            let eliminationLabel;

            if (useFractions) {
              const pivotFraction = Fraction.from(working[col][col]);
              eliminationFactor = factor.divide(pivotFraction);
              eliminationLabel = eliminationFactor.toString();
            } else {
              const pivotValueElim = working[col][col];
              eliminationFactor = factor / pivotValueElim;
              eliminationLabel = eliminationFactor;
            }

            addStep(`Column ${col + 1}: Eliminate Row ${row + 1}`,
              `Row ${row + 1} = Row ${row + 1} - (${eliminationLabel}) √ó Row ${col + 1}`, 1000);

            if (useFractions) {
              for (let j = col; j < n; j++) {
                working[row][j] = working[row][j].subtract(eliminationFactor.multiply(working[col][j]));
              }
              working[row][col] = Fraction.from(0);
            } else {
              for (let j = col; j < n; j++) {
                working[row][j] = working[row][j] - eliminationFactor * working[col][j];
              }
              working[row][col] = 0;
            }

            const eliminationCopy = deepCopyMatrix(working);
            setTimeout(() => {
              addVisualElement(displayMatrix(eliminationCopy, `Matrix after eliminating Row ${row + 1}, Column ${col + 1}`));
            }, stepDelay);
          }
        }
      }

      // Upper triangular form achieved - calculate determinant
      addStep('Calculate Determinant', 'Upper triangular form achieved. Determinant = (product of diagonal) √ó (sign from row swaps)', 1500);

      const displayCopy = deepCopyMatrix(working);
      setTimeout(() => {
        addVisualElement(displayMatrix(displayCopy, 'Upper Triangular Matrix'));
      }, stepDelay);

      // Multiply diagonal elements
      let det = useFractions ? Fraction.from(1) : 1;
      let diagProductStr = '';

      for (let i = 0; i < n; i++) {
        const val = working[i][i];
        if (useFractions) {
          det = det.multiply(val);
          diagProductStr += (i > 0 ? ' √ó ' : '') + val.toString();
        } else {
          det = det * val;
          diagProductStr += (i > 0 ? ' √ó ' : '') + val;
        }
      }

      // Apply row swap sign
      const signFactor = Math.pow(-1, rowSwaps);
      if (useFractions) {
        det = det.multiply(Fraction.from(signFactor));
      } else {
        det = det * signFactor;
      }

      if (useFractions) {
        addStep('Final Calculation', 
          `det = (${diagProductStr}) √ó ${signFactor === 1 ? '(+1)' : '(-1)'} = ${det.toString()}`, 1000);
      } else {
        addStep('Final Calculation', 
          `det = (${diagProductStr}) √ó ${signFactor === 1 ? '(+1)' : '(-1)'} = ${det}`, 1000);
      }

      const finalValue = useFractions ? det.toFloat() : det;

      setTimeout(() => {
        const finalResultDiv = document.createElement('div');
        finalResultDiv.style.fontSize = '24px';
        finalResultDiv.style.fontWeight = '600';
        finalResultDiv.style.color = '#667eea';
        finalResultDiv.textContent = `Determinant = ${finalValue.toFixed(6)}`;
        addVisualElement(finalResultDiv);

        // Add theoretical explanation
        setTimeout(() => {
          addTheoreticalExplanation('Determinant Theory (Gaussian Elimination)',
            'Gaussian elimination calculates determinant by reducing the matrix to upper triangular form using row swaps and row addition operations. Key properties: (1) Row swaps negate the determinant, (2) Adding a multiple of one row to another leaves the determinant unchanged, (3) Once in triangular form, the determinant equals the product of the diagonal elements times (-1) raised to the number of row swaps. This method is O(n¬≥) and much more efficient than cofactor expansion which is O(n!).');
        }, 750);

        // Cross-check with cofactor method
        setTimeout(() => {
          addStep('Cross-Check: Cofactor Method', 'Verifying result using cofactor expansion method', 1500);

          try {
            const cofactorDet = calculateDeterminantCofactor(A);
            const matches = Math.abs(finalValue - cofactorDet) < 1e-6;

            if (matches) {
              addStep('Cross-Check Result',
                `‚úì Verified: Gaussian elimination (${finalValue.toFixed(6)}) matches cofactor method (${cofactorDet.toFixed(6)})`, 1200);
            } else {
              addStep('Cross-Check Result',
                `‚ö† Mismatch: Gaussian elimination (${finalValue.toFixed(6)}) vs Cofactor (${cofactorDet.toFixed(6)})`, 1200);
            }

            // Show cofactor expansion steps
            setTimeout(() => {
              addStep('Cofactor Expansion Details', `Using cofactor expansion along first row`, 1000);

              for (let j = 0; j < A.length; j++) {
                const minor = getMinor(A, 0, j);
                const sign = Math.pow(-1, j);
                const minorDet = calculateDeterminantCofactor(minor);
                const cofactor = sign * A[0][j] * minorDet;

                setTimeout(() => {
                  const visualDiv = document.createElement('div');
                  visualDiv.className = 'visual-calculation';
                  visualDiv.innerHTML = `
                    <div class="formula-display">
                      Cofactor [1,${j+1}] = ${sign === 1 ? '+' : '-'}${A[0][j]} √ó det(
                    </div>
                    <div>${displayMatrix(minor, `Minor M‚ÇÅ,${j+1}`).outerHTML}</div>
                    <div class="formula-display">
                      ) = ${sign === 1 ? '+' : '-'}${A[0][j]} √ó ${minorDet.toFixed(2)} = ${cofactor.toFixed(2)}
                    </div>
                  `;

                  addVisualElement(visualDiv);
                }, stepDelay);

                addStep(
                  `Cofactor Accumulation`,
                  `det += ${cofactor.toFixed(2)}`,
                  1200
                );
              }

              setTimeout(() => {
                addStep('Cofactor Final Result', `Cofactor determinant = ${cofactorDet.toFixed(6)}`, 800);
              }, stepDelay + 200);

              setTimeout(() => {
                addTheoreticalExplanation('Cofactor Expansion Theory',
                  'Cofactor expansion calculates determinant by expanding along a row or column. Each term is (-1)‚Å±‚Å∫ ≤ √ó element √ó determinant of minor. While elegant and easy to understand, cofactor expansion becomes computationally expensive for larger matrices (factorial complexity). Gaussian elimination is more efficient for practical calculations.');
              }, stepDelay + 500);
            }, stepDelay + 500);
          } catch (e) {
            addStep('Cross-Check Result',
              '‚úó Could not verify with cofactor method (likely numerical precision issues)', 1200);
          }
        }, stepDelay + 500);
      }, stepDelay + 1000);

      return finalValue;
    }
    
    // Helper function to deep copy a matrix (handles both numbers and Fractions)
    function deepCopyMatrix(matrix) {
      return matrix.map(row => row.map(val => {
        if (val instanceof Fraction) {
          return new Fraction(val.num, val.den);
        }
        return val;
      }));
    }
    
    function calculateInverse(A) {
      const n = A.length;
      
      addStep('Step 1: Gauss-Jordan Elimination Setup',
        `Using Gauss-Jordan elimination with integer-first arithmetic to find inverse of ${n}√ó${n} matrix`, 750);

      // Create augmented matrix [A | I] - start with integers
      const augmented = Array(n).fill().map(() => Array(2 * n).fill(0));
      let useFractions = false;

      // Initialize with integers
      for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
          augmented[i][j] = A[i][j];
        }
        for (let j = 0; j < n; j++) {
          augmented[i][n + j] = (i === j) ? 1 : 0;
        }
      }

      // Display initial augmented matrix
      const initialCopy = deepCopyMatrix(augmented);
      setTimeout(() => {
        addVisualElement(displayAugmentedMatrix(initialCopy, '[A | I] Initial Augmented Matrix', useFractions));
      }, stepDelay);

      addStep('Strategy', 'Intelligently select pivots to avoid fractions: (1) Prefer ¬±1 pivots (no normalization needed), (2) Use smallest values (easier arithmetic), (3) Interchange rows when beneficial. Fractions introduced only when unavoidable.', 1200);

      // Gauss-Jordan elimination step by step
      for (let col = 0; col < n; col++) {
        // Find best pivot to avoid fractions
        // Priority: 1) ¬±1 (no normalization needed), 2) smallest non-zero absolute value, 3) any non-zero
        let bestRow = col;
        let bestValue = augmented[col][col];
        
        // First pass: look for ¬±1 pivots (ideal - no normalization needed)
        for (let row = col; row < n; row++) {
          const val = augmented[row][col];
          if (Math.abs(val) === 1) {
            bestRow = row;
            bestValue = val;
            break; // Found ideal pivot, use it
          }
        }
        
        // Second pass: if no ¬±1 found, prefer smallest non-zero absolute value
        // (easier to work with small numbers and more likely to divide evenly)
        if (Math.abs(bestValue) !== 1) {
          for (let row = col; row < n; row++) {
            const val = augmented[row][col];
            if (val !== 0 && (bestValue === 0 || Math.abs(val) < Math.abs(bestValue))) {
              bestRow = row;
              bestValue = val;
            }
          }
        }

        if (bestValue === 0) {
          throw new Error('Matrix is singular and has no inverse');
        }

        // Report row swap if needed
        if (bestRow !== col) {
          const pivotVal = augmented[bestRow][col];
          const reason = Math.abs(pivotVal) === 1 ? ' to avoid normalization (pivot is ¬±1)' : ' to use smaller pivot and avoid fractions';
          addStep(`Column ${col + 1}: Row Swap`,
            `Interchanging Row ${col + 1} ‚Üî Row ${bestRow + 1}${reason}. New pivot: ${pivotVal}`, 1200);
          [augmented[col], augmented[bestRow]] = [augmented[bestRow], augmented[col]];

          const swapCopy = deepCopyMatrix(augmented);
          setTimeout(() => {
            addVisualElement(displayAugmentedMatrix(swapCopy, `[A | I] after row interchange`, useFractions));
          }, stepDelay);
        } else {
          const pivotVal = augmented[col][col];
          const note = Math.abs(pivotVal) === 1 ? ' (no normalization needed!)' : '';
          addStep(`Column ${col + 1}: Pivot Selected`, `Using Row ${col + 1} with pivot value ${pivotVal}${note}`, 800);
        }

        // Normalize pivot row
        const pivotValue = augmented[col][col];
        if (pivotValue !== 1) {
          if (useFractions || !useIntegerDivision(augmented[col], pivotValue)) {
            // Need to use fractions
            if (!useFractions) {
              addStep('Introducing Fractions', 'Division creates non-integer results. Switching to fraction arithmetic for exact calculations.', 1000);
              useFractions = true;
              convertToFractionMatrix(augmented);
            }
            
            addStep(`Column ${col + 1}: Normalize Pivot`,
              `Divide Row ${col + 1} by ${pivotValue} to make pivot = 1`, 1200);

            const pivotFraction = Fraction.from(pivotValue);
            for (let j = 0; j < 2 * n; j++) {
              augmented[col][j] = augmented[col][j].divide(pivotFraction);
            }
          } else {
            // Can use integer division
            addStep(`Column ${col + 1}: Normalize Pivot (Integer)`,
              `Divide Row ${col + 1} by ${pivotValue} (all results remain integers)`, 1200);

            for (let j = 0; j < 2 * n; j++) {
              augmented[col][j] = augmented[col][j] / pivotValue;
            }
          }

          const pivotCopy = deepCopyMatrix(augmented);
          setTimeout(() => {
            addVisualElement(displayAugmentedMatrix(pivotCopy, `[A | I] after normalizing pivot row`, useFractions));
          }, stepDelay);
        }

        // Eliminate other entries in this column
        for (let row = 0; row < n; row++) {
          if (row !== col) {
            const factor = augmented[row][col];
            if (factor !== 0) {
              if (useFractions) {
                const factorFraction = factor;
                addStep(`Column ${col + 1}: Eliminate Row ${row + 1}`,
                  `Row ${row + 1} = Row ${row + 1} - (${factorFraction.toString()}) √ó Row ${col + 1}`, 1000);

                for (let j = 0; j < 2 * n; j++) {
                  augmented[row][j] = augmented[row][j].subtract(factorFraction.multiply(augmented[col][j]));
                }
              } else {
                addStep(`Column ${col + 1}: Eliminate Row ${row + 1}`,
                  `Row ${row + 1} = Row ${row + 1} - (${factor}) √ó Row ${col + 1}`, 1000);

                for (let j = 0; j < 2 * n; j++) {
                  augmented[row][j] = augmented[row][j] - factor * augmented[col][j];
                }
              }

              const eliminationCopy = deepCopyMatrix(augmented);
              setTimeout(() => {
                addVisualElement(displayAugmentedMatrix(eliminationCopy, `[A | I] after eliminating row ${row + 1}`, useFractions));
              }, stepDelay);
            }
          }
        }

        addStep(`Column ${col + 1} Complete`,
          `Column ${col + 1} now has 1 at position [${col + 1},${col + 1}] and 0s elsewhere`, 800);
      }

      // Extract and display final inverse
      const inverse = [];
      for (let i = 0; i < n; i++) {
        inverse[i] = [];
        for (let j = 0; j < n; j++) {
          if (useFractions) {
            inverse[i][j] = augmented[i][n + j].toFloat();
          } else {
            inverse[i][j] = augmented[i][n + j];
          }
        }
      }

      setTimeout(() => {
        addVisualElement(displayMatrix(inverse, 'Final Inverse Matrix A‚Åª¬π'));

        // Cross-check with cofactor method
        setTimeout(() => {
          try {
            const inverseCofactor = calculateInverseCofactor(A);
            const cofactorMatches = true;
            for (let i = 0; i < n && cofactorMatches; i++) {
              for (let j = 0; j < n && cofactorMatches; j++) {
                if (Math.abs(inverse[i][j] - inverseCofactor[i][j]) > 1e-6) {
                  throw new Error('Mismatch detected');
                }
              }
            }

            if (cofactorMatches) {
              addStep('Cross-Check: Cofactor Method',
                '‚úì Verified: Result matches inverse calculated via cofactor method', 1200);
            }
          } catch (e) {
            addStep('Cross-Check: Cofactor Method',
              '‚úó Warning: Could not verify with cofactor method (likely singular or numerical issues)', 1200);
          }
        }, stepDelay + 500);

        setTimeout(() => {
          addTheoreticalExplanation('Gauss-Jordan Elimination with Integer-First Arithmetic',
            'This implementation prioritizes integer arithmetic to keep calculations simple and exact. Key features: (1) Integer-First Approach - uses integers as long as possible, only introducing fractions when necessary, (2) Smart Division Check - verifies if division will produce integer results before proceeding, (3) Step-by-Step Visualization - shows every row operation and matrix transformation, (4) Fraction Introduction - clearly marks when fractions become unavoidable. The algorithm transforms [A | I] into [I | A‚Åª¬π] through elementary row operations.');
        }, stepDelay + 1000);
      }, stepDelay + 1500);

      return inverse;
    }

    // Helper function to check if integer division is possible
    function useIntegerDivision(row, divisor) {
      for (let j = 0; j < row.length; j++) {
        if (row[j] % divisor !== 0) {
          return false;
        }
      }
      return true;
    }

    // Helper function to convert integer matrix to fraction matrix
    function convertToFractionMatrix(matrix) {
      for (let i = 0; i < matrix.length; i++) {
        for (let j = 0; j < matrix[i].length; j++) {
          matrix[i][j] = Fraction.from(matrix[i][j]);
        }
      }
    }

    // Display augmented matrix (handles both integer and fraction modes)
    function displayAugmentedMatrix(matrix, label = '', useFractions = false) {
      const div = document.createElement('div');
      div.className = 'matrix-display';

      if (label) {
        const labelDiv = document.createElement('div');
        labelDiv.style.marginBottom = '10px';
        labelDiv.style.fontWeight = '600';
        labelDiv.textContent = label;
        div.appendChild(labelDiv);
      }

      const n = matrix.length;

      matrix.forEach(row => {
        const rowDiv = document.createElement('div');
        rowDiv.className = 'matrix-row';

        // Left side: original matrix A
        for (let j = 0; j < n; j++) {
          const cell = document.createElement('div');
          cell.className = 'matrix-cell';
          const val = row[j];
          if (useFractions && val instanceof Fraction) {
            cell.textContent = val.toString();
          } else if (isNaN(val) || !isFinite(val)) {
            cell.textContent = '0';
          } else {
            cell.textContent = Number.isInteger(val) ? val : val.toFixed(2);
          }
          rowDiv.appendChild(cell);
        }

        // Vertical separator
        const separator = document.createElement('div');
        separator.className = 'matrix-cell matrix-separator';
        separator.textContent = '|';
        separator.style.fontWeight = 'bold';
        separator.style.color = '#667eea';
        rowDiv.appendChild(separator);

        // Right side: identity then inverse
        for (let j = n; j < 2 * n; j++) {
          const cell = document.createElement('div');
          cell.className = 'matrix-cell';
          const val = row[j];
          if (useFractions && val instanceof Fraction) {
            cell.textContent = val.toString();
          } else if (isNaN(val) || !isFinite(val)) {
            cell.textContent = '0';
          } else {
            cell.textContent = Number.isInteger(val) ? val : val.toFixed(2);
          }
          rowDiv.appendChild(cell);
        }

        div.appendChild(rowDiv);
      });

      return div;
    }

    // Display augmented matrix with fractions
    function displayAugmentedFractions(matrix, label = '') {
      const div = document.createElement('div');
      div.className = 'matrix-display';

      if (label) {
        const labelDiv = document.createElement('div');
        labelDiv.style.marginBottom = '10px';
        labelDiv.style.fontWeight = '600';
        labelDiv.textContent = label;
        div.appendChild(labelDiv);
      }

      const n = matrix.length;

      matrix.forEach(row => {
        const rowDiv = document.createElement('div');
        rowDiv.className = 'matrix-row';

        // Left side: original matrix A
        for (let j = 0; j < n; j++) {
          const cell = document.createElement('div');
          cell.className = 'matrix-cell';
          const val = row[j];
          if (val instanceof Fraction) {
            cell.textContent = val.toString();
          } else if (isNaN(val) || !isFinite(val)) {
            cell.textContent = '0';
          } else {
            cell.textContent = Number.isInteger(val) ? val : val.toFixed(2);
          }
          rowDiv.appendChild(cell);
        }

        // Vertical separator
        const separator = document.createElement('div');
        separator.className = 'matrix-cell matrix-separator';
        separator.textContent = '|';
        separator.style.fontWeight = 'bold';
        separator.style.color = '#667eea';
        rowDiv.appendChild(separator);

        // Right side: identity then inverse
        for (let j = n; j < 2 * n; j++) {
          const cell = document.createElement('div');
          cell.className = 'matrix-cell';
          const val = row[j];
          if (val instanceof Fraction) {
            cell.textContent = val.toString();
          } else if (isNaN(val) || !isFinite(val)) {
            cell.textContent = '0';
          } else {
            cell.textContent = Number.isInteger(val) ? val : val.toFixed(2);
          }
          rowDiv.appendChild(cell);
        }

        div.appendChild(rowDiv);
      });

      return div;
    }
    
    function highlightRow(matrixId, rowIndex) {
      const matrixDiv = document.getElementById(matrixId);
      if (!matrixDiv) return;
      
      const rows = matrixDiv.querySelectorAll('.matrix-row');
      rows.forEach((row, index) => {
        if (index === rowIndex) {
          row.classList.add('highlight-row');
        } else {
          row.classList.remove('highlight-row');
        }
      });
    }
    
    function highlightCol(matrixId, colIndex) {
      const matrixDiv = document.getElementById(matrixId);
      if (!matrixDiv) return;
      
      const rows = matrixDiv.querySelectorAll('.matrix-row');
      rows.forEach(row => {
        const cells = row.querySelectorAll('.matrix-cell');
        cells.forEach((cell, index) => {
          if (index === colIndex) {
            cell.classList.add('highlight-col');
          } else {
            cell.classList.remove('highlight-col');
          }
        });
      });
    }
    
    function highlightCell(matrixId, rowIndex, colIndex) {
      const matrixDiv = document.getElementById(matrixId);
      if (!matrixDiv) return;
      
      const rows = matrixDiv.querySelectorAll('.matrix-row');
      if (rows[rowIndex]) {
        const cells = rows[rowIndex].querySelectorAll('.matrix-cell');
        if (cells[colIndex]) {
          cells[colIndex].classList.add('highlight-cell');
          setTimeout(() => cells[colIndex].classList.remove('highlight-cell'), 800);
        }
      }
    }
    
    function highlightResultProcessing(matrixId, rowIndex, colIndex) {
      const matrixDiv = document.getElementById(matrixId);
      if (!matrixDiv) return;
      
      const rows = matrixDiv.querySelectorAll('.matrix-row');
      if (rows[rowIndex]) {
        const cells = rows[rowIndex].querySelectorAll('.matrix-cell');
        if (cells[colIndex]) {
          cells[colIndex].classList.add('highlight-processing');
        }
      }
    }
    
    function updateResultCell(matrixId, rowIndex, colIndex, value) {
      const matrixDiv = document.getElementById(matrixId);
      if (!matrixDiv) return;
      
      const rows = matrixDiv.querySelectorAll('.matrix-row');
      if (rows[rowIndex]) {
        const cells = rows[rowIndex].querySelectorAll('.matrix-cell');
        if (cells[colIndex]) {
          cells[colIndex].textContent = Number.isInteger(value) ? value : value.toFixed(2);
          cells[colIndex].classList.add('highlight');
          setTimeout(() => cells[colIndex].classList.remove('highlight'), 1000);
        }
      }
    }
    
    function clearHighlights() {
      document.querySelectorAll('.highlight, .highlight-row, .highlight-col, .highlight-cell, .highlight-processing').forEach(el => {
        el.classList.remove('highlight', 'highlight-row', 'highlight-col', 'highlight-cell', 'highlight-processing');
      });
    }
    
    function addVisualElement(element) {
      const container = document.getElementById('processContainer');
      container.appendChild(element);
      
      // Auto-scroll to keep the latest visual element visible
      setTimeout(() => {
        element.scrollIntoView({ behavior: 'smooth', block: 'end' });
      }, 100);
    }
    
    function getMinor(matrix, row, col) {
      return matrix
        .filter((_, i) => i !== row)
        .map(r => r.filter((_, j) => j !== col));
    }
    
    function calcDet(matrix) {
      const n = matrix.length;
      
      if (n === 1) return matrix[0][0];
      if (n === 2) return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0];
      
      let det = 0;
      for (let j = 0; j < n; j++) {
        det += Math.pow(-1, j) * matrix[0][j] * calcDet(getMinor(matrix, 0, j));
      }
      return det;
    }
    
    // Pure calculation functions (no UI)

    
    function multiplyMatricesCalc(A, B) {
      const rowsA = A.length;
      const colsA = A[0].length;
      const colsB = B[0].length;
      
      if (colsA !== B.length) {
        throw new Error('Number of columns in A must equal number of rows in B');
      }
      
      const result = Array(rowsA).fill().map(() => Array(colsB).fill(0));
      
      for (let i = 0; i < rowsA; i++) {
        for (let j = 0; j < colsB; j++) {
          for (let k = 0; k < colsA; k++) {
            result[i][j] += A[i][k] * B[k][j];
          }
        }
      }
      return result;
    }


    
    // Fraction class for exact arithmetic
    class Fraction {
      constructor(num, den = 1) {
        if (den === 0) throw new Error('Denominator cannot be zero');
        const g = this.gcd(Math.abs(num), Math.abs(den));
        this.num = Math.sign(den) * (num / g);
        this.den = Math.abs(den) / g;
      }

      gcd(a, b) {
        return b === 0 ? a : this.gcd(b, a % b);
      }

      static from(val) {
        if (val instanceof Fraction) return val;
        if (Number.isInteger(val)) return new Fraction(val, 1);
        // Handle floating point by finding fraction representation
        const str = val.toString();
        if (str.includes('e') || str.includes('E')) {
          return new Fraction(val);
        }
        const decimalPlaces = (str.split('.')[1] || '').length;
        const multiplier = Math.pow(10, decimalPlaces);
        return new Fraction(Math.round(val * multiplier), multiplier);
      }

      add(other) {
        other = Fraction.from(other);
        return new Fraction(this.num * other.den + other.num * this.den, this.den * other.den);
      }

      subtract(other) {
        other = Fraction.from(other);
        return new Fraction(this.num * other.den - other.num * this.den, this.den * other.den);
      }

      multiply(other) {
        other = Fraction.from(other);
        return new Fraction(this.num * other.num, this.den * other.den);
      }

      divide(other) {
        other = Fraction.from(other);
        if (other.num === 0) throw new Error('Division by zero');
        return new Fraction(this.num * other.den, this.den * other.num);
      }

      isZero() {
        return this.num === 0;
      }

      isOne() {
        return this.num === this.den;
      }

      negate() {
        return new Fraction(-this.num, this.den);
      }

      toFloat() {
        return this.num / this.den;
      }

      toString() {
        if (this.den === 1) return `${this.num}`;
        if (this.num === 0) return '0';
        return `${this.num}/${this.den}`;
      }

      toLatex() {
        if (this.den === 1) return `${this.num}`;
        return `\\frac{${this.num}}{${this.den}}`;
      }
    }

    function calculateDeterminantCalc(A) {
      const n = A.length;

      if (n !== A[0].length) {
        throw new Error('Matrix must be square to calculate determinant');
      }

      return calcDet(A);
    }

    // Calculate determinant using cofactor expansion (for cross-checking)
    function calculateDeterminantCofactor(A) {
      const n = A.length;
      if (n === 1) return A[0][0];
      if (n === 2) return A[0][0] * A[1][1] - A[0][1] * A[1][0];

      let det = 0;
      for (let j = 0; j < n; j++) {
        det += Math.pow(-1, j) * A[0][j] * calculateDeterminantCofactor(getMinor(A, 0, j));
      }
      return det;
    }

    // Calculate inverse using cofactor method (for cross-checking)
    function calculateInverseCofactor(A) {
      const n = A.length;
      if (n !== A[0].length) {
        throw new Error('Matrix must be square to calculate inverse');
      }

      const det = calculateDeterminantCofactor(A);
      if (Math.abs(det) < 1e-10) {
        throw new Error('Matrix is singular and has no inverse');
      }

      if (n === 1) {
        return [[1 / A[0][0]]];
      }

      if (n === 2) {
        return [
          [A[1][1] / det, -A[0][1] / det],
          [-A[1][0] / det, A[0][0] / det]
        ];
      }

      const adjugate = [];
      for (let i = 0; i < n; i++) {
        adjugate[i] = [];
        for (let j = 0; j < n; j++) {
          const minor = getMinor(A, j, i);
          const cofactor = Math.pow(-1, i + j) * calculateDeterminantCofactor(minor);
          adjugate[i][j] = cofactor / det;
        }
      }

      return adjugate;
    }

    function calculateInverseCalc(A) {
      const n = A.length;

      if (n !== A[0].length) {
        throw new Error('Matrix must be square to calculate inverse');
      }

      // Create augmented matrix with Fractions [A | I]
      const augmented = Array(n).fill().map(() => Array(2 * n).fill(null));
      const rowSwaps = [];

      // Initialize with fractions
      for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
          augmented[i][j] = Fraction.from(A[i][j]);
        }
        // Identity matrix on right
        for (let j = 0; j < n; j++) {
          augmented[i][n + j] = Fraction.from(i === j ? 1 : 0);
        }
      }

      // Gauss-Jordan elimination with row swapping strategy
      for (let col = 0; col < n; col++) {
        // Find best pivot: prefer integer values, then non-zero
        let bestRow = col;
        let bestScore = -1;

        for (let row = col; row < n; row++) {
          const val = augmented[row][col];
          if (val.isZero()) continue;

          // Score: integer gets higher priority
          let score = Math.abs(val.toFloat());
          if (val.den === 1) score += 1000; // Strongly prefer integers

          if (score > bestScore) {
            bestScore = score;
            bestRow = row;
          }
        }

        // Check if we found a non-zero pivot
        if (augmented[bestRow][col].isZero()) {
          throw new Error('Matrix is singular and has no inverse');
        }

        // Swap rows if needed
        if (bestRow !== col) {
          [augmented[col], augmented[bestRow]] = [augmented[bestRow], augmented[col]];
          rowSwaps.push({ from: bestRow, to: col });
        }

        // Normalize pivot row to make pivot = 1
        const pivotValue = augmented[col][col];
        if (!pivotValue.isOne()) {
          for (let j = 0; j < 2 * n; j++) {
            augmented[col][j] = augmented[col][j].divide(pivotValue);
          }
        }

        // Eliminate other entries in this column
        for (let row = 0; row < n; row++) {
          if (row !== col) {
            const factor = augmented[row][col];
            if (!factor.isZero()) {
              for (let j = 0; j < 2 * n; j++) {
                augmented[row][j] = augmented[row][j].subtract(factor.multiply(augmented[col][j]));
              }
            }
          }
        }
      }

      // Extract inverse matrix and convert to floats
      const inverse = [];
      for (let i = 0; i < n; i++) {
        inverse[i] = [];
        for (let j = 0; j < n; j++) {
          inverse[i][j] = augmented[i][n + j].toFloat();
        }
      }

      // Store metadata for display
      inverse._rowSwaps = rowSwaps;

      return inverse;
    }
    

    
    // Matrix Test Functions
    function runMatrixTests() {
      const resultDiv = document.getElementById('result');
      const container = document.getElementById('processContainer');
      
      resultDiv.style.display = 'block';
      container.innerHTML = '';
      
      const testResults = [];
      
      // Matrix Multiplication Tests
      testResults.push(testMatrixMultiplication2x2());
      testResults.push(testMatrixMultiplication2x3_3x2());
      testResults.push(testMatrixMultiplicationIdentity());
      
      // Determinant Tests
      testResults.push(testDeterminant2x2());
      testResults.push(testDeterminant3x3());
      testResults.push(testDeterminantIdentity());
      
      // Matrix Inverse Tests
      testResults.push(testMatrixInverse2x2());
      testResults.push(testMatrixInverseIdentity());
      testResults.push(testMatrixInverseProperty());
      
      // Display results
      displayMatrixTestResults(testResults);
    }








    
    function testMatrixMultiplication2x2() {
      const A = [[1, 2], [3, 4]];
      const B = [[5, 6], [7, 8]];
      const result = multiplyMatricesCalc(A, B);
      const expected = [[19, 22], [43, 50]];
      const passed = matricesEqual(result, expected);
      return {
        name: 'Matrix Multiplication 2x2 √ó 2x2',
        passed: passed,
        expected: expected,
        actual: result
      };
    }
    
    function testMatrixMultiplication2x3_3x2() {
      const A = [[1, 2, 3], [4, 5, 6]];
      const B = [[7, 8], [9, 10], [11, 12]];
      const result = multiplyMatricesCalc(A, B);
      const expected = [[58, 64], [139, 154]];
      const passed = matricesEqual(result, expected);
      return {
        name: 'Matrix Multiplication 2x3 √ó 3x2',
        passed: passed,
        expected: expected,
        actual: result
      };
    }
    
    function testMatrixMultiplicationIdentity() {
      const A = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];
      const I = [[1, 0, 0], [0, 1, 0], [0, 0, 1]];
      const result = multiplyMatricesCalc(A, I);
      const passed = matricesEqual(result, A);
      return {
        name: 'Matrix Multiplication Identity: A √ó I = A',
        passed: passed,
        expected: 'Equal to original matrix',
        actual: passed ? 'Equal' : 'Not equal'
      };
    }



    
    function testDeterminant2x2() {
      const A = [[1, 2], [3, 4]];
      const result = calcDet(A);
      const expected = -2; // 1*4 - 2*3 = 4 - 6 = -2
      const passed = Math.abs(result - expected) < 1e-10;
      return {
        name: 'Determinant 2x2 Matrix',
        passed: passed,
        expected: expected,
        actual: result
      };
    }
    
    function testDeterminant3x3() {
      const A = [[1, 0, 2], [3, 2, 1], [4, 0, 3]];
      const result = calcDet(A);
      const expected = -10; // 1*(2*3-1*0) - 0*(3*3-1*4) + 2*(3*0-2*4) = 6 + 0 - 16 = -10
      const passed = Math.abs(result - expected) < 1e-10;
      return {
        name: 'Determinant 3x3 Matrix',
        passed: passed,
        expected: expected,
        actual: result
      };
    }
    
    function testDeterminantIdentity() {
      const I = [[1, 0, 0], [0, 1, 0], [0, 0, 1]];
      const result = calcDet(I);
      const passed = Math.abs(result - 1) < 1e-10;
      return {
        name: 'Determinant Identity Matrix = 1',
        passed: passed,
        expected: 1,
        actual: result
      };
    }
    
    function testMatrixInverse2x2() {
      const A = [[1, 2], [3, 4]];
      const result = calculateInverseCalc(A);
      const expected = [[-2, 1], [1.5, -0.5]]; // (1/(1*4-2*3)) * [4, -2; -3, 1] = (1/-2) * [4, -2; -3, 1] = [-2, 1; 1.5, -0.5]
      const passed = matricesEqual(result, expected);
      return {
        name: 'Matrix Inverse 2x2',
        passed: passed,
        expected: expected,
        actual: result
      };
    }
    
    function testMatrixInverseIdentity() {
      const I = [[1, 0], [0, 1]];
      const result = calculateInverseCalc(I);
      const passed = matricesEqual(result, I);
      return {
        name: 'Matrix Inverse Identity = Itself',
        passed: passed,
        expected: 'Equal to identity',
        actual: passed ? 'Equal' : 'Not equal'
      };
    }
    
    function testMatrixInverseProperty() {
      const A = [[2, 1], [1, 1]];
      const A_inv = calculateInverseCalc(A);
      const product = multiplyMatricesCalc(A, A_inv);
      const I = [[1, 0], [0, 1]];
      const passed = matricesEqual(product, I, 1e-8); // Allow for small floating point errors
      return {
        name: 'Matrix Inverse Property: A √ó A‚Åª¬π = I',
        passed: passed,
        expected: 'Equal to identity matrix',
        actual: passed ? 'Equal' : 'Not equal'
      };
    }
    
    function matricesEqual(A, B, tolerance = 1e-10) {
      if (A.length !== B.length || A[0].length !== B[0].length) return false;
      for (let i = 0; i < A.length; i++) {
        for (let j = 0; j < A[0].length; j++) {
          if (Math.abs(A[i][j] - B[i][j]) > tolerance) return false;
        }
      }
      return true;
    }
    
    function displayMatrixTestResults(results) {
      const resultContent = document.getElementById('processContainer');
      
      const resultsDiv = document.createElement('div');
      resultsDiv.className = 'test-results';
      
      const header = document.createElement('h3');
      header.textContent = 'Matrix Operation Tests';
      header.style.color = '#667eea';
      header.style.marginBottom = '20px';
      resultsDiv.appendChild(header);
      
      let passedCount = 0;
      results.forEach(result => {
        if (result.passed) passedCount++;
        
        const testDiv = document.createElement('div');
        testDiv.className = `test-result ${result.passed ? 'test-pass' : 'test-fail'}`;
        
        const nameSpan = document.createElement('span');
        nameSpan.className = 'test-name';
        nameSpan.textContent = result.name;
        
        const statusSpan = document.createElement('span');
        statusSpan.className = 'test-status';
        statusSpan.textContent = result.passed ? 'PASS' : 'FAIL';
        
        testDiv.appendChild(nameSpan);
        testDiv.appendChild(statusSpan);
        
        if (!result.passed) {
          const detailsDiv = document.createElement('div');
          detailsDiv.style.marginTop = '8px';
          detailsDiv.style.fontSize = '14px';
          if (Array.isArray(result.expected) && Array.isArray(result.expected[0])) {
            // Matrix display
            detailsDiv.innerHTML = `Expected:<br>${displayMatrix(result.expected).outerHTML}<br>Actual:<br>${displayMatrix(result.actual).outerHTML}`;
          } else {
            detailsDiv.innerHTML = `Expected: ${Array.isArray(result.expected) ? '[' + result.expected.map(row => '[' + row.join(', ') + ']').join('; ') + ']' : result.expected}<br>Actual: ${Array.isArray(result.actual) ? '[' + result.actual.map(row => '[' + row.join(', ') + ']').join('; ') + ']' : result.actual}`;
          }
          testDiv.appendChild(detailsDiv);
        }
        
        resultsDiv.appendChild(testDiv);
      });
      
      const summaryDiv = document.createElement('div');
      summaryDiv.style.marginTop = '20px';
      summaryDiv.style.padding = '15px';
      summaryDiv.style.background = passedCount === results.length ? '#d4edda' : '#f8d7da';
      summaryDiv.style.borderRadius = '8px';
      summaryDiv.style.textAlign = 'center';
      summaryDiv.style.fontWeight = '600';
      summaryDiv.innerHTML = `Tests Passed: ${passedCount}/${results.length}`;
      resultsDiv.appendChild(summaryDiv);
      
      resultContent.appendChild(resultsDiv);
    }
    
    updateMatrices();
  </script>
</body>
</html>