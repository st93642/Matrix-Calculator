<!-- ********************************************************************** -->
<!--                                                                        -->
<!--  matrix-calculator.html                            TTTTTTTT SSSSSSS II -->
<!--                                                       TT    SS      II -->
<!--  By: st93642@students.tsi.lv                          TT    SSSSSSS II -->
<!--                                                       TT         SS II -->
<!--  Created: Oct 28 2025 18:46 st93642                   TT    SSSSSSS II -->
<!--  Updated: Oct 28 2025 22:07 st93642                                    -->
<!--                                                                        -->
<!--   Transport and Telecommunication Institute - Riga, Latvia             -->
<!--                       https://tsi.lv                                   -->
<!-- ********************************************************************** -->

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Matrix Calculator</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
      background: white;
      border-radius: 20px;
      padding: 30px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
    }
    
    h1 {
      text-align: center;
      color: #667eea;
      margin-bottom: 30px;
      font-size: 2.5em;
    }
    
    .tabs {
      display: flex;
      justify-content: center;
      margin-bottom: 30px;
      border-bottom: 2px solid #e0e0e0;
    }
    
    .tab-button {
      padding: 15px 30px;
      background: #333333;
      border: none;
      border-bottom: 3px solid transparent;
      cursor: pointer;
      font-size: 16px;
      font-weight: 600;
      color: #cccccc;
      transition: all 0.3s;
    }
    
    .tab-button.active {
      background: white;
      color: #667eea;
      border-bottom-color: #667eea;
    }
    
    .tab-button:hover {
      background: #444444;
      color: #ffffff;
    }
    
    .tab-content {
      display: none;
    }
    
    .tab-content.active {
      display: block;
    }
    
    .controls {
      display: flex;
      gap: 20px;
      margin-bottom: 30px;
      flex-wrap: wrap;
    }
    
    .control-group {
      flex: 1;
      min-width: 200px;
    }
    
    label {
      display: block;
      margin-bottom: 5px;
      color: #555;
      font-weight: 600;
    }
    
    select, input {
      width: 100%;
      padding: 10px;
      border: 2px solid #e0e0e0;
      border-radius: 8px;
      font-size: 16px;
      transition: border-color 0.3s;
    }
    
    select:focus, input:focus {
      outline: none;
      border-color: #667eea;
    }
    
    .matrices-container {
      display: flex;
      gap: 30px;
      margin-bottom: 30px;
      flex-wrap: wrap;
    }
    
    .matrix-section {
      flex: 1;
      min-width: 250px;
    }
    
    .matrix-section h3 {
      color: #764ba2;
      margin-bottom: 15px;
    }
    
    .matrix-grid {
      display: inline-grid;
      gap: 8px;
      padding: 20px;
      background: #f8f9fa;
      border-radius: 12px;
      border: 3px solid #667eea;
    }
    
    .matrix-grid input {
      width: 60px;
      height: 50px;
      text-align: center;
      font-size: 18px;
      font-weight: 600;
      border: 2px solid #ddd;
    }
    
    .buttons {
      display: flex;
      gap: 15px;
      flex-wrap: wrap;
      margin-bottom: 30px;
    }
    
    button {
      flex: 1;
      min-width: 120px;
      padding: 15px 25px;
      font-size: 16px;
      font-weight: 600;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.3s;
      color: white;
    }
    
    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
    }
    
    .btn-add { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
    .btn-multiply { background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); }
    .btn-transpose { background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); }
    .btn-subtract { background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%); }
    .btn-scalar { background: linear-gradient(135deg, #ffd93d 0%, #ffb142 100%); }
    .btn-determinant { background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%); }
    .btn-inverse { background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%); }
    
    .result-section {
      margin-top: 30px;
      padding: 25px;
      background: #f8f9fa;
      border-radius: 12px;
      border-left: 5px solid #667eea;
    }
    
    .result-left, .result-right {
      min-width: 0;
      box-sizing: border-box;
      max-height: 70vh;
      overflow-y: auto;
      padding-right: 10px;
    }
    
    .result-left h3, .result-right h3 {
      color: #764ba2;
      margin-bottom: 20px;
    }
    
    .steps {
      max-height: 60vh;
      overflow-y: auto;
      padding-right: 10px;
    }
    

    
    .step {
      padding: 15px;
      margin-bottom: 15px;
      background: white;
      border-radius: 8px;
      border-left: 4px solid #667eea;
      animation: slideIn 0.5s ease-out;
      opacity: 0;
      animation-fill-mode: forwards;
    }
    
    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateX(-20px);
      }
      to {
        opacity: 1;
        transform: translateX(0);
      }
    }
    
    .step-title {
      font-weight: 600;
      color: #667eea;
      margin-bottom: 8px;
    }
    
    .step-content {
      color: #555;
      font-family: 'Courier New', monospace;
      line-height: 1.6;
    }
    
    .matrix-display {
      display: inline-block;
      margin: 10px 0;
      padding: 15px;
      background: white;
      border-radius: 8px;
      border: 2px solid #667eea;
    }
    
    .matrix-row {
      display: flex;
      gap: 10px;
      justify-content: center;
    }
    
    .matrix-cell {
      width: 50px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      color: #333;
      background: #f0f0f0;
      border-radius: 5px;
      transition: all 0.3s ease;
    }
    
    .matrix-separator {
      width: 20px !important;
      background: transparent !important;
      border: none !important;
      padding: 0 !important;
    }
    
    .highlight {
      background: #ffe066 !important;
      animation: pulse 0.5s ease-in-out;
      transform: scale(1.15);
      box-shadow: 0 0 15px rgba(255, 224, 102, 0.8);
    }
    
    .highlight-row {
      background: #a8e6cf !important;
      transform: scale(1.1);
    }
    
    .highlight-col {
      background: #ffd3b6 !important;
      transform: scale(1.1);
    }
    
    .highlight-cell {
      background: #ff8c69 !important;
      transform: scale(1.3);
      animation: pulse-cell 0.6s ease-in-out;
      box-shadow: 0 0 15px rgba(255, 140, 105, 0.8);
      z-index: 10;
      position: relative;
    }
    
    @keyframes pulse-cell {
      0%, 100% { transform: scale(1.3); }
      50% { transform: scale(1.5); }
    }
    
    .highlight-processing {
      background: #ff6b6b !important;
      animation: pulse 0.8s ease-in-out infinite;
      transform: scale(1.2);
      box-shadow: 0 0 20px rgba(255, 107, 107, 0.9);
      border: 2px solid #ff4757;
    }
    
    @keyframes pulse {
      0%, 100% { transform: scale(1.15); }
      50% { transform: scale(1.25); }
    }
    
    .formula-display {
      font-size: 18px;
      padding: 15px;
      background: linear-gradient(135deg, #667eea20 0%, #764ba220 100%);
      border-radius: 8px;
      margin: 15px 0;
      font-family: 'Courier New', monospace;
      font-weight: 600;
      color: #764ba2;
      text-align: center;
      border: 2px solid #667eea;
    }
    
    .visual-calculation {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 20px;
      margin: 20px 0;
      flex-wrap: wrap;
      max-width: 100%;
    }
    
    .calc-arrow {
      font-size: 30px;
      color: #667eea;
      animation: bounce 1s infinite;
    }
    
    @keyframes bounce {
      0%, 100% { transform: translateX(0); }
      50% { transform: translateX(10px); }
    }
    
    .error {
      color: #f5576c;
      padding: 15px;
      background: #ffe0e0;
      border-radius: 8px;
      margin-top: 10px;
    }
    
    .theoretical-explanation {
      background: linear-gradient(135deg, #e8f4fd 0%, #d1e7f0 100%);
      border-left-color: #4a90e2;
    }
    
    .theoretical-content {
      font-style: italic;
      color: #2c5282;
      line-height: 1.6;
    }
    
    /* Vector-specific styles */
    .vector-inputs {
      display: flex;
      gap: 30px;
      margin-bottom: 30px;
      flex-wrap: wrap;
    }
    
    .vector-section {
      flex: 1;
      min-width: 200px;
    }
    
    .vector-group {
      background: #f8f9fa;
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 20px;
    }
    
    .vector-group h4 {
      color: #764ba2;
      margin-bottom: 15px;
      font-size: 1.2em;
    }
    
    .vector-input {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 10px;
    }
    
    .vector-input label {
      min-width: 60px;
      font-weight: 600;
      color: #555;
    }
    
    .vector-input input {
      flex: 1;
      padding: 8px 12px;
      border: 2px solid #e0e0e0;
      border-radius: 6px;
      font-size: 16px;
      text-align: center;
    }
    
    .vector-input input:focus {
      border-color: #667eea;
      outline: none;
    }
    
    .vector-buttons {
      display: flex;
      gap: 15px;
      flex-wrap: wrap;
      margin-bottom: 30px;
    }
    
    .vector-btn {
      flex: 1;
      min-width: 150px;
      padding: 15px 20px;
      font-size: 14px;
      font-weight: 600;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.3s;
      color: white;
    }
    
    .btn-vector-add { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
    .btn-vector-add-w { background: linear-gradient(135deg, #4a5fc1 0%, #5a3d91 100%); }
    .btn-vector-subtract { background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%); }
    .btn-vector-subtract-w { background: linear-gradient(135deg, #d43d3d 0%, #c9302c 100%); }
    .btn-vector-scalar { background: linear-gradient(135deg, #ffd93d 0%, #ffb142 100%); }
    .btn-vector-scalar-w { background: linear-gradient(135deg, #e6b800 0%, #d39e00 100%); }
    .btn-vector-norm { background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); }
    .btn-vector-norm-w { background: linear-gradient(135deg, #c06bd6 0%, #d6336c 100%); }
    .btn-vector-distance { background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); }
    .btn-vector-components { background: linear-gradient(135deg, #a8e6cf 0%, #52c234 100%); }
    
    .vector-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
    }
    
    .test-section {
      margin-top: 20px;
      text-align: center;
    }
    
    .test-btn {
      background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%);
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
      box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3);
    }
    
    .test-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(255, 107, 107, 0.4);
    }
    
    .test-results {
      margin-top: 20px;
      padding: 20px;
      background: #f8f9fa;
      border-radius: 12px;
      border-left: 5px solid #28a745;
    }
    
    .test-result {
      margin-bottom: 15px;
      padding: 10px;
      border-radius: 8px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .test-pass {
      background: #d4edda;
      border-left: 4px solid #28a745;
    }
    
    .test-fail {
      background: #f8d7da;
      border-left: 4px solid #dc3545;
    }
    
    .test-name {
      font-weight: 600;
    }
    
    .test-status {
      font-weight: 600;
      padding: 4px 8px;
      border-radius: 4px;
    }
    
    .test-pass .test-status {
      background: #28a745;
      color: white;
    }
    
    .test-fail .test-status {
      background: #dc3545;
      color: white;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>🧮 Matrix & Vector Calculator</h1>
    
    <div class="tabs">
      <button class="tab-button active" onclick="switchTab('matrix')">Matrices</button>
      <button class="tab-button" onclick="switchTab('vector')">Vectors</button>
    </div>
    
    <!-- Matrix Tab Content -->
    <div id="matrix-tab" class="tab-content active">
      <div class="controls">
        <div class="control-group">
          <label>Matrix A Size:</label>
          <select id="sizeA" onchange="updateMatrices()">
            <option value="1x1">1×1</option>
            <option value="1x2">1×2</option>
            <option value="1x3">1×3</option>
            <option value="1x4">1×4</option>
            <option value="1x5">1×5</option>
            <option value="2x1">2×1</option>
            <option value="2x2">2×2</option>
            <option value="2x3">2×3</option>
            <option value="2x4">2×4</option>
            <option value="2x5">2×5</option>
            <option value="3x1">3×1</option>
            <option value="3x2">3×2</option>
            <option value="3x3" selected>3×3</option>
            <option value="3x4">3×4</option>
            <option value="3x5">3×5</option>
            <option value="4x1">4×1</option>
            <option value="4x2">4×2</option>
            <option value="4x3">4×3</option>
            <option value="4x4">4×4</option>
            <option value="4x5">4×5</option>
            <option value="5x1">5×1</option>
            <option value="5x2">5×2</option>
            <option value="5x3">5×3</option>
            <option value="5x4">5×4</option>
            <option value="5x5">5×5</option>
          </select>
        </div>
        <div class="control-group">
          <label>Matrix B Size:</label>
          <select id="sizeB" onchange="updateMatrices()">
            <option value="1x1">1×1</option>
            <option value="1x2">1×2</option>
            <option value="1x3">1×3</option>
            <option value="1x4">1×4</option>
            <option value="1x5">1×5</option>
            <option value="2x1">2×1</option>
            <option value="2x2">2×2</option>
            <option value="2x3">2×3</option>
            <option value="2x4">2×4</option>
            <option value="2x5">2×5</option>
            <option value="3x1">3×1</option>
            <option value="3x2">3×2</option>
            <option value="3x3" selected>3×3</option>
            <option value="3x4">3×4</option>
            <option value="3x5">3×5</option>
            <option value="4x1">4×1</option>
            <option value="4x2">4×2</option>
            <option value="4x3">4×3</option>
            <option value="4x4">4×4</option>
            <option value="4x5">4×5</option>
            <option value="5x1">5×1</option>
            <option value="5x2">5×2</option>
            <option value="5x3">5×3</option>
            <option value="5x4">5×4</option>
            <option value="5x5">5×5</option>
          </select>
        </div>
        <div class="control-group">
          <label>Scalar:</label>
          <input type="number" id="scalarValue" value="2" step="any" style="width: 80px;">
        </div>
      </div>
      
      <div class="matrices-container">
        <div class="matrix-section">
          <h3>Matrix A</h3>
          <div class="matrix-grid" id="matrixA"></div>
        </div>
        <div class="matrix-section">
          <h3>Matrix B</h3>
          <div class="matrix-grid" id="matrixB"></div>
        </div>
      </div>
      
      <div class="buttons">
        <button class="btn-add" onclick="calculate('add')">➕ Add A + B</button>
        <button class="btn-subtract" onclick="calculate('subtract')">➖ Subtract A - B</button>
        <button class="btn-multiply" onclick="calculate('multiply')">✖️ Multiply A × B</button>
        <button class="btn-scalar" onclick="calculate('scalar')">🔢 Scalar kA</button>
        <button class="btn-transpose" onclick="calculate('transpose')">🔄 Transpose A</button>
        <button class="btn-determinant" onclick="calculate('determinant')">📊 Det(A)</button>
        <button class="btn-inverse" onclick="calculate('inverse')">🔄⁻¹ Inverse A⁻¹</button>
      </div>
      
      <div class="test-section">
        <button class="test-btn" onclick="runMatrixTests()">🧮 Run Matrix Tests</button>
      </div>
    </div>
    
    <!-- Vector Tab Content -->
    <div id="vector-tab" class="tab-content">
      <div class="vector-inputs">
        <div class="vector-section">
          <div class="vector-group">
            <h4>Vector Operations</h4>
            <div class="vector-input">
              <label>Vector U:</label>
              <input type="number" id="u1" placeholder="x" step="any">
              <input type="number" id="u2" placeholder="y" step="any">
              <input type="number" id="u3" placeholder="z" step="any">
            </div>
            <div class="vector-input">
              <label>Vector V:</label>
              <input type="number" id="v1" placeholder="x" step="any">
              <input type="number" id="v2" placeholder="y" step="any">
              <input type="number" id="v3" placeholder="z" step="any">
            </div>
            <div class="vector-input">
              <label>Vector W:</label>
              <input type="number" id="w1" placeholder="x" step="any">
              <input type="number" id="w2" placeholder="y" step="any">
              <input type="number" id="w3" placeholder="z" step="any">
            </div>
            <div class="vector-input">
              <label>Scalar k:</label>
              <input type="number" id="vectorScalar" value="2" step="any" style="max-width: 80px;">
            </div>
          </div>
        </div>
        
        <div class="vector-section">
          <div class="vector-group">
            <h4>Point-to-Point Operations</h4>
            <div class="vector-input">
              <label>Point P1:</label>
              <input type="number" id="p1x" placeholder="x" step="any">
              <input type="number" id="p1y" placeholder="y" step="any">
              <input type="number" id="p1z" placeholder="z" step="any">
            </div>
            <div class="vector-input">
              <label>Point P2:</label>
              <input type="number" id="p2x" placeholder="x" step="any">
              <input type="number" id="p2y" placeholder="y" step="any">
              <input type="number" id="p2z" placeholder="z" step="any">
            </div>
          </div>
        </div>
      </div>
      
      <div class="vector-buttons">
        <button class="vector-btn btn-vector-add" onclick="calculateVector('add')">➕ U + V</button>
        <button class="vector-btn btn-vector-add-w" onclick="calculateVector('addW')">➕ U + W</button>
        <button class="vector-btn btn-vector-subtract" onclick="calculateVector('subtract')">➖ U - V</button>
        <button class="vector-btn btn-vector-subtract-w" onclick="calculateVector('subtractW')">➖ U - W</button>
        <button class="vector-btn btn-vector-scalar" onclick="calculateVector('scalar')">🔢 kU</button>
        <button class="vector-btn btn-vector-scalar-w" onclick="calculateVector('scalarW')">🔢 kW</button>
        <button class="vector-btn btn-vector-norm" onclick="calculateVector('norm')">📏 ||U||</button>
        <button class="vector-btn btn-vector-norm-w" onclick="calculateVector('normW')">📏 ||W||</button>
        <button class="vector-btn btn-vector-distance" onclick="calculateVector('distance')">📍 Distance P1-P2</button>
        <button class="vector-btn btn-vector-components" onclick="calculateVector('components')">→ Vector P1→P2</button>
      </div>
      
      <div class="test-section">
        <button class="test-btn" onclick="runVectorTests()">🧪 Run Vector Tests</button>
      </div>
    </div>
    
    <div class="result-section" id="result" style="display: none;">
      <div class="row">
        <div class="col-md-6 result-left">
          <h3>Visual Process</h3>
          <div id="resultContent"></div>
        </div>
        <div class="col-md-6 result-right">
          <h3>Calculation Steps</h3>
          <div class="steps" id="steps"></div>
        </div>
      </div>
    </div>
  </div>
  
  <script>
    let stepDelay = 0;
    
    function switchTab(tabName) {
      // Hide all tabs
      document.querySelectorAll('.tab-content').forEach(tab => {
        tab.classList.remove('active');
      });
      document.querySelectorAll('.tab-button').forEach(btn => {
        btn.classList.remove('active');
      });
      
      // Show selected tab
      document.getElementById(tabName + '-tab').classList.add('active');
      event.target.classList.add('active');
      
      // Hide results when switching tabs
      document.getElementById('result').style.display = 'none';
    }
    
    // Vector Functions
    function getVector(idPrefix) {
      return [
        parseFloat(document.getElementById(idPrefix + '1').value) || 0,
        parseFloat(document.getElementById(idPrefix + '2').value) || 0,
        parseFloat(document.getElementById(idPrefix + '3').value) || 0
      ];
    }
    
    function getPoint(idPrefix) {
      return [
        parseFloat(document.getElementById(idPrefix + 'x').value) || 0,
        parseFloat(document.getElementById(idPrefix + 'y').value) || 0,
        parseFloat(document.getElementById(idPrefix + 'z').value) || 0
      ];
    }
    
    function displayVector(vector, label = '') {
      const div = document.createElement('div');
      div.className = 'vector-display';
      
      if (label) {
        const labelSpan = document.createElement('span');
        labelSpan.textContent = label + ' ';
        div.appendChild(labelSpan);
      }
      
      div.innerHTML += `<span class="vector-arrow">→</span> (${vector[0]}, ${vector[1]}, ${vector[2]})`;
      return div;
    }
    
    function calculateVector(operation) {
      stepDelay = 0;
      const resultDiv = document.getElementById('result');
      const resultContent = document.getElementById('resultContent');
      const stepsDiv = document.getElementById('steps');
      
      resultDiv.style.display = 'block';
      resultContent.innerHTML = '';
      stepsDiv.innerHTML = '';
      
      try {
        switch(operation) {
          case 'add':
            vectorAdd();
            break;
          case 'addW':
            vectorAddW();
            break;
          case 'subtract':
            vectorSubtract();
            break;
          case 'subtractW':
            vectorSubtractW();
            break;
          case 'scalar':
            vectorScalarMultiply();
            break;
          case 'scalarW':
            vectorScalarMultiplyW();
            break;
          case 'norm':
            vectorNorm();
            break;
          case 'normW':
            vectorNormW();
            break;
          case 'distance':
            vectorDistance();
            break;
          case 'components':
            vectorComponents();
            break;
        }
      } catch (error) {
        resultContent.innerHTML = `<div class="error">${error.message}</div>`;
      }
    }
    
    function vectorAdd() {
      const u = getVector('u');
      const v = getVector('v');
      
      addStep('Vector Addition Setup', 'Adding vectors U and V component-wise');
      
      const result = [u[0] + v[0], u[1] + v[1], u[2] + v[2]];
      
      addStep('Component Addition', 
        `U = (${u[0]}, ${u[1]}, ${u[2]})<br>V = (${v[0]}, ${v[1]}, ${v[2]})<br><br>` +
        `U + V = (${u[0]} + ${v[0]}, ${u[1]} + ${v[1]}, ${u[2]} + ${v[2]}) = (${result[0]}, ${result[1]}, ${result[2]})`,
        1000
      );
      
      setTimeout(() => {
        document.getElementById('resultContent').appendChild(displayVector(result, 'U + V'));
        
        setTimeout(() => {
          addTheoreticalExplanation('Vector Addition Theory', 
            'Vector addition is performed component-wise: (u₁ + v₁, u₂ + v₂, u₃ + v₃). This operation follows the parallelogram law - the sum of two vectors is the diagonal of the parallelogram formed by the vectors. Vector addition is commutative (U + V = V + U) and associative ((U + V) + W = U + (V + W)).');
        }, 500);
      }, stepDelay);
    }
    
    function vectorSubtract() {
      const u = getVector('u');
      const v = getVector('v');
      
      addStep('Vector Subtraction Setup', 'Subtracting vector V from vector U component-wise');
      
      const result = [u[0] - v[0], u[1] - v[1], u[2] - v[2]];
      
      addStep('Component Subtraction', 
        `U = (${u[0]}, ${u[1]}, ${u[2]})<br>V = (${v[0]}, ${v[1]}, ${v[2]})<br><br>` +
        `U - V = (${u[0]} - ${v[0]}, ${u[1]} - ${v[1]}, ${u[2]} - ${v[2]}) = (${result[0]}, ${result[1]}, ${result[2]})`,
        1000
      );
      
      setTimeout(() => {
        document.getElementById('resultContent').appendChild(displayVector(result, 'U - V'));
        
        setTimeout(() => {
          addTheoreticalExplanation('Vector Subtraction Theory', 
            'Vector subtraction is performed component-wise: (u₁ - v₁, u₂ - v₂, u₃ - v₃). Geometrically, U - V gives the vector from the tip of V to the tip of U. Vector subtraction is not commutative (U - V ≠ V - U).');
        }, 500);
      }, stepDelay);
    }
    
    function vectorScalarMultiply() {
      const u = getVector('u');
      const k = parseFloat(document.getElementById('vectorScalar').value) || 0;
      
      addStep('Scalar Multiplication Setup', `Multiplying vector U by scalar ${k}`);
      
      const result = [k * u[0], k * u[1], k * u[2]];
      
      addStep('Component Multiplication', 
        `k = ${k}<br>U = (${u[0]}, ${u[1]}, ${u[2]})<br><br>` +
        `kU = (${k} × ${u[0]}, ${k} × ${u[1]}, ${k} × ${u[2]}) = (${result[0]}, ${result[1]}, ${result[2]})`,
        1000
      );
      
      setTimeout(() => {
        document.getElementById('resultContent').appendChild(displayVector(result, `${k}U`));
        
        setTimeout(() => {
          addTheoreticalExplanation('Scalar Multiplication Theory', 
            'Scalar multiplication multiplies each component by the scalar: (k × u₁, k × u₂, k × u₃). If k > 1, the vector is stretched; if 0 < k < 1, it\'s compressed; if k < 0, the direction is reversed. Properties include: k(U + V) = kU + kV, (k + m)U = kU + mU, and (km)U = k(mU).');
        }, 500);
      }, stepDelay);
    }
    
    function vectorNorm() {
      const u = getVector('u');
      
      addStep('Vector Norm (Magnitude) Setup', 'Calculating the Euclidean norm of vector U');
      
      const norm = Math.sqrt(u[0]*u[0] + u[1]*u[1] + u[2]*u[2]);
      
      addStep('Norm Calculation', 
        `U = (${u[0]}, ${u[1]}, ${u[2]})<br><br>` +
        `||U|| = √(${u[0]}² + ${u[1]}² + ${u[2]}²) = √(${u[0]*u[0]} + ${u[1]*u[1]} + ${u[2]*u[2]}) = √(${u[0]*u[0] + u[1]*u[1] + u[2]*u[2]}) = ${norm.toFixed(3)}`,
        1500
      );
      
      setTimeout(() => {
        document.getElementById('resultContent').innerHTML = 
          `<div style="font-size: 24px; font-weight: 600; color: #667eea;">||U|| = ${norm.toFixed(3)}</div>`;
        
        setTimeout(() => {
          addTheoreticalExplanation('Vector Norm Theory', 
            'The Euclidean norm (magnitude) measures the length of a vector: ||U|| = √(u₁² + u₂² + u₃²). A unit vector has norm 1. The norm satisfies the triangle inequality: ||U + V|| ≤ ||U|| + ||V||. Zero vector has norm 0. The norm is always non-negative.');
        }, 500);
      }, stepDelay);
    }
    
    function vectorDistance() {
      const p1 = getPoint('p1');
      const p2 = getPoint('p2');
      
      addStep('Distance Between Points Setup', 'Calculating Euclidean distance between points P1 and P2');
      
      const diff = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];
      const distance = Math.sqrt(diff[0]*diff[0] + diff[1]*diff[1] + diff[2]*diff[2]);
      
      addStep('Distance Calculation', 
        `P1 = (${p1[0]}, ${p1[1]}, ${p1[2]})<br>P2 = (${p2[0]}, ${p2[1]}, ${p2[2]})<br><br>` +
        `Vector P1→P2 = (${diff[0]}, ${diff[1]}, ${diff[2]})<br>` +
        `Distance = ||P2 - P1|| = √((${diff[0]})² + (${diff[1]})² + (${diff[2]})²) = √(${diff[0]*diff[0]} + ${diff[1]*diff[1]} + ${diff[2]*diff[2]}) = √(${diff[0]*diff[0] + diff[1]*diff[1] + diff[2]*diff[2]}) = ${distance.toFixed(3)}`,
        1500
      );
      
      setTimeout(() => {
        document.getElementById('resultContent').innerHTML = 
          `<div style="font-size: 24px; font-weight: 600; color: #667eea;">Distance = ${distance.toFixed(3)}</div>`;
        
        setTimeout(() => {
          addTheoreticalExplanation('Distance Between Points Theory', 
            'The Euclidean distance between points P1 and P2 is ||P2 - P1|| = √((x₂-x₁)² + (y₂-y₁)² + (z₂-z₁)²). This is the straight-line distance in 3D space. Distance is always non-negative and symmetric (distance P1→P2 = distance P2→P1).');
        }, 500);
      }, stepDelay);
    }
    
    function vectorComponents() {
      const p1 = getPoint('p1');
      const p2 = getPoint('p2');
      
      addStep('Vector Components Setup', 'Finding the vector from point P1 to point P2');
      
      const components = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];
      
      addStep('Component Calculation', 
        `P1 = (${p1[0]}, ${p1[1]}, ${p1[2]})<br>P2 = (${p2[0]}, ${p2[1]}, ${p2[2]})<br><br>` +
        `Vector P1→P2 = P2 - P1 = (${p2[0]} - ${p1[0]}, ${p2[1]} - ${p1[1]}, ${p2[2]} - ${p1[2]}) = (${components[0]}, ${components[1]}, ${components[2]})`,
        1000
      );
      
      setTimeout(() => {
        document.getElementById('resultContent').appendChild(displayVector(components, 'P1→P2'));
        
        setTimeout(() => {
          addTheoreticalExplanation('Vector Components Theory', 
            'The vector from point P1 to P2 has components (x₂-x₁, y₂-y₁, z₂-z₁). This represents the displacement vector. The initial point P1 is the "tail" and terminal point P2 is the "head" of the vector. Vector components determine both magnitude and direction in 3D space.');
        }, 500);
      }, stepDelay);
    }
    
    function vectorAddW() {
      const u = getVector('u');
      const w = getVector('w');
      
      addStep('Vector Addition Setup', 'Adding vectors U and W component-wise');
      
      const result = [u[0] + w[0], u[1] + w[1], u[2] + w[2]];
      
      addStep('Component Addition', 
        `U = (${u[0]}, ${u[1]}, ${u[2]})<br>W = (${w[0]}, ${w[1]}, ${w[2]})<br><br>` +
        `U + W = (${u[0]} + ${w[0]}, ${u[1]} + ${w[1]}, ${u[2]} + ${w[2]}) = (${result[0]}, ${result[1]}, ${result[2]})`,
        1000
      );
      
      setTimeout(() => {
        document.getElementById('resultContent').appendChild(displayVector(result, 'U + W'));
        
        setTimeout(() => {
          addTheoreticalExplanation('Vector Addition Theory', 
            'Vector addition is performed component-wise: (u₁ + w₁, u₂ + w₂, u₃ + w₃). This operation follows the parallelogram law - the sum of two vectors is the diagonal of the parallelogram formed by the vectors. Vector addition is commutative (U + W = W + U) and associative ((U + W) + V = U + (W + V)).');
        }, 500);
      }, stepDelay);
    }
    
    function vectorSubtractW() {
      const u = getVector('u');
      const w = getVector('w');
      
      addStep('Vector Subtraction Setup', 'Subtracting vector W from vector U component-wise');
      
      const result = [u[0] - w[0], u[1] - w[1], u[2] - w[2]];
      
      addStep('Component Subtraction', 
        `U = (${u[0]}, ${u[1]}, ${u[2]})<br>W = (${w[0]}, ${w[1]}, ${w[2]})<br><br>` +
        `U - W = (${u[0]} - ${w[0]}, ${u[1]} - ${w[1]}, ${u[2]} - ${w[2]}) = (${result[0]}, ${result[1]}, ${result[2]})`,
        1000
      );
      
      setTimeout(() => {
        document.getElementById('resultContent').appendChild(displayVector(result, 'U - W'));
        
        setTimeout(() => {
          addTheoreticalExplanation('Vector Subtraction Theory', 
            'Vector subtraction is performed component-wise: (u₁ - w₁, u₂ - w₂, u₃ - w₃). Geometrically, U - W gives the vector from the tip of W to the tip of U. Vector subtraction is not commutative (U - W ≠ W - U).');
        }, 500);
      }, stepDelay);
    }
    
    function vectorScalarMultiplyW() {
      const w = getVector('w');
      const k = parseFloat(document.getElementById('vectorScalar').value) || 0;
      
      addStep('Scalar Multiplication Setup', `Multiplying vector W by scalar ${k}`);
      
      const result = [k * w[0], k * w[1], k * w[2]];
      
      addStep('Component Multiplication', 
        `k = ${k}<br>W = (${w[0]}, ${w[1]}, ${w[2]})<br><br>` +
        `kW = (${k} × ${w[0]}, ${k} × ${w[1]}, ${k} × ${w[2]}) = (${result[0]}, ${result[1]}, ${result[2]})`,
        1000
      );
      
      setTimeout(() => {
        document.getElementById('resultContent').appendChild(displayVector(result, `${k}W`));
        
        setTimeout(() => {
          addTheoreticalExplanation('Scalar Multiplication Theory', 
            'Scalar multiplication multiplies each component by the scalar: (k × w₁, k × w₂, k × w₃). If k > 1, the vector is stretched; if 0 < k < 1, it\'s compressed; if k < 0, the direction is reversed. Properties include: k(W + U) = kW + kU, (k + m)W = kW + mW, and (km)W = k(mW).');
        }, 500);
      }, stepDelay);
    }
    
    function vectorNormW() {
      const w = getVector('w');
      
      addStep('Vector Norm (Magnitude) Setup', 'Calculating the Euclidean norm of vector W');
      
      const norm = Math.sqrt(w[0]*w[0] + w[1]*w[1] + w[2]*w[2]);
      
      addStep('Norm Calculation', 
        `W = (${w[0]}, ${w[1]}, ${w[2]})<br><br>` +
        `||W|| = √(${w[0]}² + ${w[1]}² + ${w[2]}²) = √(${w[0]*w[0]} + ${w[1]*w[1]} + ${w[2]*w[2]}) = √(${w[0]*w[0] + w[1]*w[1] + w[2]*w[2]}) = ${norm.toFixed(3)}`,
        1500
      );
      
      setTimeout(() => {
        document.getElementById('resultContent').innerHTML = 
          `<div style="font-size: 24px; font-weight: 600; color: #667eea;">||W|| = ${norm.toFixed(3)}</div>`;
        
        setTimeout(() => {
          addTheoreticalExplanation('Vector Norm Theory', 
            'The Euclidean norm (magnitude) measures the length of a vector: ||W|| = √(w₁² + w₂² + w₃²). A unit vector has norm 1. The norm satisfies the triangle inequality: ||W + U|| ≤ ||W|| + ||U||. Zero vector has norm 0. The norm is always non-negative.');
        }, 500);
      }, stepDelay);
    }
    
    function updateMatrices() {
      const sizeA = document.getElementById('sizeA').value.split('x');
      const sizeB = document.getElementById('sizeB').value.split('x');
      
      createMatrixInputs('matrixA', parseInt(sizeA[0]), parseInt(sizeA[1]));
      createMatrixInputs('matrixB', parseInt(sizeB[0]), parseInt(sizeB[1]));
      
      document.getElementById('result').style.display = 'none';
    }
    
    function createMatrixInputs(id, rows, cols) {
      const container = document.getElementById(id);
      container.innerHTML = '';
      container.style.gridTemplateColumns = `repeat(${cols}, 60px)`;
      
      for (let i = 0; i < rows * cols; i++) {
        const input = document.createElement('input');
        input.type = 'number';
        input.value = Math.floor(Math.random() * 10);
        input.step = 'any';
        container.appendChild(input);
      }
    }
    
    function getMatrix(id) {
      const sizeStr = id === 'matrixA' ? 
        document.getElementById('sizeA').value :
        document.getElementById('sizeB').value;
      
      const size = sizeStr.split('x');
      const rows = parseInt(size[0]);
      const cols = parseInt(size[1]);
      
      const inputs = document.getElementById(id).getElementsByTagName('input');
      const matrix = [];
      
      for (let i = 0; i < rows; i++) {
        matrix[i] = [];
        for (let j = 0; j < cols; j++) {
          matrix[i][j] = parseFloat(inputs[i * cols + j].value) || 0;
        }
      }
      
      return matrix;
    }
    
    function displayMatrix(matrix, label = '') {
      const div = document.createElement('div');
      div.className = 'matrix-display';
      
      if (label) {
        const labelDiv = document.createElement('div');
        labelDiv.style.marginBottom = '10px';
        labelDiv.style.fontWeight = '600';
        labelDiv.textContent = label;
        div.appendChild(labelDiv);
      }
      
      matrix.forEach(row => {
        const rowDiv = document.createElement('div');
        rowDiv.className = 'matrix-row';
        row.forEach(val => {
          const cell = document.createElement('div');
          cell.className = 'matrix-cell';
          if (isNaN(val) || !isFinite(val)) {
            cell.textContent = '0.00'; // Handle NaN/Infinity
          } else {
            cell.textContent = Number.isInteger(val) ? val : val.toFixed(2);
          }
          rowDiv.appendChild(cell);
        });
        div.appendChild(rowDiv);
      });
      
      return div;
    }
    
    function displayAugmented(matrix, label = '') {
      const div = document.createElement('div');
      div.className = 'matrix-display';
      
      if (label) {
        const labelDiv = document.createElement('div');
        labelDiv.style.marginBottom = '10px';
        labelDiv.style.fontWeight = '600';
        labelDiv.textContent = label;
        div.appendChild(labelDiv);
      }
      
      const n = matrix.length; // Size of square matrix A
      
      matrix.forEach(row => {
        const rowDiv = document.createElement('div');
        rowDiv.className = 'matrix-row';
        
        // Left side: original matrix A
        for (let j = 0; j < n; j++) {
          const cell = document.createElement('div');
          cell.className = 'matrix-cell';
          const val = row[j];
          if (isNaN(val) || !isFinite(val)) {
            cell.textContent = '0.00'; // Handle NaN/Infinity
          } else {
            cell.textContent = Number.isInteger(val) ? val : val.toFixed(2);
          }
          rowDiv.appendChild(cell);
        }
        
        // Vertical separator
        const separator = document.createElement('div');
        separator.className = 'matrix-cell matrix-separator';
        separator.textContent = '|';
        separator.style.fontWeight = 'bold';
        separator.style.color = '#667eea';
        rowDiv.appendChild(separator);
        
        // Right side: identity matrix I
        for (let j = n; j < 2 * n; j++) {
          const cell = document.createElement('div');
          cell.className = 'matrix-cell';
          const val = row[j];
          if (isNaN(val) || !isFinite(val)) {
            cell.textContent = '0.00'; // Handle NaN/Infinity
          } else {
            cell.textContent = Number.isInteger(val) ? val : val.toFixed(2);
          }
          rowDiv.appendChild(cell);
        }
        
        div.appendChild(rowDiv);
      });
      
      return div;
    }
    
    function addStep(title, content, delay = 500) {
      setTimeout(() => {
        const stepsDiv = document.getElementById('steps');
        const step = document.createElement('div');
        step.className = 'step';
        step.style.animationDelay = '0s';
        
        const titleDiv = document.createElement('div');
        titleDiv.className = 'step-title';
        titleDiv.textContent = title;
        
        const contentDiv = document.createElement('div');
        contentDiv.className = 'step-content';
        if (typeof content === 'string') {
          contentDiv.innerHTML = content;
        } else {
          contentDiv.appendChild(content);
        }
        
        step.appendChild(titleDiv);
        step.appendChild(contentDiv);
        stepsDiv.appendChild(step);
        
        // Auto-scroll to keep the latest step visible
        setTimeout(() => {
          step.scrollIntoView({ behavior: 'smooth', block: 'end' });
        }, 100);
      }, stepDelay);
      
      stepDelay += delay;
    }
    
    function addTheoreticalExplanation(title, content) {
      setTimeout(() => {
        const stepsDiv = document.getElementById('steps');
        const explanation = document.createElement('div');
        explanation.className = 'theoretical-explanation';
        
        const titleDiv = document.createElement('div');
        titleDiv.className = 'step-title';
        titleDiv.textContent = title;
        
        const contentDiv = document.createElement('div');
        contentDiv.className = 'theoretical-content';
        contentDiv.textContent = content;
        
        explanation.appendChild(titleDiv);
        explanation.appendChild(contentDiv);
        stepsDiv.appendChild(explanation);
        
        // Auto-scroll to keep the latest explanation visible
        setTimeout(() => {
          explanation.scrollIntoView({ behavior: 'smooth', block: 'end' });
        }, 100);
      }, stepDelay);
      
      stepDelay += 1000; // Give more time for theoretical explanations
    }
    
    function calculate(operation) {
      stepDelay = 0;
      const resultDiv = document.getElementById('result');
      const resultContent = document.getElementById('resultContent');
      const stepsDiv = document.getElementById('steps');
      
      resultDiv.style.display = 'block';
      resultContent.innerHTML = '';
      stepsDiv.innerHTML = '';
      
      const matrixA = getMatrix('matrixA');
      const matrixB = getMatrix('matrixB');
      
      try {
        switch(operation) {
          case 'add':
            addMatrices(matrixA, matrixB);
            break;
          case 'subtract':
            subtractMatrices(matrixA, matrixB);
            break;
          case 'multiply':
            multiplyMatrices(matrixA, matrixB);
            break;
          case 'scalar':
            scalarMultiply(matrixA);
            break;
          case 'transpose':
            transposeMatrix(matrixA);
            break;
          case 'determinant':
            calculateDeterminant(matrixA);
            break;
          case 'inverse':
            calculateInverse(matrixA);
            break;
        }
      } catch (error) {
        resultContent.innerHTML = `<div class="error">${error.message}</div>`;
      }
    }
    
    function addMatrices(A, B) {
      const result = addMatricesCalc(A, B);
      
      addStep('Step 1: Matrix Addition', 'Adding corresponding elements from Matrix A and Matrix B', 750);
      
      for (let i = 0; i < A.length; i++) {
        for (let j = 0; j < A[0].length; j++) {
          addStep(
            `Element [${i+1},${j+1}]`,
            `A[${i+1},${j+1}] + B[${i+1},${j+1}] = ${A[i][j]} + ${B[i][j]} = ${result[i][j]}`,
            450
          );
        }
      }
      
      setTimeout(() => {
        addVisualElement(displayMatrix(result, 'Result: A + B'));
        
        // Add theoretical explanation
        setTimeout(() => {
          addTheoreticalExplanation('Matrix Addition Theory', 
            'Matrix addition is performed element-wise, where each element of the result matrix C is the sum of the corresponding elements from matrices A and B: Cᵢⱼ = Aᵢⱼ + Bᵢⱼ. This operation requires both matrices to have identical dimensions (same number of rows and columns). Matrix addition is commutative (A + B = B + A) and associative ((A + B) + C = A + (B + C)).');
        }, 750);
      }, stepDelay);
      
      return result;
    }
    
    function subtractMatrices(A, B) {
      const result = subtractMatricesCalc(A, B);
      
      addStep('Step 1: Matrix Subtraction', 'Subtracting corresponding elements from Matrix B from Matrix A', 750);
      
      for (let i = 0; i < A.length; i++) {
        for (let j = 0; j < A[0].length; j++) {
          addStep(
            `Element [${i+1},${j+1}]`,
            `A[${i+1},${j+1}] - B[${i+1},${j+1}] = ${A[i][j]} - ${B[i][j]} = ${result[i][j]}`,
            450
          );
        }
      }
      
      setTimeout(() => {
        addVisualElement(displayMatrix(result, 'Result: A - B'));
        
        // Add theoretical explanation
        setTimeout(() => {
          addTheoreticalExplanation('Matrix Subtraction Theory', 
            'Matrix subtraction is performed element-wise, where each element of the result matrix C is the difference of the corresponding elements from matrices A and B: Cᵢⱼ = Aᵢⱼ - Bᵢⱼ. This operation requires both matrices to have identical dimensions (same number of rows and columns). Matrix subtraction is not commutative (A - B ≠ B - A).');
        }, 750);
      }, stepDelay);
      
      return result;
    }
    
    function scalarMultiply(A) {
      const scalar = parseFloat(document.getElementById('scalarValue').value) || 0;
      const result = scalarMultiplyCalc(A, scalar);
      
      addStep('Step 1: Scalar Multiplication', `Multiplying matrix A by scalar ${scalar}`, 750);
      
      for (let i = 0; i < A.length; i++) {
        for (let j = 0; j < A[0].length; j++) {
          addStep(
            `Element [${i+1},${j+1}]`,
            `${scalar} × A[${i+1},${j+1}] = ${scalar} × ${A[i][j]} = ${result[i][j]}`,
            450
          );
        }
      }
      
      setTimeout(() => {
        addVisualElement(displayMatrix(result, `Result: ${scalar}A`));
        
        // Add theoretical explanation
        setTimeout(() => {
          addTheoreticalExplanation('Scalar Multiplication Theory', 
            'Scalar multiplication multiplies each element of the matrix by a scalar value k: (kA)ᵢⱼ = k × Aᵢⱼ. This operation changes the scale of the matrix while preserving its structure. Properties include: k(A + B) = kA + kB, (k + m)A = kA + mA, and (km)A = k(mA). Scalar multiplication is used in transformations, scaling, and solving linear equations.');
        }, 750);
      }, stepDelay);
      
      return result;
    }
    
    function multiplyMatrices(A, B) {
      const result = multiplyMatricesCalc(A, B);
      
      addStep('Step 1: Matrix Multiplication Setup', `Multiplying ${A.length}×${A[0].length} matrix with ${B.length}×${B[0].length} matrix`, 750);
      
      // Create visual multiplication display - synchronized with first step
      setTimeout(() => {
        const visualDiv = document.createElement('div');
        visualDiv.className = 'visual-calculation';
        visualDiv.innerHTML = `
          <div id="matrixA-visual">${displayMatrix(A, 'Matrix A').outerHTML}</div>
          <div class="calc-arrow">×</div>
          <div id="matrixB-visual">${displayMatrix(B, 'Matrix B').outerHTML}</div>
          <div class="calc-arrow">=</div>
          <div id="result-visual">${displayMatrix(result, 'Result C').outerHTML}</div>
        `;
        addVisualElement(visualDiv);
      }, stepDelay);
      
      for (let i = 0; i < A.length; i++) {
        for (let j = 0; j < B[0].length; j++) {
          let calculation = '';
          
          // Start processing this result cell
          setTimeout(() => {
            highlightResultProcessing('result-visual', i, j);
            highlightRow('matrixA-visual', i);
            highlightCol('matrixB-visual', j);
          }, stepDelay);
          
          addStep(`Computing C[${i+1},${j+1}]`, `Row ${i+1} of A × Column ${j+1} of B`, 1800);
          
          for (let k = 0; k < A[0].length; k++) {
            calculation += `${A[i][k]}×${B[k][j]}`;
            if (k < A[0].length - 1) calculation += ' + ';
            
            // Animate individual multiplication - highlight specific cells being multiplied
            setTimeout(() => {
              highlightCell('matrixA-visual', i, k);
              highlightCell('matrixB-visual', k, j); // This is the specific digit in the column
            }, stepDelay);
            
            addStep(
              `Step: A[${i+1},${k+1}] × B[${k+1},${j+1}]`,
              `${A[i][k]} × ${B[k][j]} = ${A[i][k] * B[k][j]}`,
              1500
            );
          }
          
          // Update result matrix with final value
          setTimeout(() => {
            updateResultCell('result-visual', i, j, result[i][j]);
            clearHighlights();
          }, stepDelay);
          
          addStep(
            `C[${i+1},${j+1}] Complete`,
            `${calculation} = ${result[i][j]}`,
            1800
          );
        }
      }
      
      setTimeout(() => {
        addVisualElement(displayMatrix(result, 'Final Result: A × B'));
        
        // Add theoretical explanation
        setTimeout(() => {
          addTheoreticalExplanation('Matrix Multiplication Theory', 
            'Matrix multiplication combines rows from the first matrix with columns from the second matrix using dot products. For element Cᵢⱼ, take row i from matrix A and column j from matrix B, multiply corresponding elements, and sum the results. The inner dimensions must match (columns of A = rows of B). Result dimensions are (rows of A) × (columns of B). Matrix multiplication is not commutative (A × B ≠ B × A in general).');
        }, 750);
      }, stepDelay + 1500);
      
      return result;
    }
    
    function transposeMatrix(A) {
      const result = transposeMatrixCalc(A);
      
      addStep('Step 1: Matrix Transpose Setup', `Transposing ${A.length}×${A[0].length} matrix to ${A[0].length}×${A.length} matrix`, 750);
      
      // Create visual transpose display - synchronized with first step
      setTimeout(() => {
        const visualDiv = document.createElement('div');
        visualDiv.className = 'visual-calculation';
        visualDiv.innerHTML = `
          <div id="original-matrix">${displayMatrix(A, 'Original A').outerHTML}</div>
          <div class="calc-arrow">→</div>
          <div id="transpose-result">${displayMatrix(result, 'Transposed Aᵀ').outerHTML}</div>
        `;
        addVisualElement(visualDiv);
      }, stepDelay);
      
      for (let i = 0; i < A.length; i++) {
        for (let j = 0; j < A[0].length; j++) {
          // Animate the element movement
          setTimeout(() => {
            highlightCell('original-matrix', i, j);
            highlightCell('transpose-result', j, i);
          }, stepDelay);
          
          addStep(
            `Element Movement`,
            `A[${i+1},${j+1}] = ${A[i][j]} → Aᵀ[${j+1},${i+1}] = ${A[i][j]}`,
            900
          );
          
          // Update the result matrix
          setTimeout(() => {
            updateResultCell('transpose-result', j, i, A[i][j]);
          }, stepDelay + 450);
        }
      }
      
      setTimeout(() => {
        addVisualElement(displayMatrix(result, 'Final Result: Aᵀ'));
        
        // Add theoretical explanation
        setTimeout(() => {
          addTheoreticalExplanation('Matrix Transpose Theory', 
            'Matrix transpose swaps rows with columns: element Aᵢⱼ becomes Aᵀⱼᵢ. A matrix of size m×n becomes n×m. Transpose has several important properties: (Aᵀ)ᵀ = A, (A + B)ᵀ = Aᵀ + Bᵀ, and (A × B)ᵀ = Bᵀ × Aᵀ. Transpose is used in solving linear systems, finding orthogonal matrices, and many other applications in linear algebra.');
        }, 750);
      }, stepDelay + 1500);
      
      return result;
    }
    
    function calculateDeterminant(A) {
      const det = calculateDeterminantCalc(A);
      
      if (A.length === 2) {
        addStep('Step 1: 2×2 Determinant Formula', `det([${A[0][0]} ${A[0][1]}; ${A[1][0]} ${A[1][1]}]) = (${A[0][0]} × ${A[1][1]}) - (${A[0][1]} × ${A[1][0]}) = ${det}`, 750);
        
        // Visual 2x2 determinant calculation - synchronized with step
        setTimeout(() => {
          const visualDiv = document.createElement('div');
          visualDiv.className = 'visual-calculation';
          visualDiv.innerHTML = `
            <div>${displayMatrix(A, 'Matrix A').outerHTML}</div>
            <div class="calc-arrow">det</div>
            <div class="formula-display">
              (${A[0][0]} × ${A[1][1]}) - (${A[0][1]} × ${A[1][0]}) = ${det}
            </div>
          `;
          
          addVisualElement(visualDiv);
        }, stepDelay);
        
        setTimeout(() => {
          const finalResultDiv = document.createElement('div');
          finalResultDiv.style.fontSize = '24px';
          finalResultDiv.style.fontWeight = '600';
          finalResultDiv.style.color = '#667eea';
          finalResultDiv.textContent = `Determinant = ${det}`;
          addVisualElement(finalResultDiv);
          
          // Add theoretical explanation
          setTimeout(() => {
            addTheoreticalExplanation('2×2 Determinant Theory', 
              'For a 2×2 matrix [a b; c d], the determinant is ad - bc. This formula comes from the area of the parallelogram formed by the column vectors. A non-zero determinant indicates the matrix is invertible. If determinant is zero, the matrix is singular and has no inverse.');
          }, 750);
        }, stepDelay + 1000);
        return det;
      }
      
      addStep('Step 1: Cofactor Expansion Setup', `Using cofactor expansion along first row of ${A.length}×${A.length} matrix`, 750);
      
      // Show original matrix
      addStep('Original Matrix', displayMatrix(A, 'Matrix A'), 1500);
      
      for (let j = 0; j < A.length; j++) {
        const minor = getMinor(A, 0, j);
        const sign = Math.pow(-1, j);
        const minorDet = calculateDeterminantCalc(minor);
        const cofactor = sign * A[0][j] * minorDet;
        
        // Visual cofactor calculation - synchronized with accumulation step
        setTimeout(() => {
          const visualDiv = document.createElement('div');
          visualDiv.className = 'visual-calculation';
          visualDiv.innerHTML = `
            <div class="formula-display">
              Cofactor [1,${j+1}] = ${sign === 1 ? '+' : '-'}${A[0][j]} × det(
            </div>
            <div>${displayMatrix(minor, `Minor M₁,${j+1}`).outerHTML}</div>
            <div class="formula-display">
              ) = ${sign === 1 ? '+' : '-'}${A[0][j]} × ${minorDet.toFixed(2)} = ${cofactor.toFixed(2)}
            </div>
          `;
          
          addVisualElement(visualDiv);
        }, stepDelay);
        
        addStep(
          `Accumulate Determinant`,
          `det += ${cofactor.toFixed(2)} → Current total: ${det.toFixed(2)}`,
          1200
        );
      }
      
      setTimeout(() => {
        const finalResultDiv = document.createElement('div');
        finalResultDiv.style.fontSize = '24px';
        finalResultDiv.style.fontWeight = '600';
        finalResultDiv.style.color = '#667eea';
        finalResultDiv.textContent = `Determinant = ${det.toFixed(2)}`;
        addVisualElement(finalResultDiv);
        
        // Add theoretical explanation
        setTimeout(() => {
          addTheoreticalExplanation('Determinant Theory (Cofactor Expansion)', 
            'The determinant measures the "volume scaling factor" of a linear transformation. For square matrices, it\'s calculated using cofactor expansion along any row or column. Each cofactor is (-1)ⁱ⁺ʲ times the determinant of the minor matrix (original matrix with row i and column j removed). If determinant = 0, the matrix is singular (not invertible). If |det| = 1, the transformation preserves volume. Determinant is used in solving systems of equations, finding matrix inverses, and analyzing linear transformations.');
        }, 750);
      }, stepDelay + 1000);
      
      return det;
    }
    
    function calculateInverse(A) {
      const inverse = calculateInverseCalc(A);
      
      addStep('Step 1: Gauss-Jordan Elimination Setup', `Using Gauss-Jordan elimination to find inverse of ${A.length}×${A.length} matrix`, 750);
      
      // Create augmented matrix [A | I] for display
      const augmented = Array(A.length).fill().map(() => Array(2 * A.length).fill(0));
      const identity = Array(A.length).fill().map(() => Array(A.length).fill(0));
      
      // Initialize identity matrix
      for (let i = 0; i < A.length; i++) {
        identity[i][i] = 1;
      }
      
      // Create augmented matrix [A | I]
      for (let i = 0; i < A.length; i++) {
        for (let j = 0; j < A.length; j++) {
          augmented[i][j] = A[i][j];        // Left side: original matrix
          augmented[i][j + A.length] = identity[i][j]; // Right side: identity matrix
        }
      }
      
      // Display initial augmented matrix - synchronized with setup step
      setTimeout(() => {
        addVisualElement(displayAugmented(augmented, '[A | I]'));
      }, stepDelay);
      
      // Simulate Gauss-Jordan elimination for display
      for (let pivot = 0; pivot < A.length; pivot++) {
        addStep(`Step ${pivot + 2}: Process Column ${pivot + 1}`, `Make column ${pivot + 1} have 1 on diagonal and 0s elsewhere`, 750);
        
        // Get pivot value
        const pivotValue = augmented[pivot][pivot];
        addStep(`Pivot Element`, `Pivot = ${pivotValue.toFixed(2)} at position [${pivot + 1},${pivot + 1}]`, 1200);
        
        // Make pivot 1 by dividing the entire row by pivot value
        if (Math.abs(pivotValue - 1) > 1e-10) {
          for (let j = 0; j < 2 * A.length; j++) {
            if (isFinite(augmented[pivot][j]) && isFinite(pivotValue) && pivotValue !== 0) {
              augmented[pivot][j] /= pivotValue;
            } else {
              augmented[pivot][j] = 0; // Handle division by zero or invalid values
            }
          }
          addStep(`Normalize Pivot Row`, `Divide row ${pivot + 1} by ${pivotValue.toFixed(2)} to make pivot = 1`, 1500);
          
          // Display updated matrix - synchronized with normalization step
          setTimeout(() => {
            addVisualElement(displayAugmented(augmented, `[A | I] after normalization`));
          }, stepDelay);
        }
        
        // Eliminate other entries in this column
        for (let i = 0; i < A.length; i++) {
          if (i !== pivot) {
            const factor = augmented[i][pivot];
            if (Math.abs(factor) > 1e-10 && isFinite(factor)) {
              addStep(`Eliminate Row ${i + 1}`, `Row ${i + 1} = Row ${i + 1} - (${factor.toFixed(2)}) × Row ${pivot + 1}`, 1200);
              
              for (let j = 0; j < 2 * A.length; j++) {
                if (isFinite(augmented[i][j]) && isFinite(augmented[pivot][j]) && isFinite(factor)) {
                  augmented[i][j] -= factor * augmented[pivot][j];
                } else {
                  augmented[i][j] = 0; // Handle invalid operations
                }
              }
              
              // Display updated matrix - synchronized with elimination step
              setTimeout(() => {
                addVisualElement(displayAugmented(augmented, `[A | I] after eliminating row ${i + 1}`));
              }, stepDelay);
            }
          }
        }
        
        addStep(`Column ${pivot + 1} Complete`, `Column ${pivot + 1} now has 1 on diagonal and 0s elsewhere`, 1800);
      }
      
      setTimeout(() => {
        addVisualElement(displayMatrix(inverse, 'Inverse Matrix A⁻¹'));
        
        // Add theoretical explanation
        setTimeout(() => {
          addTheoreticalExplanation('Gauss-Jordan Elimination Theory', 
            'Gauss-Jordan elimination transforms a matrix into its inverse by creating an augmented matrix [A | I] and performing row operations to convert A into the identity matrix I. The operations are: 1) Swap rows for better pivots, 2) Divide rows to create 1s on the diagonal, 3) Subtract multiples of rows to create 0s elsewhere. The right side becomes A⁻¹. This method is numerically stable and efficient for finding matrix inverses, especially for larger matrices.');
        }, 750);
      }, stepDelay + 1500);
      
      return inverse;
    }
    
    function highlightRow(matrixId, rowIndex) {
      const matrixDiv = document.getElementById(matrixId);
      if (!matrixDiv) return;
      
      const rows = matrixDiv.querySelectorAll('.matrix-row');
      rows.forEach((row, index) => {
        if (index === rowIndex) {
          row.classList.add('highlight-row');
        } else {
          row.classList.remove('highlight-row');
        }
      });
    }
    
    function highlightCol(matrixId, colIndex) {
      const matrixDiv = document.getElementById(matrixId);
      if (!matrixDiv) return;
      
      const rows = matrixDiv.querySelectorAll('.matrix-row');
      rows.forEach(row => {
        const cells = row.querySelectorAll('.matrix-cell');
        cells.forEach((cell, index) => {
          if (index === colIndex) {
            cell.classList.add('highlight-col');
          } else {
            cell.classList.remove('highlight-col');
          }
        });
      });
    }
    
    function highlightCell(matrixId, rowIndex, colIndex) {
      const matrixDiv = document.getElementById(matrixId);
      if (!matrixDiv) return;
      
      const rows = matrixDiv.querySelectorAll('.matrix-row');
      if (rows[rowIndex]) {
        const cells = rows[rowIndex].querySelectorAll('.matrix-cell');
        if (cells[colIndex]) {
          cells[colIndex].classList.add('highlight-cell');
          setTimeout(() => cells[colIndex].classList.remove('highlight-cell'), 800);
        }
      }
    }
    
    function highlightResultProcessing(matrixId, rowIndex, colIndex) {
      const matrixDiv = document.getElementById(matrixId);
      if (!matrixDiv) return;
      
      const rows = matrixDiv.querySelectorAll('.matrix-row');
      if (rows[rowIndex]) {
        const cells = rows[rowIndex].querySelectorAll('.matrix-cell');
        if (cells[colIndex]) {
          cells[colIndex].classList.add('highlight-processing');
        }
      }
    }
    
    function updateResultCell(matrixId, rowIndex, colIndex, value) {
      const matrixDiv = document.getElementById(matrixId);
      if (!matrixDiv) return;
      
      const rows = matrixDiv.querySelectorAll('.matrix-row');
      if (rows[rowIndex]) {
        const cells = rows[rowIndex].querySelectorAll('.matrix-cell');
        if (cells[colIndex]) {
          cells[colIndex].textContent = Number.isInteger(value) ? value : value.toFixed(2);
          cells[colIndex].classList.add('highlight');
          setTimeout(() => cells[colIndex].classList.remove('highlight'), 1000);
        }
      }
    }
    
    function clearHighlights() {
      document.querySelectorAll('.highlight, .highlight-row, .highlight-col, .highlight-cell, .highlight-processing').forEach(el => {
        el.classList.remove('highlight', 'highlight-row', 'highlight-col', 'highlight-cell', 'highlight-processing');
      });
    }
    
    function addVisualElement(element) {
      const resultContent = document.getElementById('resultContent');
      resultContent.appendChild(element);
      
      // Auto-scroll to keep the latest visual element visible
      setTimeout(() => {
        element.scrollIntoView({ behavior: 'smooth', block: 'end' });
      }, 100);
    }
    
    function getMinor(matrix, row, col) {
      return matrix
        .filter((_, i) => i !== row)
        .map(r => r.filter((_, j) => j !== col));
    }
    
    function calcDet(matrix) {
      const n = matrix.length;
      
      if (n === 1) return matrix[0][0];
      if (n === 2) return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0];
      
      let det = 0;
      for (let j = 0; j < n; j++) {
        det += Math.pow(-1, j) * matrix[0][j] * calcDet(getMinor(matrix, 0, j));
      }
      return det;
    }
    
    // Pure calculation functions (no UI)
    function addMatricesCalc(A, B) {
      if (A.length !== B.length || A[0].length !== B[0].length) {
        throw new Error('Matrices must have the same dimensions for addition');
      }
      
      const result = [];
      for (let i = 0; i < A.length; i++) {
        result[i] = [];
        for (let j = 0; j < A[0].length; j++) {
          result[i][j] = A[i][j] + B[i][j];
        }
      }
      return result;
    }
    
    function subtractMatricesCalc(A, B) {
      if (A.length !== B.length || A[0].length !== B[0].length) {
        throw new Error('Matrices must have the same dimensions for subtraction');
      }
      
      const result = [];
      for (let i = 0; i < A.length; i++) {
        result[i] = [];
        for (let j = 0; j < A[0].length; j++) {
          result[i][j] = A[i][j] - B[i][j];
        }
      }
      return result;
    }
    
    function multiplyMatricesCalc(A, B) {
      const rowsA = A.length;
      const colsA = A[0].length;
      const colsB = B[0].length;
      
      if (colsA !== B.length) {
        throw new Error('Number of columns in A must equal number of rows in B');
      }
      
      const result = Array(rowsA).fill().map(() => Array(colsB).fill(0));
      
      for (let i = 0; i < rowsA; i++) {
        for (let j = 0; j < colsB; j++) {
          for (let k = 0; k < colsA; k++) {
            result[i][j] += A[i][k] * B[k][j];
          }
        }
      }
      return result;
    }
    
    function scalarMultiplyCalc(A, scalar) {
      const result = [];
      for (let i = 0; i < A.length; i++) {
        result[i] = [];
        for (let j = 0; j < A[0].length; j++) {
          result[i][j] = scalar * A[i][j];
        }
      }
      return result;
    }
    
    function transposeMatrixCalc(A) {
      const result = [];
      for (let i = 0; i < A[0].length; i++) {
        result[i] = [];
        for (let j = 0; j < A.length; j++) {
          result[i][j] = A[j][i];
        }
      }
      return result;
    }
    
    function calculateDeterminantCalc(A) {
      const n = A.length;
      
      if (n !== A[0].length) {
        throw new Error('Matrix must be square to calculate determinant');
      }
      
      return calcDet(A);
    }
    
    function calculateInverseCalc(A) {
      const n = A.length;
      
      if (n !== A[0].length) {
        throw new Error('Matrix must be square to calculate inverse');
      }
      
      // Create augmented matrix [A | I]
      const augmented = Array(n).fill().map(() => Array(2 * n).fill(0));
      
      // Initialize identity matrix
      for (let i = 0; i < n; i++) {
        augmented[i][i + n] = 1;
      }
      
      // Create augmented matrix [A | I]
      for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
          augmented[i][j] = A[i][j];
        }
      }
      
      // Gauss-Jordan elimination
      for (let pivot = 0; pivot < n; pivot++) {
        // Find pivot row
        let maxRow = pivot;
        for (let i = pivot + 1; i < n; i++) {
          if (Math.abs(augmented[i][pivot]) > Math.abs(augmented[maxRow][pivot])) {
            maxRow = i;
          }
        }
        
        // Check if pivot is zero
        if (Math.abs(augmented[maxRow][pivot]) < 1e-10) {
          throw new Error('Matrix is singular and has no inverse');
        }
        
        // Swap rows if needed
        if (maxRow !== pivot) {
          [augmented[pivot], augmented[maxRow]] = [augmented[maxRow], augmented[pivot]];
        }
        
        // Get pivot value
        const pivotValue = augmented[pivot][pivot];
        
        // Make pivot 1
        for (let j = 0; j < 2 * n; j++) {
          augmented[pivot][j] /= pivotValue;
        }
        
        // Eliminate other entries in this column
        for (let i = 0; i < n; i++) {
          if (i !== pivot) {
            const factor = augmented[i][pivot];
            for (let j = 0; j < 2 * n; j++) {
              augmented[i][j] -= factor * augmented[pivot][j];
            }
          }
        }
      }
      
      // Extract inverse matrix
      const inverse = augmented.map(row => row.slice(n));
      return inverse;
    }
    
    function runVectorTests() {
      const resultDiv = document.getElementById('result');
      const resultContent = document.getElementById('resultContent');
      const stepsDiv = document.getElementById('steps');
      
      resultDiv.style.display = 'block';
      resultContent.innerHTML = '';
      stepsDiv.innerHTML = '';
      
      const testResults = [];
      
      // Test Vector Addition
      testResults.push(testVectorAddition());
      
      // Test Vector Addition with W
      testResults.push(testVectorAdditionW());
      
      // Test Vector Subtraction
      testResults.push(testVectorSubtraction());
      
      // Test Vector Subtraction with W
      testResults.push(testVectorSubtractionW());
      
      // Test Scalar Multiplication
      testResults.push(testScalarMultiplication());
      
      // Test Scalar Multiplication with W
      testResults.push(testScalarMultiplicationW());
      
      // Test Vector Norm
      testResults.push(testVectorNorm());
      
      // Test Vector Norm with W
      testResults.push(testVectorNormW());
      
      // Test Distance Calculation
      testResults.push(testDistanceCalculation());
      
      // Test Vector Components
      testResults.push(testVectorComponents());
      
      // Display results
      displayTestResults(testResults);
    }
    
    function testVectorAddition() {
      // Set test inputs
      document.getElementById('u1').value = '3';
      document.getElementById('u2').value = '4';
      document.getElementById('u3').value = '5';
      document.getElementById('v1').value = '1';
      document.getElementById('v2').value = '2';
      document.getElementById('v3').value = '3';
      
      const u = getVector('u');
      const v = getVector('v');
      const expected = [4, 6, 8]; // 3+1, 4+2, 5+3
      const result = [u[0] + v[0], u[1] + v[1], u[2] + v[2]];
      
      const passed = arraysEqual(result, expected);
      return {
        name: 'Vector Addition (3,4,5) + (1,2,3)',
        passed: passed,
        expected: expected,
        actual: result
      };
    }
    
    function testVectorSubtraction() {
      // Set test inputs
      document.getElementById('u1').value = '5';
      document.getElementById('u2').value = '7';
      document.getElementById('u3').value = '9';
      document.getElementById('v1').value = '2';
      document.getElementById('v2').value = '3';
      document.getElementById('v3').value = '4';
      
      const u = getVector('u');
      const v = getVector('v');
      const expected = [3, 4, 5]; // 5-2, 7-3, 9-4
      const result = [u[0] - v[0], u[1] - v[1], u[2] - v[2]];
      
      const passed = arraysEqual(result, expected);
      return {
        name: 'Vector Subtraction (5,7,9) - (2,3,4)',
        passed: passed,
        expected: expected,
        actual: result
      };
    }
    
    function testScalarMultiplication() {
      // Set test inputs
      document.getElementById('u1').value = '2';
      document.getElementById('u2').value = '3';
      document.getElementById('u3').value = '4';
      document.getElementById('vectorScalar').value = '3';
      
      const u = getVector('u');
      const k = parseFloat(document.getElementById('vectorScalar').value);
      const expected = [6, 9, 12]; // 2*3, 3*3, 4*3
      const result = [k * u[0], k * u[1], k * u[2]];
      
      const passed = arraysEqual(result, expected);
      return {
        name: 'Scalar Multiplication 3 × (2,3,4)',
        passed: passed,
        expected: expected,
        actual: result
      };
    }
    
    function testVectorNorm() {
      // Set test inputs
      document.getElementById('u1').value = '3';
      document.getElementById('u2').value = '4';
      document.getElementById('u3').value = '0';
      
      const u = getVector('u');
      const expected = 5; // √(3² + 4² + 0²) = √(9 + 16) = √25 = 5
      const result = Math.sqrt(u[0]*u[0] + u[1]*u[1] + u[2]*u[2]);
      
      const passed = Math.abs(result - expected) < 0.001;
      return {
        name: 'Vector Norm ||(3,4,0)||',
        passed: passed,
        expected: expected,
        actual: result
      };
    }
    
    function testDistanceCalculation() {
      // Set test inputs
      document.getElementById('p1x').value = '0';
      document.getElementById('p1y').value = '0';
      document.getElementById('p1z').value = '0';
      document.getElementById('p2x').value = '3';
      document.getElementById('p2y').value = '4';
      document.getElementById('p2z').value = '0';
      
      const p1 = getPoint('p1');
      const p2 = getPoint('p2');
      const diff = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];
      const expected = 5; // √((3-0)² + (4-0)² + (0-0)²) = √(9 + 16) = √25 = 5
      const result = Math.sqrt(diff[0]*diff[0] + diff[1]*diff[1] + diff[2]*diff[2]);
      
      const passed = Math.abs(result - expected) < 0.001;
      return {
        name: 'Distance between (0,0,0) and (3,4,0)',
        passed: passed,
        expected: expected,
        actual: result
      };
    }
    
    function testVectorComponents() {
      // Set test inputs
      document.getElementById('p1x').value = '1';
      document.getElementById('p1y').value = '2';
      document.getElementById('p1z').value = '3';
      document.getElementById('p2x').value = '4';
      document.getElementById('p2y').value = '6';
      document.getElementById('p2z').value = '8';
      
      const p1 = getPoint('p1');
      const p2 = getPoint('p2');
      const expected = [3, 4, 5]; // 4-1, 6-2, 8-3
      const result = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];
      
      const passed = arraysEqual(result, expected);
      return {
        name: 'Vector Components (1,2,3) → (4,6,8)',
        passed: passed,
        expected: expected,
        actual: result
      };
    }
    
    function testVectorAdditionW() {
      // Set test inputs
      document.getElementById('u1').value = '1';
      document.getElementById('u2').value = '2';
      document.getElementById('u3').value = '3';
      document.getElementById('w1').value = '4';
      document.getElementById('w2').value = '5';
      document.getElementById('w3').value = '6';
      
      const u = getVector('u');
      const w = getVector('w');
      const expected = [5, 7, 9]; // 1+4, 2+5, 3+6
      const result = [u[0] + w[0], u[1] + w[1], u[2] + w[2]];
      
      const passed = arraysEqual(result, expected);
      return {
        name: 'Vector Addition W (1,2,3) + (4,5,6)',
        passed: passed,
        expected: expected,
        actual: result
      };
    }
    
    function testVectorSubtractionW() {
      // Set test inputs
      document.getElementById('u1').value = '7';
      document.getElementById('u2').value = '8';
      document.getElementById('u3').value = '9';
      document.getElementById('w1').value = '2';
      document.getElementById('w2').value = '3';
      document.getElementById('w3').value = '4';
      
      const u = getVector('u');
      const w = getVector('w');
      const expected = [5, 5, 5]; // 7-2, 8-3, 9-4
      const result = [u[0] - w[0], u[1] - w[1], u[2] - w[2]];
      
      const passed = arraysEqual(result, expected);
      return {
        name: 'Vector Subtraction W (7,8,9) - (2,3,4)',
        passed: passed,
        expected: expected,
        actual: result
      };
    }
    
    function testScalarMultiplicationW() {
      // Set test inputs
      document.getElementById('w1').value = '2';
      document.getElementById('w2').value = '4';
      document.getElementById('w3').value = '6';
      document.getElementById('vectorScalar').value = '2';
      
      const w = getVector('w');
      const k = parseFloat(document.getElementById('vectorScalar').value);
      const expected = [4, 8, 12]; // 2*2, 4*2, 6*2
      const result = [k * w[0], k * w[1], k * w[2]];
      
      const passed = arraysEqual(result, expected);
      return {
        name: 'Scalar Multiplication W 2 × (2,4,6)',
        passed: passed,
        expected: expected,
        actual: result
      };
    }
    
    function testVectorNormW() {
      // Set test inputs
      document.getElementById('w1').value = '6';
      document.getElementById('w2').value = '8';
      document.getElementById('w3').value = '0';
      
      const w = getVector('w');
      const expected = 10; // √(6² + 8² + 0²) = √(36 + 64) = √100 = 10
      const result = Math.sqrt(w[0]*w[0] + w[1]*w[1] + w[2]*w[2]);
      
      const passed = Math.abs(result - expected) < 0.001;
      return {
        name: 'Vector Norm W ||(6,8,0)||',
        passed: passed,
        expected: expected,
        actual: result
      };
    }
    
    function arraysEqual(a, b) {
      if (a.length !== b.length) return false;
      for (let i = 0; i < a.length; i++) {
        if (Math.abs(a[i] - b[i]) > 0.001) return false;
      }
      return true;
    }
    
    function displayTestResults(results) {
      const resultContent = document.getElementById('resultContent');
      
      const resultsDiv = document.createElement('div');
      resultsDiv.className = 'test-results';
      
      const header = document.createElement('h3');
      header.textContent = 'Vector Operation Tests';
      header.style.color = '#28a745';
      header.style.marginBottom = '20px';
      resultsDiv.appendChild(header);
      
      let passedCount = 0;
      results.forEach(result => {
        if (result.passed) passedCount++;
        
        const testDiv = document.createElement('div');
        testDiv.className = `test-result ${result.passed ? 'test-pass' : 'test-fail'}`;
        
        const nameSpan = document.createElement('span');
        nameSpan.className = 'test-name';
        nameSpan.textContent = result.name;
        
        const statusSpan = document.createElement('span');
        statusSpan.className = 'test-status';
        statusSpan.textContent = result.passed ? 'PASS' : 'FAIL';
        
        testDiv.appendChild(nameSpan);
        testDiv.appendChild(statusSpan);
        
        if (!result.passed) {
          const detailsDiv = document.createElement('div');
          detailsDiv.style.marginTop = '8px';
          detailsDiv.style.fontSize = '14px';
          detailsDiv.innerHTML = `Expected: [${result.expected.join(', ')}]<br>Actual: [${Array.isArray(result.actual) ? result.actual.map(x => typeof x === 'number' ? x.toFixed(3) : x).join(', ') : result.actual.toFixed(3)}]`;
          testDiv.appendChild(detailsDiv);
        }
        
        resultsDiv.appendChild(testDiv);
      });
      
      const summaryDiv = document.createElement('div');
      summaryDiv.style.marginTop = '20px';
      summaryDiv.style.padding = '15px';
      summaryDiv.style.background = passedCount === results.length ? '#d4edda' : '#f8d7da';
      summaryDiv.style.borderRadius = '8px';
      summaryDiv.style.textAlign = 'center';
      summaryDiv.style.fontWeight = '600';
      summaryDiv.innerHTML = `Tests Passed: ${passedCount}/${results.length}`;
      resultsDiv.appendChild(summaryDiv);
      
      resultContent.appendChild(resultsDiv);
    }
    
    // Matrix Test Functions
    function runMatrixTests() {
      const resultDiv = document.getElementById('result');
      const resultContent = document.getElementById('resultContent');
      const stepsDiv = document.getElementById('steps');
      
      resultDiv.style.display = 'block';
      resultContent.innerHTML = '';
      stepsDiv.innerHTML = '';
      
      const testResults = [];
      
      // Matrix Addition Tests
      testResults.push(testMatrixAddition2x2());
      testResults.push(testMatrixAddition3x3());
      testResults.push(testMatrixAdditionCommutativity());
      
      // Matrix Subtraction Tests
      testResults.push(testMatrixSubtraction2x2());
      testResults.push(testMatrixSubtraction3x3());
      
      // Scalar Multiplication Tests
      testResults.push(testScalarMultiplication2x2());
      testResults.push(testScalarMultiplication3x3());
      testResults.push(testScalarDistributivity());
      
      // Matrix Multiplication Tests
      testResults.push(testMatrixMultiplication2x2());
      testResults.push(testMatrixMultiplication2x3_3x2());
      testResults.push(testMatrixMultiplicationIdentity());
      
      // Matrix Transpose Tests
      testResults.push(testMatrixTranspose2x3());
      testResults.push(testMatrixTransposeDouble());
      testResults.push(testMatrixTransposeSum());
      
      // Determinant Tests
      testResults.push(testDeterminant2x2());
      testResults.push(testDeterminant3x3());
      testResults.push(testDeterminantIdentity());
      
      // Matrix Inverse Tests
      testResults.push(testMatrixInverse2x2());
      testResults.push(testMatrixInverseIdentity());
      testResults.push(testMatrixInverseProperty());
      
      // Display results
      displayMatrixTestResults(testResults);
    }
    
    function testMatrixAddition2x2() {
      const A = [[1, 2], [3, 4]];
      const B = [[5, 6], [7, 8]];
      const result = addMatricesCalc(A, B);
      const expected = [[6, 8], [10, 12]];
      const passed = matricesEqual(result, expected);
      return {
        name: 'Matrix Addition 2x2 + 2x2',
        passed: passed,
        expected: expected,
        actual: result
      };
    }
    
    function testMatrixAddition3x3() {
      const A = [[1, 0, 2], [3, 2, 1], [4, 0, 3]];
      const B = [[1, 1, 3], [4, 2, 1], [3, 2, 0]];
      const result = addMatricesCalc(A, B);
      const expected = [[2, 1, 5], [7, 4, 2], [7, 2, 3]];
      const passed = matricesEqual(result, expected);
      return {
        name: 'Matrix Addition 3x3 + 3x3',
        passed: passed,
        expected: expected,
        actual: result
      };
    }
    
    function testMatrixAdditionCommutativity() {
      const A = [[1, 2], [3, 4]];
      const B = [[5, 6], [7, 8]];
      const AB = addMatricesCalc(A, B);
      const BA = addMatricesCalc(B, A);
      const passed = matricesEqual(AB, BA);
      return {
        name: 'Matrix Addition Commutativity: A + B = B + A',
        passed: passed,
        expected: 'Equal matrices',
        actual: passed ? 'Equal' : 'Not equal'
      };
    }
    
    function testMatrixSubtraction2x2() {
      const A = [[5, 6], [7, 8]];
      const B = [[1, 2], [3, 4]];
      const result = subtractMatricesCalc(A, B);
      const expected = [[4, 4], [4, 4]];
      const passed = matricesEqual(result, expected);
      return {
        name: 'Matrix Subtraction 2x2 - 2x2',
        passed: passed,
        expected: expected,
        actual: result
      };
    }
    
    function testMatrixSubtraction3x3() {
      const A = [[1, 0, 2], [3, 2, 1], [4, 0, 3]];
      const B = [[1, 1, 3], [4, 2, 1], [3, 2, 0]];
      const result = subtractMatricesCalc(A, B);
      const expected = [[0, -1, -1], [-1, 0, 0], [1, -2, 3]];
      const passed = matricesEqual(result, expected);
      return {
        name: 'Matrix Subtraction 3x3 - 3x3',
        passed: passed,
        expected: expected,
        actual: result
      };
    }
    
    function testScalarMultiplication2x2() {
      const A = [[1, 2], [3, 4]];
      const result = scalarMultiplyCalc(A, 3);
      const expected = [[3, 6], [9, 12]];
      const passed = matricesEqual(result, expected);
      return {
        name: 'Scalar Multiplication 2x2 × 3',
        passed: passed,
        expected: expected,
        actual: result
      };
    }
    
    function testScalarMultiplication3x3() {
      const A = [[1, 0, 2], [3, 2, 1], [4, 0, 3]];
      const result = scalarMultiplyCalc(A, -2);
      const expected = [[-2, 0, -4], [-6, -4, -2], [-8, 0, -6]];
      const passed = matricesEqual(result, expected);
      return {
        name: 'Scalar Multiplication 3x3 × (-2)',
        passed: passed,
        expected: expected,
        actual: result
      };
    }
    
    function testScalarDistributivity() {
      const A = [[1, 2], [3, 4]];
      const B = [[5, 6], [7, 8]];
      const k = 3;
      const left = scalarMultiplyCalc(addMatricesCalc(A, B), k);
      const right = addMatricesCalc(scalarMultiplyCalc(A, k), scalarMultiplyCalc(B, k));
      const passed = matricesEqual(left, right);
      return {
        name: 'Scalar Distributivity: k(A + B) = kA + kB',
        passed: passed,
        expected: 'Equal matrices',
        actual: passed ? 'Equal' : 'Not equal'
      };
    }
    
    function testMatrixMultiplication2x2() {
      const A = [[1, 2], [3, 4]];
      const B = [[5, 6], [7, 8]];
      const result = multiplyMatricesCalc(A, B);
      const expected = [[19, 22], [43, 50]];
      const passed = matricesEqual(result, expected);
      return {
        name: 'Matrix Multiplication 2x2 × 2x2',
        passed: passed,
        expected: expected,
        actual: result
      };
    }
    
    function testMatrixMultiplication2x3_3x2() {
      const A = [[1, 2, 3], [4, 5, 6]];
      const B = [[7, 8], [9, 10], [11, 12]];
      const result = multiplyMatricesCalc(A, B);
      const expected = [[58, 64], [139, 154]];
      const passed = matricesEqual(result, expected);
      return {
        name: 'Matrix Multiplication 2x3 × 3x2',
        passed: passed,
        expected: expected,
        actual: result
      };
    }
    
    function testMatrixMultiplicationIdentity() {
      const A = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];
      const I = [[1, 0, 0], [0, 1, 0], [0, 0, 1]];
      const result = multiplyMatricesCalc(A, I);
      const passed = matricesEqual(result, A);
      return {
        name: 'Matrix Multiplication Identity: A × I = A',
        passed: passed,
        expected: 'Equal to original matrix',
        actual: passed ? 'Equal' : 'Not equal'
      };
    }
    
    function testMatrixTranspose2x3() {
      const A = [[1, 2, 3], [4, 5, 6]];
      const result = transposeMatrixCalc(A);
      const expected = [[1, 4], [2, 5], [3, 6]];
      const passed = matricesEqual(result, expected);
      return {
        name: 'Matrix Transpose 2x3 to 3x2',
        passed: passed,
        expected: expected,
        actual: result
      };
    }
    
    function testMatrixTransposeDouble() {
      const A = [[1, 2, 3], [4, 5, 6]];
      const result = transposeMatrixCalc(transposeMatrixCalc(A));
      const passed = matricesEqual(result, A);
      return {
        name: 'Matrix Transpose Double: (A^T)^T = A',
        passed: passed,
        expected: 'Equal to original matrix',
        actual: passed ? 'Equal' : 'Not equal'
      };
    }
    
    function testMatrixTransposeSum() {
      const A = [[1, 2], [3, 4]];
      const B = [[5, 6], [7, 8]];
      const left = transposeMatrixCalc(addMatricesCalc(A, B));
      const right = addMatricesCalc(transposeMatrixCalc(A), transposeMatrixCalc(B));
      const passed = matricesEqual(left, right);
      return {
        name: 'Matrix Transpose of Sum: (A + B)^T = A^T + B^T',
        passed: passed,
        expected: 'Equal matrices',
        actual: passed ? 'Equal' : 'Not equal'
      };
    }
    
    function testDeterminant2x2() {
      const A = [[1, 2], [3, 4]];
      const result = calcDet(A);
      const expected = -2; // 1*4 - 2*3 = 4 - 6 = -2
      const passed = Math.abs(result - expected) < 1e-10;
      return {
        name: 'Determinant 2x2 Matrix',
        passed: passed,
        expected: expected,
        actual: result
      };
    }
    
    function testDeterminant3x3() {
      const A = [[1, 0, 2], [3, 2, 1], [4, 0, 3]];
      const result = calcDet(A);
      const expected = -10; // 1*(2*3-1*0) - 0*(3*3-1*4) + 2*(3*0-2*4) = 6 + 0 - 16 = -10
      const passed = Math.abs(result - expected) < 1e-10;
      return {
        name: 'Determinant 3x3 Matrix',
        passed: passed,
        expected: expected,
        actual: result
      };
    }
    
    function testDeterminantIdentity() {
      const I = [[1, 0, 0], [0, 1, 0], [0, 0, 1]];
      const result = calcDet(I);
      const passed = Math.abs(result - 1) < 1e-10;
      return {
        name: 'Determinant Identity Matrix = 1',
        passed: passed,
        expected: 1,
        actual: result
      };
    }
    
    function testMatrixInverse2x2() {
      const A = [[1, 2], [3, 4]];
      const result = calculateInverseCalc(A);
      const expected = [[-2, 1], [1.5, -0.5]]; // (1/(1*4-2*3)) * [4, -2; -3, 1] = (1/-2) * [4, -2; -3, 1] = [-2, 1; 1.5, -0.5]
      const passed = matricesEqual(result, expected);
      return {
        name: 'Matrix Inverse 2x2',
        passed: passed,
        expected: expected,
        actual: result
      };
    }
    
    function testMatrixInverseIdentity() {
      const I = [[1, 0], [0, 1]];
      const result = calculateInverseCalc(I);
      const passed = matricesEqual(result, I);
      return {
        name: 'Matrix Inverse Identity = Itself',
        passed: passed,
        expected: 'Equal to identity',
        actual: passed ? 'Equal' : 'Not equal'
      };
    }
    
    function testMatrixInverseProperty() {
      const A = [[2, 1], [1, 1]];
      const A_inv = calculateInverseCalc(A);
      const product = multiplyMatricesCalc(A, A_inv);
      const I = [[1, 0], [0, 1]];
      const passed = matricesEqual(product, I, 1e-8); // Allow for small floating point errors
      return {
        name: 'Matrix Inverse Property: A × A⁻¹ = I',
        passed: passed,
        expected: 'Equal to identity matrix',
        actual: passed ? 'Equal' : 'Not equal'
      };
    }
    
    function matricesEqual(A, B, tolerance = 1e-10) {
      if (A.length !== B.length || A[0].length !== B[0].length) return false;
      for (let i = 0; i < A.length; i++) {
        for (let j = 0; j < A[0].length; j++) {
          if (Math.abs(A[i][j] - B[i][j]) > tolerance) return false;
        }
      }
      return true;
    }
    
    function displayMatrixTestResults(results) {
      const resultContent = document.getElementById('resultContent');
      
      const resultsDiv = document.createElement('div');
      resultsDiv.className = 'test-results';
      
      const header = document.createElement('h3');
      header.textContent = 'Matrix Operation Tests';
      header.style.color = '#667eea';
      header.style.marginBottom = '20px';
      resultsDiv.appendChild(header);
      
      let passedCount = 0;
      results.forEach(result => {
        if (result.passed) passedCount++;
        
        const testDiv = document.createElement('div');
        testDiv.className = `test-result ${result.passed ? 'test-pass' : 'test-fail'}`;
        
        const nameSpan = document.createElement('span');
        nameSpan.className = 'test-name';
        nameSpan.textContent = result.name;
        
        const statusSpan = document.createElement('span');
        statusSpan.className = 'test-status';
        statusSpan.textContent = result.passed ? 'PASS' : 'FAIL';
        
        testDiv.appendChild(nameSpan);
        testDiv.appendChild(statusSpan);
        
        if (!result.passed) {
          const detailsDiv = document.createElement('div');
          detailsDiv.style.marginTop = '8px';
          detailsDiv.style.fontSize = '14px';
          if (Array.isArray(result.expected) && Array.isArray(result.expected[0])) {
            // Matrix display
            detailsDiv.innerHTML = `Expected:<br>${displayMatrix(result.expected).outerHTML}<br>Actual:<br>${displayMatrix(result.actual).outerHTML}`;
          } else {
            detailsDiv.innerHTML = `Expected: ${Array.isArray(result.expected) ? '[' + result.expected.map(row => '[' + row.join(', ') + ']').join('; ') + ']' : result.expected}<br>Actual: ${Array.isArray(result.actual) ? '[' + result.actual.map(row => '[' + row.join(', ') + ']').join('; ') + ']' : result.actual}`;
          }
          testDiv.appendChild(detailsDiv);
        }
        
        resultsDiv.appendChild(testDiv);
      });
      
      const summaryDiv = document.createElement('div');
      summaryDiv.style.marginTop = '20px';
      summaryDiv.style.padding = '15px';
      summaryDiv.style.background = passedCount === results.length ? '#d4edda' : '#f8d7da';
      summaryDiv.style.borderRadius = '8px';
      summaryDiv.style.textAlign = 'center';
      summaryDiv.style.fontWeight = '600';
      summaryDiv.innerHTML = `Tests Passed: ${passedCount}/${results.length}`;
      resultsDiv.appendChild(summaryDiv);
      
      resultContent.appendChild(resultsDiv);
    }
    
    updateMatrices();
  </script>
</body>
</html>