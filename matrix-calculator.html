<!-- ********************************************************************** -->
<!--                                                                        -->
<!--  matrix-calculator.html                            TTTTTTTT SSSSSSS II -->
<!--                                                       TT    SS      II -->
<!--  By: st93642@students.tsi.lv                          TT    SSSSSSS II -->
<!--                                                       TT         SS II -->
<!--  Created: Oct 28 2025 18:46 st93642                   TT    SSSSSSS II -->
<!--  Updated: Oct 28 2025 22:08 st93642                                    -->
<!--                                                                        -->
<!--   Transport and Telecommunication Institute - Riga, Latvia             -->
<!--                       https://tsi.lv                                   -->
<!-- ********************************************************************** -->

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Matrix Calculator</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
      background: white;
      border-radius: 20px;
      padding: 30px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
    }
    
    h1 {
      text-align: center;
      color: #667eea;
      margin-bottom: 30px;
      font-size: 2.5em;
    }
    
    .tabs {
      display: flex;
      justify-content: center;
      margin-bottom: 30px;
      border-bottom: 2px solid #e0e0e0;
    }
    
    .tab-button {
      padding: 15px 30px;
      background: #333333;
      border: none;
      border-bottom: 3px solid transparent;
      cursor: pointer;
      font-size: 16px;
      font-weight: 600;
      color: #cccccc;
      transition: all 0.3s;
    }
    
    .tab-button.active {
      background: white;
      color: #667eea;
      border-bottom-color: #667eea;
    }
    
    .tab-button:hover {
      background: #444444;
      color: #ffffff;
    }
    
    .tab-content {
      display: none;
    }
    
    .tab-content.active {
      display: block;
    }
    
    .controls {
      display: flex;
      gap: 20px;
      margin-bottom: 30px;
      flex-wrap: wrap;
    }
    
    .control-group {
      flex: 1;
      min-width: 200px;
    }
    
    label {
      display: block;
      margin-bottom: 5px;
      color: #555;
      font-weight: 600;
    }
    
    select, input {
      width: 100%;
      padding: 10px;
      border: 2px solid #e0e0e0;
      border-radius: 8px;
      font-size: 16px;
      transition: border-color 0.3s;
    }
    
    select:focus, input:focus {
      outline: none;
      border-color: #667eea;
    }
    
    .matrices-container {
      display: flex;
      gap: 30px;
      margin-bottom: 30px;
      flex-wrap: wrap;
    }
    
    .matrix-section {
      flex: 1;
      min-width: 250px;
    }
    
    .matrix-section h3 {
      color: #764ba2;
      margin-bottom: 15px;
    }
    
    .matrix-grid {
      display: inline-grid;
      gap: 8px;
      padding: 20px;
      background: #f8f9fa;
      border-radius: 12px;
      border: 3px solid #667eea;
    }
    
    .matrix-grid input {
      width: 60px;
      height: 50px;
      text-align: center;
      font-size: 18px;
      font-weight: 600;
      border: 2px solid #ddd;
    }
    
    .buttons {
      display: flex;
      gap: 15px;
      flex-wrap: wrap;
      margin-bottom: 30px;
    }
    
    button {
      flex: 1;
      min-width: 120px;
      padding: 15px 25px;
      font-size: 16px;
      font-weight: 600;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.3s;
      color: white;
    }
    
    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
    }
    
    .btn-add { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
    .btn-multiply { background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); }
    .btn-transpose { background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); }
    .btn-subtract { background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%); }
    .btn-scalar { background: linear-gradient(135deg, #ffd93d 0%, #ffb142 100%); }
    .btn-determinant { background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%); }
    .btn-inverse { background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%); }
    
    .result-section {
      margin-top: 30px;
      padding: 25px;
      background: #f8f9fa;
      border-radius: 12px;
      border-left: 5px solid #667eea;
    }
    
    .result-left, .result-right {
      min-width: 0;
      box-sizing: border-box;
      max-height: 70vh;
      overflow-y: auto;
      padding-right: 10px;
    }
    
    .result-left h3, .result-right h3 {
      color: #764ba2;
      margin-bottom: 20px;
    }
    
    .steps {
      max-height: 60vh;
      overflow-y: auto;
      padding-right: 10px;
    }
    

    
    .step {
      padding: 15px;
      margin-bottom: 15px;
      background: white;
      border-radius: 8px;
      border-left: 4px solid #667eea;
      animation: slideIn 0.5s ease-out;
      opacity: 0;
      animation-fill-mode: forwards;
    }
    
    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateX(-20px);
      }
      to {
        opacity: 1;
        transform: translateX(0);
      }
    }
    
    .step-title {
      font-weight: 600;
      color: #667eea;
      margin-bottom: 8px;
    }
    
    .step-content {
      color: #555;
      font-family: 'Courier New', monospace;
      line-height: 1.6;
    }
    
    .matrix-display {
      display: inline-block;
      margin: 10px 0;
      padding: 15px;
      background: white;
      border-radius: 8px;
      border: 2px solid #667eea;
    }
    
    .matrix-row {
      display: flex;
      gap: 12px;
      justify-content: center;
    }
    
    .matrix-cell {
      width: 85px;
      min-width: 85px;
      height: 45px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      color: #333;
      background: #f0f0f0;
      border-radius: 5px;
      transition: all 0.3s ease;
      font-size: 16px;
    }
    
    .matrix-separator {
      width: 20px !important;
      background: transparent !important;
      border: none !important;
      padding: 0 !important;
    }
    
    .highlight {
      background: #ffe066 !important;
      animation: pulse 0.5s ease-in-out;
      transform: scale(1.15);
      box-shadow: 0 0 15px rgba(255, 224, 102, 0.8);
    }
    
    .highlight-row {
      background: #a8e6cf !important;
      transform: scale(1.1);
    }
    
    .highlight-col {
      background: #ffd3b6 !important;
      transform: scale(1.1);
    }
    
    .highlight-cell {
      background: #ff8c69 !important;
      transform: scale(1.3);
      animation: pulse-cell 0.6s ease-in-out;
      box-shadow: 0 0 15px rgba(255, 140, 105, 0.8);
      z-index: 10;
      position: relative;
    }
    
    @keyframes pulse-cell {
      0%, 100% { transform: scale(1.3); }
      50% { transform: scale(1.5); }
    }
    
    .highlight-processing {
      background: #ff6b6b !important;
      animation: pulse 0.8s ease-in-out infinite;
      transform: scale(1.2);
      box-shadow: 0 0 20px rgba(255, 107, 107, 0.9);
      border: 2px solid #ff4757;
    }
    
    @keyframes pulse {
      0%, 100% { transform: scale(1.15); }
      50% { transform: scale(1.25); }
    }
    
    .formula-display {
      font-size: 18px;
      padding: 15px;
      background: linear-gradient(135deg, #667eea20 0%, #764ba220 100%);
      border-radius: 8px;
      margin: 15px 0;
      font-family: 'Courier New', monospace;
      font-weight: 600;
      color: #764ba2;
      text-align: center;
      border: 2px solid #667eea;
    }
    
    .visual-calculation {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 20px;
      margin: 20px 0;
      flex-wrap: wrap;
      max-width: 100%;
    }
    
    .calc-arrow {
      font-size: 30px;
      color: #667eea;
      animation: bounce 1s infinite;
    }
    
    @keyframes bounce {
      0%, 100% { transform: translateX(0); }
      50% { transform: translateX(10px); }
    }
    
    .error {
      color: #f5576c;
      padding: 15px;
      background: #ffe0e0;
      border-radius: 8px;
      margin-top: 10px;
    }
    
    .theoretical-explanation {
      background: linear-gradient(135deg, #e8f4fd 0%, #d1e7f0 100%);
      border-left-color: #4a90e2;
    }
    
    .theoretical-content {
      font-style: italic;
      color: #2c5282;
      line-height: 1.6;
    }
    
    /* Vector-specific styles */
    .vector-inputs {
      display: flex;
      gap: 30px;
      margin-bottom: 30px;
      flex-wrap: wrap;
    }
    
    .vector-section {
      flex: 1;
      min-width: 200px;
    }
    
    .vector-group {
      background: #f8f9fa;
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 20px;
    }
    
    .vector-group h4 {
      color: #764ba2;
      margin-bottom: 15px;
      font-size: 1.2em;
    }
    
    .vector-input {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 10px;
    }
    
    .vector-input label {
      min-width: 60px;
      font-weight: 600;
      color: #555;
    }
    
    .vector-input input {
      flex: 1;
      padding: 8px 12px;
      border: 2px solid #e0e0e0;
      border-radius: 6px;
      font-size: 16px;
      text-align: center;
    }
    
    .vector-input input:focus {
      border-color: #667eea;
      outline: none;
    }
    
    .vector-buttons {
      display: flex;
      gap: 15px;
      flex-wrap: wrap;
      margin-bottom: 30px;
    }
    
    .vector-btn {
      flex: 1;
      min-width: 150px;
      padding: 15px 20px;
      font-size: 14px;
      font-weight: 600;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.3s;
      color: white;
    }
    
    .btn-vector-add { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
    .btn-vector-add-w { background: linear-gradient(135deg, #4a5fc1 0%, #5a3d91 100%); }
    .btn-vector-subtract { background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%); }
    .btn-vector-subtract-w { background: linear-gradient(135deg, #d43d3d 0%, #c9302c 100%); }
    .btn-vector-scalar { background: linear-gradient(135deg, #ffd93d 0%, #ffb142 100%); }
    .btn-vector-scalar-w { background: linear-gradient(135deg, #e6b800 0%, #d39e00 100%); }
    .btn-vector-norm { background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); }
    .btn-vector-norm-w { background: linear-gradient(135deg, #c06bd6 0%, #d6336c 100%); }
    .btn-vector-distance { background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); }
    .btn-vector-components { background: linear-gradient(135deg, #a8e6cf 0%, #52c234 100%); }
    
    .vector-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
    }
    
    .test-section {
      margin-top: 20px;
      text-align: center;
    }
    
    .test-btn {
      background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%);
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
      box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3);
    }
    
    .test-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(255, 107, 107, 0.4);
    }
    
    .test-results {
      margin-top: 20px;
      padding: 20px;
      background: #f8f9fa;
      border-radius: 12px;
      border-left: 5px solid #28a745;
    }
    
    .test-result {
      margin-bottom: 15px;
      padding: 10px;
      border-radius: 8px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .test-pass {
      background: #d4edda;
      border-left: 4px solid #28a745;
    }
    
    .test-fail {
      background: #f8d7da;
      border-left: 4px solid #dc3545;
    }
    
    .test-name {
      font-weight: 600;
    }
    
    .test-status {
      font-weight: 600;
      padding: 4px 8px;
      border-radius: 4px;
    }
    
    .test-pass .test-status {
      background: #28a745;
      color: white;
    }
    
    .test-fail .test-status {
      background: #dc3545;
      color: white;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üßÆ Matrix & Vector Calculator</h1>
    
    <div class="tabs">
      <button class="tab-button active" onclick="switchTab('matrix')">Matrices</button>
      <button class="tab-button" onclick="switchTab('vector')">Vectors</button>
    </div>
    
    <!-- Matrix Tab Content -->
    <div id="matrix-tab" class="tab-content active">
      <div class="controls">
        <div class="control-group">
          <label>Matrix A Size:</label>
          <select id="sizeA" onchange="updateMatrices()">
            <option value="1x1">1√ó1</option>
            <option value="1x2">1√ó2</option>
            <option value="1x3">1√ó3</option>
            <option value="1x4">1√ó4</option>
            <option value="1x5">1√ó5</option>
            <option value="2x1">2√ó1</option>
            <option value="2x2">2√ó2</option>
            <option value="2x3">2√ó3</option>
            <option value="2x4">2√ó4</option>
            <option value="2x5">2√ó5</option>
            <option value="3x1">3√ó1</option>
            <option value="3x2">3√ó2</option>
            <option value="3x3" selected>3√ó3</option>
            <option value="3x4">3√ó4</option>
            <option value="3x5">3√ó5</option>
            <option value="4x1">4√ó1</option>
            <option value="4x2">4√ó2</option>
            <option value="4x3">4√ó3</option>
            <option value="4x4">4√ó4</option>
            <option value="4x5">4√ó5</option>
            <option value="5x1">5√ó1</option>
            <option value="5x2">5√ó2</option>
            <option value="5x3">5√ó3</option>
            <option value="5x4">5√ó4</option>
            <option value="5x5">5√ó5</option>
          </select>
        </div>
        <div class="control-group">
          <label>Matrix B Size:</label>
          <select id="sizeB" onchange="updateMatrices()">
            <option value="1x1">1√ó1</option>
            <option value="1x2">1√ó2</option>
            <option value="1x3">1√ó3</option>
            <option value="1x4">1√ó4</option>
            <option value="1x5">1√ó5</option>
            <option value="2x1">2√ó1</option>
            <option value="2x2">2√ó2</option>
            <option value="2x3">2√ó3</option>
            <option value="2x4">2√ó4</option>
            <option value="2x5">2√ó5</option>
            <option value="3x1">3√ó1</option>
            <option value="3x2">3√ó2</option>
            <option value="3x3" selected>3√ó3</option>
            <option value="3x4">3√ó4</option>
            <option value="3x5">3√ó5</option>
            <option value="4x1">4√ó1</option>
            <option value="4x2">4√ó2</option>
            <option value="4x3">4√ó3</option>
            <option value="4x4">4√ó4</option>
            <option value="4x5">4√ó5</option>
            <option value="5x1">5√ó1</option>
            <option value="5x2">5√ó2</option>
            <option value="5x3">5√ó3</option>
            <option value="5x4">5√ó4</option>
            <option value="5x5">5√ó5</option>
          </select>
        </div>
        <div class="control-group">
          <label>Scalar:</label>
          <input type="number" id="scalarValue" value="2" step="any" style="width: 80px;">
        </div>
      </div>
      
      <div class="matrices-container">
        <div class="matrix-section">
          <h3>Matrix A</h3>
          <div class="matrix-grid" id="matrixA"></div>
        </div>
        <div class="matrix-section">
          <h3>Matrix B</h3>
          <div class="matrix-grid" id="matrixB"></div>
        </div>
      </div>
      
      <div class="buttons">
        <button class="btn-add" onclick="calculate('add')">‚ûï Add A + B</button>
        <button class="btn-subtract" onclick="calculate('subtract')">‚ûñ Subtract A - B</button>
        <button class="btn-multiply" onclick="calculate('multiply')">‚úñÔ∏è Multiply A √ó B</button>
        <button class="btn-scalar" onclick="calculate('scalar')">üî¢ Scalar kA</button>
        <button class="btn-transpose" onclick="calculate('transpose')">üîÑ Transpose A</button>
        <button class="btn-determinant" onclick="calculate('determinant')">üìä Det(A)</button>
        <button class="btn-inverse" onclick="calculate('inverse')">üîÑ‚Åª¬π Inverse A‚Åª¬π</button>
      </div>
      
      <div class="test-section">
        <button class="test-btn" onclick="runMatrixTests()">üßÆ Run Matrix Tests</button>
      </div>
    </div>
    
    <!-- Vector Tab Content -->
    <div id="vector-tab" class="tab-content">
      <div class="vector-inputs">
        <div class="vector-section">
          <div class="vector-group">
            <h4>Vector Operations</h4>
            <div class="vector-input">
              <label>Vector U:</label>
              <input type="number" id="u1" placeholder="x" step="any">
              <input type="number" id="u2" placeholder="y" step="any">
              <input type="number" id="u3" placeholder="z" step="any">
            </div>
            <div class="vector-input">
              <label>Vector V:</label>
              <input type="number" id="v1" placeholder="x" step="any">
              <input type="number" id="v2" placeholder="y" step="any">
              <input type="number" id="v3" placeholder="z" step="any">
            </div>
            <div class="vector-input">
              <label>Vector W:</label>
              <input type="number" id="w1" placeholder="x" step="any">
              <input type="number" id="w2" placeholder="y" step="any">
              <input type="number" id="w3" placeholder="z" step="any">
            </div>
            <div class="vector-input">
              <label>Scalar k:</label>
              <input type="number" id="vectorScalar" value="2" step="any" style="max-width: 80px;">
            </div>
          </div>
        </div>
        
        <div class="vector-section">
          <div class="vector-group">
            <h4>Point-to-Point Operations</h4>
            <div class="vector-input">
              <label>Point P1:</label>
              <input type="number" id="p1x" placeholder="x" step="any">
              <input type="number" id="p1y" placeholder="y" step="any">
              <input type="number" id="p1z" placeholder="z" step="any">
            </div>
            <div class="vector-input">
              <label>Point P2:</label>
              <input type="number" id="p2x" placeholder="x" step="any">
              <input type="number" id="p2y" placeholder="y" step="any">
              <input type="number" id="p2z" placeholder="z" step="any">
            </div>
          </div>
        </div>
      </div>
      
      <div class="vector-buttons">
        <button class="vector-btn btn-vector-add" onclick="calculateVector('add')">‚ûï U + V</button>
        <button class="vector-btn btn-vector-add-w" onclick="calculateVector('addW')">‚ûï U + W</button>
        <button class="vector-btn btn-vector-subtract" onclick="calculateVector('subtract')">‚ûñ U - V</button>
        <button class="vector-btn btn-vector-subtract-w" onclick="calculateVector('subtractW')">‚ûñ U - W</button>
        <button class="vector-btn btn-vector-scalar" onclick="calculateVector('scalar')">üî¢ kU</button>
        <button class="vector-btn btn-vector-scalar-w" onclick="calculateVector('scalarW')">üî¢ kW</button>
        <button class="vector-btn btn-vector-norm" onclick="calculateVector('norm')">üìè ||U||</button>
        <button class="vector-btn btn-vector-norm-w" onclick="calculateVector('normW')">üìè ||W||</button>
        <button class="vector-btn btn-vector-distance" onclick="calculateVector('distance')">üìç Distance P1-P2</button>
        <button class="vector-btn btn-vector-components" onclick="calculateVector('components')">‚Üí Vector P1‚ÜíP2</button>
      </div>
      
      <div class="test-section">
        <button class="test-btn" onclick="runVectorTests()">üß™ Run Vector Tests</button>
      </div>
    </div>
    
    <div class="result-section" id="result" style="display: none;">
      <div class="row">
        <div class="col-12">
          <h3>Step-by-Step Process</h3>
          <div id="processContainer"></div>
        </div>
      </div>
    </div>
  </div>
  
  <script>
    let stepDelay = 0;
    
    function switchTab(tabName) {
      // Hide all tabs
      document.querySelectorAll('.tab-content').forEach(tab => {
        tab.classList.remove('active');
      });
      document.querySelectorAll('.tab-button').forEach(btn => {
        btn.classList.remove('active');
      });
      
      // Show selected tab
      document.getElementById(tabName + '-tab').classList.add('active');
      event.target.classList.add('active');
      
      // Hide results when switching tabs
      document.getElementById('result').style.display = 'none';
    }
    
    // Vector Functions
    function getVector(idPrefix) {
      return [
        parseFloat(document.getElementById(idPrefix + '1').value) || 0,
        parseFloat(document.getElementById(idPrefix + '2').value) || 0,
        parseFloat(document.getElementById(idPrefix + '3').value) || 0
      ];
    }
    
    function getPoint(idPrefix) {
      return [
        parseFloat(document.getElementById(idPrefix + 'x').value) || 0,
        parseFloat(document.getElementById(idPrefix + 'y').value) || 0,
        parseFloat(document.getElementById(idPrefix + 'z').value) || 0
      ];
    }
    
    function displayVector(vector, label = '') {
      const div = document.createElement('div');
      div.className = 'vector-display';
      
      if (label) {
        const labelSpan = document.createElement('span');
        labelSpan.textContent = label + ' ';
        div.appendChild(labelSpan);
      }
      
      div.innerHTML += `<span class="vector-arrow">‚Üí</span> (${vector[0]}, ${vector[1]}, ${vector[2]})`;
      return div;
    }
    
    function calculateVector(operation) {
      stepDelay = 0;
      const resultDiv = document.getElementById('result');
      const container = document.getElementById('processContainer');
      
      resultDiv.style.display = 'block';
      container.innerHTML = '';
      
      try {
        switch(operation) {
          case 'add':
            vectorAdd();
            break;
          case 'addW':
            vectorAddW();
            break;
          case 'subtract':
            vectorSubtract();
            break;
          case 'subtractW':
            vectorSubtractW();
            break;
          case 'scalar':
            vectorScalarMultiply();
            break;
          case 'scalarW':
            vectorScalarMultiplyW();
            break;
          case 'norm':
            vectorNorm();
            break;
          case 'normW':
            vectorNormW();
            break;
          case 'distance':
            vectorDistance();
            break;
          case 'components':
            vectorComponents();
            break;
        }
      } catch (error) {
        resultContent.innerHTML = `<div class="error">${error.message}</div>`;
      }
    }
    
    function vectorAdd() {
      const u = getVector('u');
      const v = getVector('v');
      
      addStep('Vector Addition Setup', 'Adding vectors U and V component-wise');
      
      const result = [u[0] + v[0], u[1] + v[1], u[2] + v[2]];
      
      addStep('Component Addition', 
        `U = (${u[0]}, ${u[1]}, ${u[2]})<br>V = (${v[0]}, ${v[1]}, ${v[2]})<br><br>` +
        `U + V = (${u[0]} + ${v[0]}, ${u[1]} + ${v[1]}, ${u[2]} + ${v[2]}) = (${result[0]}, ${result[1]}, ${result[2]})`,
        1000
      );
      
      setTimeout(() => {
        document.getElementById('processContainer').appendChild(displayVector(result, 'U + V'));
        
        setTimeout(() => {
          addTheoreticalExplanation('Vector Addition Theory', 
            'Vector addition is performed component-wise: (u‚ÇÅ + v‚ÇÅ, u‚ÇÇ + v‚ÇÇ, u‚ÇÉ + v‚ÇÉ). This operation follows the parallelogram law - the sum of two vectors is the diagonal of the parallelogram formed by the vectors. Vector addition is commutative (U + V = V + U) and associative ((U + V) + W = U + (V + W)).');
        }, 500);
      }, stepDelay);
    }
    
    function vectorSubtract() {
      const u = getVector('u');
      const v = getVector('v');
      
      addStep('Vector Subtraction Setup', 'Subtracting vector V from vector U component-wise');
      
      const result = [u[0] - v[0], u[1] - v[1], u[2] - v[2]];
      
      addStep('Component Subtraction', 
        `U = (${u[0]}, ${u[1]}, ${u[2]})<br>V = (${v[0]}, ${v[1]}, ${v[2]})<br><br>` +
        `U - V = (${u[0]} - ${v[0]}, ${u[1]} - ${v[1]}, ${u[2]} - ${v[2]}) = (${result[0]}, ${result[1]}, ${result[2]})`,
        1000
      );
      
      setTimeout(() => {
        document.getElementById('processContainer').appendChild(displayVector(result, 'U - V'));
        
        setTimeout(() => {
          addTheoreticalExplanation('Vector Subtraction Theory', 
            'Vector subtraction is performed component-wise: (u‚ÇÅ - v‚ÇÅ, u‚ÇÇ - v‚ÇÇ, u‚ÇÉ - v‚ÇÉ). Geometrically, U - V gives the vector from the tip of V to the tip of U. Vector subtraction is not commutative (U - V ‚â† V - U).');
        }, 500);
      }, stepDelay);
    }
    
    function vectorScalarMultiply() {
      const u = getVector('u');
      const k = parseFloat(document.getElementById('vectorScalar').value) || 0;
      
      addStep('Scalar Multiplication Setup', `Multiplying vector U by scalar ${k}`);
      
      const result = [k * u[0], k * u[1], k * u[2]];
      
      addStep('Component Multiplication', 
        `k = ${k}<br>U = (${u[0]}, ${u[1]}, ${u[2]})<br><br>` +
        `kU = (${k} √ó ${u[0]}, ${k} √ó ${u[1]}, ${k} √ó ${u[2]}) = (${result[0]}, ${result[1]}, ${result[2]})`,
        1000
      );
      
      setTimeout(() => {
        document.getElementById('processContainer').appendChild(displayVector(result, `${k}U`));
        
        setTimeout(() => {
          addTheoreticalExplanation('Scalar Multiplication Theory', 
            'Scalar multiplication multiplies each component by the scalar: (k √ó u‚ÇÅ, k √ó u‚ÇÇ, k √ó u‚ÇÉ). If k > 1, the vector is stretched; if 0 < k < 1, it\'s compressed; if k < 0, the direction is reversed. Properties include: k(U + V) = kU + kV, (k + m)U = kU + mU, and (km)U = k(mU).');
        }, 500);
      }, stepDelay);
    }
    
    function vectorNorm() {
      const u = getVector('u');
      
      addStep('Vector Norm (Magnitude) Setup', 'Calculating the Euclidean norm of vector U');
      
      const norm = Math.sqrt(u[0]*u[0] + u[1]*u[1] + u[2]*u[2]);
      
      addStep('Norm Calculation', 
        `U = (${u[0]}, ${u[1]}, ${u[2]})<br><br>` +
        `||U|| = ‚àö(${u[0]}¬≤ + ${u[1]}¬≤ + ${u[2]}¬≤) = ‚àö(${u[0]*u[0]} + ${u[1]*u[1]} + ${u[2]*u[2]}) = ‚àö(${u[0]*u[0] + u[1]*u[1] + u[2]*u[2]}) = ${norm.toFixed(3)}`,
        1500
      );
      
      setTimeout(() => {
        document.getElementById('processContainer').innerHTML = 
          `<div style="font-size: 24px; font-weight: 600; color: #667eea;">||U|| = ${norm.toFixed(3)}</div>`;
        
        setTimeout(() => {
          addTheoreticalExplanation('Vector Norm Theory', 
            'The Euclidean norm (magnitude) measures the length of a vector: ||U|| = ‚àö(u‚ÇÅ¬≤ + u‚ÇÇ¬≤ + u‚ÇÉ¬≤). A unit vector has norm 1. The norm satisfies the triangle inequality: ||U + V|| ‚â§ ||U|| + ||V||. Zero vector has norm 0. The norm is always non-negative.');
        }, 500);
      }, stepDelay);
    }
    
    function vectorDistance() {
      const p1 = getPoint('p1');
      const p2 = getPoint('p2');
      
      addStep('Distance Between Points Setup', 'Calculating Euclidean distance between points P1 and P2');
      
      const diff = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];
      const distance = Math.sqrt(diff[0]*diff[0] + diff[1]*diff[1] + diff[2]*diff[2]);
      
      addStep('Distance Calculation', 
        `P1 = (${p1[0]}, ${p1[1]}, ${p1[2]})<br>P2 = (${p2[0]}, ${p2[1]}, ${p2[2]})<br><br>` +
        `Vector P1‚ÜíP2 = (${diff[0]}, ${diff[1]}, ${diff[2]})<br>` +
        `Distance = ||P2 - P1|| = ‚àö((${diff[0]})¬≤ + (${diff[1]})¬≤ + (${diff[2]})¬≤) = ‚àö(${diff[0]*diff[0]} + ${diff[1]*diff[1]} + ${diff[2]*diff[2]}) = ‚àö(${diff[0]*diff[0] + diff[1]*diff[1] + diff[2]*diff[2]}) = ${distance.toFixed(3)}`,
        1500
      );
      
      setTimeout(() => {
        document.getElementById('processContainer').innerHTML = 
          `<div style="font-size: 24px; font-weight: 600; color: #667eea;">Distance = ${distance.toFixed(3)}</div>`;
        
        setTimeout(() => {
          addTheoreticalExplanation('Distance Between Points Theory', 
            'The Euclidean distance between points P1 and P2 is ||P2 - P1|| = ‚àö((x‚ÇÇ-x‚ÇÅ)¬≤ + (y‚ÇÇ-y‚ÇÅ)¬≤ + (z‚ÇÇ-z‚ÇÅ)¬≤). This is the straight-line distance in 3D space. Distance is always non-negative and symmetric (distance P1‚ÜíP2 = distance P2‚ÜíP1).');
        }, 500);
      }, stepDelay);
    }
    
    function vectorComponents() {
      const p1 = getPoint('p1');
      const p2 = getPoint('p2');
      
      addStep('Vector Components Setup', 'Finding the vector from point P1 to point P2');
      
      const components = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];
      
      addStep('Component Calculation', 
        `P1 = (${p1[0]}, ${p1[1]}, ${p1[2]})<br>P2 = (${p2[0]}, ${p2[1]}, ${p2[2]})<br><br>` +
        `Vector P1‚ÜíP2 = P2 - P1 = (${p2[0]} - ${p1[0]}, ${p2[1]} - ${p1[1]}, ${p2[2]} - ${p1[2]}) = (${components[0]}, ${components[1]}, ${components[2]})`,
        1000
      );
      
      setTimeout(() => {
        document.getElementById('processContainer').appendChild(displayVector(components, 'P1‚ÜíP2'));
        
        setTimeout(() => {
          addTheoreticalExplanation('Vector Components Theory', 
            'The vector from point P1 to P2 has components (x‚ÇÇ-x‚ÇÅ, y‚ÇÇ-y‚ÇÅ, z‚ÇÇ-z‚ÇÅ). This represents the displacement vector. The initial point P1 is the "tail" and terminal point P2 is the "head" of the vector. Vector components determine both magnitude and direction in 3D space.');
        }, 500);
      }, stepDelay);
    }
    
    function vectorAddW() {
      const u = getVector('u');
      const w = getVector('w');
      
      addStep('Vector Addition Setup', 'Adding vectors U and W component-wise');
      
      const result = [u[0] + w[0], u[1] + w[1], u[2] + w[2]];
      
      addStep('Component Addition', 
        `U = (${u[0]}, ${u[1]}, ${u[2]})<br>W = (${w[0]}, ${w[1]}, ${w[2]})<br><br>` +
        `U + W = (${u[0]} + ${w[0]}, ${u[1]} + ${w[1]}, ${u[2]} + ${w[2]}) = (${result[0]}, ${result[1]}, ${result[2]})`,
        1000
      );
      
      setTimeout(() => {
        document.getElementById('processContainer').appendChild(displayVector(result, 'U + W'));
        
        setTimeout(() => {
          addTheoreticalExplanation('Vector Addition Theory', 
            'Vector addition is performed component-wise: (u‚ÇÅ + w‚ÇÅ, u‚ÇÇ + w‚ÇÇ, u‚ÇÉ + w‚ÇÉ). This operation follows the parallelogram law - the sum of two vectors is the diagonal of the parallelogram formed by the vectors. Vector addition is commutative (U + W = W + U) and associative ((U + W) + V = U + (W + V)).');
        }, 500);
      }, stepDelay);
    }
    
    function vectorSubtractW() {
      const u = getVector('u');
      const w = getVector('w');
      
      addStep('Vector Subtraction Setup', 'Subtracting vector W from vector U component-wise');
      
      const result = [u[0] - w[0], u[1] - w[1], u[2] - w[2]];
      
      addStep('Component Subtraction', 
        `U = (${u[0]}, ${u[1]}, ${u[2]})<br>W = (${w[0]}, ${w[1]}, ${w[2]})<br><br>` +
        `U - W = (${u[0]} - ${w[0]}, ${u[1]} - ${w[1]}, ${u[2]} - ${w[2]}) = (${result[0]}, ${result[1]}, ${result[2]})`,
        1000
      );
      
      setTimeout(() => {
        document.getElementById('processContainer').appendChild(displayVector(result, 'U - W'));
        
        setTimeout(() => {
          addTheoreticalExplanation('Vector Subtraction Theory', 
            'Vector subtraction is performed component-wise: (u‚ÇÅ - w‚ÇÅ, u‚ÇÇ - w‚ÇÇ, u‚ÇÉ - w‚ÇÉ). Geometrically, U - W gives the vector from the tip of W to the tip of U. Vector subtraction is not commutative (U - W ‚â† W - U).');
        }, 500);
      }, stepDelay);
    }
    
    function vectorScalarMultiplyW() {
      const w = getVector('w');
      const k = parseFloat(document.getElementById('vectorScalar').value) || 0;
      
      addStep('Scalar Multiplication Setup', `Multiplying vector W by scalar ${k}`);
      
      const result = [k * w[0], k * w[1], k * w[2]];
      
      addStep('Component Multiplication', 
        `k = ${k}<br>W = (${w[0]}, ${w[1]}, ${w[2]})<br><br>` +
        `kW = (${k} √ó ${w[0]}, ${k} √ó ${w[1]}, ${k} √ó ${w[2]}) = (${result[0]}, ${result[1]}, ${result[2]})`,
        1000
      );
      
      setTimeout(() => {
        document.getElementById('processContainer').appendChild(displayVector(result, `${k}W`));
        
        setTimeout(() => {
          addTheoreticalExplanation('Scalar Multiplication Theory', 
            'Scalar multiplication multiplies each component by the scalar: (k √ó w‚ÇÅ, k √ó w‚ÇÇ, k √ó w‚ÇÉ). If k > 1, the vector is stretched; if 0 < k < 1, it\'s compressed; if k < 0, the direction is reversed. Properties include: k(W + U) = kW + kU, (k + m)W = kW + mW, and (km)W = k(mW).');
        }, 500);
      }, stepDelay);
    }
    
    function vectorNormW() {
      const w = getVector('w');
      
      addStep('Vector Norm (Magnitude) Setup', 'Calculating the Euclidean norm of vector W');
      
      const norm = Math.sqrt(w[0]*w[0] + w[1]*w[1] + w[2]*w[2]);
      
      addStep('Norm Calculation', 
        `W = (${w[0]}, ${w[1]}, ${w[2]})<br><br>` +
        `||W|| = ‚àö(${w[0]}¬≤ + ${w[1]}¬≤ + ${w[2]}¬≤) = ‚àö(${w[0]*w[0]} + ${w[1]*w[1]} + ${w[2]*w[2]}) = ‚àö(${w[0]*w[0] + w[1]*w[1] + w[2]*w[2]}) = ${norm.toFixed(3)}`,
        1500
      );
      
      setTimeout(() => {
        document.getElementById('processContainer').innerHTML = 
          `<div style="font-size: 24px; font-weight: 600; color: #667eea;">||W|| = ${norm.toFixed(3)}</div>`;
        
        setTimeout(() => {
          addTheoreticalExplanation('Vector Norm Theory', 
            'The Euclidean norm (magnitude) measures the length of a vector: ||W|| = ‚àö(w‚ÇÅ¬≤ + w‚ÇÇ¬≤ + w‚ÇÉ¬≤). A unit vector has norm 1. The norm satisfies the triangle inequality: ||W + U|| ‚â§ ||W|| + ||U||. Zero vector has norm 0. The norm is always non-negative.');
        }, 500);
      }, stepDelay);
    }
    
    function updateMatrices() {
      const sizeA = document.getElementById('sizeA').value.split('x');
      const sizeB = document.getElementById('sizeB').value.split('x');
      
      createMatrixInputs('matrixA', parseInt(sizeA[0]), parseInt(sizeA[1]));
      createMatrixInputs('matrixB', parseInt(sizeB[0]), parseInt(sizeB[1]));
      
      document.getElementById('result').style.display = 'none';
    }
    
    function createMatrixInputs(id, rows, cols) {
      const container = document.getElementById(id);
      container.innerHTML = '';
      container.style.gridTemplateColumns = `repeat(${cols}, 60px)`;
      
      for (let i = 0; i < rows * cols; i++) {
        const input = document.createElement('input');
        input.type = 'number';
        input.value = Math.floor(Math.random() * 10);
        input.step = 'any';
        container.appendChild(input);
      }
    }
    
    function getMatrix(id) {
      const sizeStr = id === 'matrixA' ? 
        document.getElementById('sizeA').value :
        document.getElementById('sizeB').value;
      
      const size = sizeStr.split('x');
      const rows = parseInt(size[0]);
      const cols = parseInt(size[1]);
      
      const inputs = document.getElementById(id).getElementsByTagName('input');
      const matrix = [];
      
      for (let i = 0; i < rows; i++) {
        matrix[i] = [];
        for (let j = 0; j < cols; j++) {
          matrix[i][j] = parseFloat(inputs[i * cols + j].value) || 0;
        }
      }
      
      return matrix;
    }
    
    function displayMatrix(matrix, label = '') {
      const div = document.createElement('div');
      div.className = 'matrix-display';
      
      if (label) {
        const labelDiv = document.createElement('div');
        labelDiv.style.marginBottom = '10px';
        labelDiv.style.fontWeight = '600';
        labelDiv.textContent = label;
        div.appendChild(labelDiv);
      }
      
      matrix.forEach(row => {
        const rowDiv = document.createElement('div');
        rowDiv.className = 'matrix-row';
        row.forEach(val => {
          const cell = document.createElement('div');
          cell.className = 'matrix-cell';
          if (isNaN(val) || !isFinite(val)) {
            cell.textContent = '0.00'; // Handle NaN/Infinity
          } else {
            cell.textContent = Number.isInteger(val) ? val : val.toFixed(2);
          }
          rowDiv.appendChild(cell);
        });
        div.appendChild(rowDiv);
      });
      
      return div;
    }
    
    function displayAugmented(matrix, label = '') {
      const div = document.createElement('div');
      div.className = 'matrix-display';
      
      if (label) {
        const labelDiv = document.createElement('div');
        labelDiv.style.marginBottom = '10px';
        labelDiv.style.fontWeight = '600';
        labelDiv.textContent = label;
        div.appendChild(labelDiv);
      }
      
      const n = matrix.length; // Size of square matrix A
      
      matrix.forEach(row => {
        const rowDiv = document.createElement('div');
        rowDiv.className = 'matrix-row';
        
        // Left side: original matrix A
        for (let j = 0; j < n; j++) {
          const cell = document.createElement('div');
          cell.className = 'matrix-cell';
          const val = row[j];
          if (isNaN(val) || !isFinite(val)) {
            cell.textContent = '0.00'; // Handle NaN/Infinity
          } else {
            cell.textContent = Number.isInteger(val) ? val : val.toFixed(2);
          }
          rowDiv.appendChild(cell);
        }
        
        // Vertical separator
        const separator = document.createElement('div');
        separator.className = 'matrix-cell matrix-separator';
        separator.textContent = '|';
        separator.style.fontWeight = 'bold';
        separator.style.color = '#667eea';
        rowDiv.appendChild(separator);
        
        // Right side: identity matrix I
        for (let j = n; j < 2 * n; j++) {
          const cell = document.createElement('div');
          cell.className = 'matrix-cell';
          const val = row[j];
          if (isNaN(val) || !isFinite(val)) {
            cell.textContent = '0.00'; // Handle NaN/Infinity
          } else {
            cell.textContent = Number.isInteger(val) ? val : val.toFixed(2);
          }
          rowDiv.appendChild(cell);
        }
        
        div.appendChild(rowDiv);
      });
      
      return div;
    }
    
    function addStep(title, content, delay = 500) {
      setTimeout(() => {
        const container = document.getElementById('processContainer');
        const step = document.createElement('div');
        step.className = 'step';
        step.style.animationDelay = '0s';
        
        const titleDiv = document.createElement('div');
        titleDiv.className = 'step-title';
        titleDiv.textContent = title;
        
        const contentDiv = document.createElement('div');
        contentDiv.className = 'step-content';
        if (typeof content === 'string') {
          contentDiv.innerHTML = content;
        } else {
          contentDiv.appendChild(content);
        }
        
        step.appendChild(titleDiv);
        step.appendChild(contentDiv);
        container.appendChild(step);
        
        // Auto-scroll to keep the latest step visible
        setTimeout(() => {
          step.scrollIntoView({ behavior: 'smooth', block: 'end' });
        }, 100);
      }, stepDelay);
      
      stepDelay += delay;
    }
    
    function addTheoreticalExplanation(title, content) {
      setTimeout(() => {
        const container = document.getElementById('processContainer');
        const explanation = document.createElement('div');
        explanation.className = 'theoretical-explanation';
        
        const titleDiv = document.createElement('div');
        titleDiv.className = 'step-title';
        titleDiv.textContent = title;
        
        const contentDiv = document.createElement('div');
        contentDiv.className = 'theoretical-content';
        contentDiv.textContent = content;
        
        explanation.appendChild(titleDiv);
        explanation.appendChild(contentDiv);
        container.appendChild(explanation);
        
        // Auto-scroll to keep the latest explanation visible
        setTimeout(() => {
          explanation.scrollIntoView({ behavior: 'smooth', block: 'end' });
        }, 100);
      }, stepDelay);
      
      stepDelay += 1000; // Give more time for theoretical explanations
    }
    
    function calculate(operation) {
      stepDelay = 0;
      const resultDiv = document.getElementById('result');
      const container = document.getElementById('processContainer');
      
      resultDiv.style.display = 'block';
      container.innerHTML = '';
      
      const matrixA = getMatrix('matrixA');
      const matrixB = getMatrix('matrixB');
      
      try {
        switch(operation) {
          case 'add':
            addMatrices(matrixA, matrixB);
            break;
          case 'subtract':
            subtractMatrices(matrixA, matrixB);
            break;
          case 'multiply':
            multiplyMatrices(matrixA, matrixB);
            break;
          case 'scalar':
            scalarMultiply(matrixA);
            break;
          case 'transpose':
            transposeMatrix(matrixA);
            break;
          case 'determinant':
            calculateDeterminant(matrixA);
            break;
          case 'inverse':
            calculateInverse(matrixA);
            break;
        }
      } catch (error) {
        resultContent.innerHTML = `<div class="error">${error.message}</div>`;
      }
    }
    
    function addMatrices(A, B) {
      const result = addMatricesCalc(A, B);
      
      addStep('Step 1: Matrix Addition', 'Adding corresponding elements from Matrix A and Matrix B', 750);
      
      for (let i = 0; i < A.length; i++) {
        for (let j = 0; j < A[0].length; j++) {
          addStep(
            `Element [${i+1},${j+1}]`,
            `A[${i+1},${j+1}] + B[${i+1},${j+1}] = ${A[i][j]} + ${B[i][j]} = ${result[i][j]}`,
            450
          );
        }
      }
      
      setTimeout(() => {
        addVisualElement(displayMatrix(result, 'Result: A + B'));
        
        // Add theoretical explanation
        setTimeout(() => {
          addTheoreticalExplanation('Matrix Addition Theory', 
            'Matrix addition is performed element-wise, where each element of the result matrix C is the sum of the corresponding elements from matrices A and B: C·µ¢‚±º = A·µ¢‚±º + B·µ¢‚±º. This operation requires both matrices to have identical dimensions (same number of rows and columns). Matrix addition is commutative (A + B = B + A) and associative ((A + B) + C = A + (B + C)).');
        }, 750);
      }, stepDelay);
      
      return result;
    }
    
    function subtractMatrices(A, B) {
      const result = subtractMatricesCalc(A, B);
      
      addStep('Step 1: Matrix Subtraction', 'Subtracting corresponding elements from Matrix B from Matrix A', 750);
      
      for (let i = 0; i < A.length; i++) {
        for (let j = 0; j < A[0].length; j++) {
          addStep(
            `Element [${i+1},${j+1}]`,
            `A[${i+1},${j+1}] - B[${i+1},${j+1}] = ${A[i][j]} - ${B[i][j]} = ${result[i][j]}`,
            450
          );
        }
      }
      
      setTimeout(() => {
        addVisualElement(displayMatrix(result, 'Result: A - B'));
        
        // Add theoretical explanation
        setTimeout(() => {
          addTheoreticalExplanation('Matrix Subtraction Theory', 
            'Matrix subtraction is performed element-wise, where each element of the result matrix C is the difference of the corresponding elements from matrices A and B: C·µ¢‚±º = A·µ¢‚±º - B·µ¢‚±º. This operation requires both matrices to have identical dimensions (same number of rows and columns). Matrix subtraction is not commutative (A - B ‚â† B - A).');
        }, 750);
      }, stepDelay);
      
      return result;
    }
    
    function scalarMultiply(A) {
      const scalar = parseFloat(document.getElementById('scalarValue').value) || 0;
      const result = scalarMultiplyCalc(A, scalar);
      
      addStep('Step 1: Scalar Multiplication', `Multiplying matrix A by scalar ${scalar}`, 750);
      
      for (let i = 0; i < A.length; i++) {
        for (let j = 0; j < A[0].length; j++) {
          addStep(
            `Element [${i+1},${j+1}]`,
            `${scalar} √ó A[${i+1},${j+1}] = ${scalar} √ó ${A[i][j]} = ${result[i][j]}`,
            450
          );
        }
      }
      
      setTimeout(() => {
        addVisualElement(displayMatrix(result, `Result: ${scalar}A`));
        
        // Add theoretical explanation
        setTimeout(() => {
          addTheoreticalExplanation('Scalar Multiplication Theory', 
            'Scalar multiplication multiplies each element of the matrix by a scalar value k: (kA)·µ¢‚±º = k √ó A·µ¢‚±º. This operation changes the scale of the matrix while preserving its structure. Properties include: k(A + B) = kA + kB, (k + m)A = kA + mA, and (km)A = k(mA). Scalar multiplication is used in transformations, scaling, and solving linear equations.');
        }, 750);
      }, stepDelay);
      
      return result;
    }
    
    function multiplyMatrices(A, B) {
      const result = multiplyMatricesCalc(A, B);
      
      addStep('Step 1: Matrix Multiplication Setup', `Multiplying ${A.length}√ó${A[0].length} matrix with ${B.length}√ó${B[0].length} matrix`, 750);
      
      // Create visual multiplication display - synchronized with first step
      setTimeout(() => {
        const visualDiv = document.createElement('div');
        visualDiv.className = 'visual-calculation';
        visualDiv.innerHTML = `
          <div id="matrixA-visual">${displayMatrix(A, 'Matrix A').outerHTML}</div>
          <div class="calc-arrow">√ó</div>
          <div id="matrixB-visual">${displayMatrix(B, 'Matrix B').outerHTML}</div>
          <div class="calc-arrow">=</div>
          <div id="result-visual">${displayMatrix(result, 'Result C').outerHTML}</div>
        `;
        addVisualElement(visualDiv);
      }, stepDelay);
      
      for (let i = 0; i < A.length; i++) {
        for (let j = 0; j < B[0].length; j++) {
          let calculation = '';
          
          // Start processing this result cell
          setTimeout(() => {
            highlightResultProcessing('result-visual', i, j);
            highlightRow('matrixA-visual', i);
            highlightCol('matrixB-visual', j);
          }, stepDelay);
          
          addStep(`Computing C[${i+1},${j+1}]`, `Row ${i+1} of A √ó Column ${j+1} of B`, 1800);
          
          for (let k = 0; k < A[0].length; k++) {
            calculation += `${A[i][k]}√ó${B[k][j]}`;
            if (k < A[0].length - 1) calculation += ' + ';
            
            // Animate individual multiplication - highlight specific cells being multiplied
            setTimeout(() => {
              highlightCell('matrixA-visual', i, k);
              highlightCell('matrixB-visual', k, j); // This is the specific digit in the column
            }, stepDelay);
            
            addStep(
              `Step: A[${i+1},${k+1}] √ó B[${k+1},${j+1}]`,
              `${A[i][k]} √ó ${B[k][j]} = ${A[i][k] * B[k][j]}`,
              1500
            );
          }
          
          // Update result matrix with final value
          setTimeout(() => {
            updateResultCell('result-visual', i, j, result[i][j]);
            clearHighlights();
          }, stepDelay);
          
          addStep(
            `C[${i+1},${j+1}] Complete`,
            `${calculation} = ${result[i][j]}`,
            1800
          );
        }
      }
      
      setTimeout(() => {
        addVisualElement(displayMatrix(result, 'Final Result: A √ó B'));
        
        // Add theoretical explanation
        setTimeout(() => {
          addTheoreticalExplanation('Matrix Multiplication Theory', 
            'Matrix multiplication combines rows from the first matrix with columns from the second matrix using dot products. For element C·µ¢‚±º, take row i from matrix A and column j from matrix B, multiply corresponding elements, and sum the results. The inner dimensions must match (columns of A = rows of B). Result dimensions are (rows of A) √ó (columns of B). Matrix multiplication is not commutative (A √ó B ‚â† B √ó A in general).');
        }, 750);
      }, stepDelay + 1500);
      
      return result;
    }
    
    function transposeMatrix(A) {
      const result = transposeMatrixCalc(A);
      
      addStep('Step 1: Matrix Transpose Setup', `Transposing ${A.length}√ó${A[0].length} matrix to ${A[0].length}√ó${A.length} matrix`, 750);
      
      // Create visual transpose display - synchronized with first step
      setTimeout(() => {
        const visualDiv = document.createElement('div');
        visualDiv.className = 'visual-calculation';
        visualDiv.innerHTML = `
          <div id="original-matrix">${displayMatrix(A, 'Original A').outerHTML}</div>
          <div class="calc-arrow">‚Üí</div>
          <div id="transpose-result">${displayMatrix(result, 'Transposed A·µÄ').outerHTML}</div>
        `;
        addVisualElement(visualDiv);
      }, stepDelay);
      
      for (let i = 0; i < A.length; i++) {
        for (let j = 0; j < A[0].length; j++) {
          // Animate the element movement
          setTimeout(() => {
            highlightCell('original-matrix', i, j);
            highlightCell('transpose-result', j, i);
          }, stepDelay);
          
          addStep(
            `Element Movement`,
            `A[${i+1},${j+1}] = ${A[i][j]} ‚Üí A·µÄ[${j+1},${i+1}] = ${A[i][j]}`,
            900
          );
          
          // Update the result matrix
          setTimeout(() => {
            updateResultCell('transpose-result', j, i, A[i][j]);
          }, stepDelay + 450);
        }
      }
      
      setTimeout(() => {
        addVisualElement(displayMatrix(result, 'Final Result: A·µÄ'));
        
        // Add theoretical explanation
        setTimeout(() => {
          addTheoreticalExplanation('Matrix Transpose Theory', 
            'Matrix transpose swaps rows with columns: element A·µ¢‚±º becomes A·µÄ‚±º·µ¢. A matrix of size m√ón becomes n√óm. Transpose has several important properties: (A·µÄ)·µÄ = A, (A + B)·µÄ = A·µÄ + B·µÄ, and (A √ó B)·µÄ = B·µÄ √ó A·µÄ. Transpose is used in solving linear systems, finding orthogonal matrices, and many other applications in linear algebra.');
        }, 750);
      }, stepDelay + 1500);
      
      return result;
    }
    
    function calculateDeterminant(A) {
      const det = calculateDeterminantCalc(A);
      
      if (A.length === 2) {
        addStep('Step 1: 2√ó2 Determinant Formula', `det([${A[0][0]} ${A[0][1]}; ${A[1][0]} ${A[1][1]}]) = (${A[0][0]} √ó ${A[1][1]}) - (${A[0][1]} √ó ${A[1][0]}) = ${det}`, 750);
        
        // Visual 2x2 determinant calculation - synchronized with step
        setTimeout(() => {
          const visualDiv = document.createElement('div');
          visualDiv.className = 'visual-calculation';
          visualDiv.innerHTML = `
            <div>${displayMatrix(A, 'Matrix A').outerHTML}</div>
            <div class="calc-arrow">det</div>
            <div class="formula-display">
              (${A[0][0]} √ó ${A[1][1]}) - (${A[0][1]} √ó ${A[1][0]}) = ${det}
            </div>
          `;
          
          addVisualElement(visualDiv);
        }, stepDelay);
        
        setTimeout(() => {
          const finalResultDiv = document.createElement('div');
          finalResultDiv.style.fontSize = '24px';
          finalResultDiv.style.fontWeight = '600';
          finalResultDiv.style.color = '#667eea';
          finalResultDiv.textContent = `Determinant = ${det}`;
          addVisualElement(finalResultDiv);
          
          // Add theoretical explanation
          setTimeout(() => {
            addTheoreticalExplanation('2√ó2 Determinant Theory', 
              'For a 2√ó2 matrix [a b; c d], the determinant is ad - bc. This formula comes from the area of the parallelogram formed by the column vectors. A non-zero determinant indicates the matrix is invertible. If determinant is zero, the matrix is singular and has no inverse.');
          }, 750);
        }, stepDelay + 1000);
        return det;
      }
      
      addStep('Step 1: Cofactor Expansion Setup', `Using cofactor expansion along first row of ${A.length}√ó${A.length} matrix`, 750);
      
      // Show original matrix
      addStep('Original Matrix', displayMatrix(A, 'Matrix A'), 1500);
      
      for (let j = 0; j < A.length; j++) {
        const minor = getMinor(A, 0, j);
        const sign = Math.pow(-1, j);
        const minorDet = calculateDeterminantCalc(minor);
        const cofactor = sign * A[0][j] * minorDet;
        
        // Visual cofactor calculation - synchronized with accumulation step
        setTimeout(() => {
          const visualDiv = document.createElement('div');
          visualDiv.className = 'visual-calculation';
          visualDiv.innerHTML = `
            <div class="formula-display">
              Cofactor [1,${j+1}] = ${sign === 1 ? '+' : '-'}${A[0][j]} √ó det(
            </div>
            <div>${displayMatrix(minor, `Minor M‚ÇÅ,${j+1}`).outerHTML}</div>
            <div class="formula-display">
              ) = ${sign === 1 ? '+' : '-'}${A[0][j]} √ó ${minorDet.toFixed(2)} = ${cofactor.toFixed(2)}
            </div>
          `;
          
          addVisualElement(visualDiv);
        }, stepDelay);
        
        addStep(
          `Accumulate Determinant`,
          `det += ${cofactor.toFixed(2)} ‚Üí Current total: ${det.toFixed(2)}`,
          1200
        );
      }
      
      setTimeout(() => {
        const finalResultDiv = document.createElement('div');
        finalResultDiv.style.fontSize = '24px';
        finalResultDiv.style.fontWeight = '600';
        finalResultDiv.style.color = '#667eea';
        finalResultDiv.textContent = `Determinant = ${det.toFixed(2)}`;
        addVisualElement(finalResultDiv);
        
        // Add theoretical explanation
        setTimeout(() => {
          addTheoreticalExplanation('Determinant Theory (Cofactor Expansion)', 
            'The determinant measures the "volume scaling factor" of a linear transformation. For square matrices, it\'s calculated using cofactor expansion along any row or column. Each cofactor is (-1)‚Å±‚Å∫ ≤ times the determinant of the minor matrix (original matrix with row i and column j removed). If determinant = 0, the matrix is singular (not invertible). If |det| = 1, the transformation preserves volume. Determinant is used in solving systems of equations, finding matrix inverses, and analyzing linear transformations.');
        }, 750);
      }, stepDelay + 1000);
      
      return det;
    }
    
    // Helper function to deep copy a matrix (handles both numbers and Fractions)
    function deepCopyMatrix(matrix) {
      return matrix.map(row => row.map(val => {
        if (val instanceof Fraction) {
          return new Fraction(val.num, val.den);
        }
        return val;
      }));
    }
    
    function calculateInverse(A) {
      const n = A.length;
      
      addStep('Step 1: Gauss-Jordan Elimination Setup',
        `Using Gauss-Jordan elimination with integer-first arithmetic to find inverse of ${n}√ó${n} matrix`, 750);

      // Create augmented matrix [A | I] - start with integers
      const augmented = Array(n).fill().map(() => Array(2 * n).fill(0));
      let useFractions = false;

      // Initialize with integers
      for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
          augmented[i][j] = A[i][j];
        }
        for (let j = 0; j < n; j++) {
          augmented[i][n + j] = (i === j) ? 1 : 0;
        }
      }

      // Display initial augmented matrix
      const initialCopy = deepCopyMatrix(augmented);
      setTimeout(() => {
        addVisualElement(displayAugmentedMatrix(initialCopy, '[A | I] Initial Augmented Matrix', useFractions));
      }, stepDelay);

      addStep('Strategy', 'Intelligently select pivots to avoid fractions: (1) Prefer ¬±1 pivots (no normalization needed), (2) Use smallest values (easier arithmetic), (3) Interchange rows when beneficial. Fractions introduced only when unavoidable.', 1200);

      // Gauss-Jordan elimination step by step
      for (let col = 0; col < n; col++) {
        // Find best pivot to avoid fractions
        // Priority: 1) ¬±1 (no normalization needed), 2) smallest non-zero absolute value, 3) any non-zero
        let bestRow = col;
        let bestValue = augmented[col][col];
        
        // First pass: look for ¬±1 pivots (ideal - no normalization needed)
        for (let row = col; row < n; row++) {
          const val = augmented[row][col];
          if (Math.abs(val) === 1) {
            bestRow = row;
            bestValue = val;
            break; // Found ideal pivot, use it
          }
        }
        
        // Second pass: if no ¬±1 found, prefer smallest non-zero absolute value
        // (easier to work with small numbers and more likely to divide evenly)
        if (Math.abs(bestValue) !== 1) {
          for (let row = col; row < n; row++) {
            const val = augmented[row][col];
            if (val !== 0 && (bestValue === 0 || Math.abs(val) < Math.abs(bestValue))) {
              bestRow = row;
              bestValue = val;
            }
          }
        }

        if (bestValue === 0) {
          throw new Error('Matrix is singular and has no inverse');
        }

        // Report row swap if needed
        if (bestRow !== col) {
          const pivotVal = augmented[bestRow][col];
          const reason = Math.abs(pivotVal) === 1 ? ' to avoid normalization (pivot is ¬±1)' : ' to use smaller pivot and avoid fractions';
          addStep(`Column ${col + 1}: Row Swap`,
            `Interchanging Row ${col + 1} ‚Üî Row ${bestRow + 1}${reason}. New pivot: ${pivotVal}`, 1200);
          [augmented[col], augmented[bestRow]] = [augmented[bestRow], augmented[col]];

          const swapCopy = deepCopyMatrix(augmented);
          setTimeout(() => {
            addVisualElement(displayAugmentedMatrix(swapCopy, `[A | I] after row interchange`, useFractions));
          }, stepDelay);
        } else {
          const pivotVal = augmented[col][col];
          const note = Math.abs(pivotVal) === 1 ? ' (no normalization needed!)' : '';
          addStep(`Column ${col + 1}: Pivot Selected`, `Using Row ${col + 1} with pivot value ${pivotVal}${note}`, 800);
        }

        // Normalize pivot row
        const pivotValue = augmented[col][col];
        if (pivotValue !== 1) {
          if (useFractions || !useIntegerDivision(augmented[col], pivotValue)) {
            // Need to use fractions
            if (!useFractions) {
              addStep('Introducing Fractions', 'Division creates non-integer results. Switching to fraction arithmetic for exact calculations.', 1000);
              useFractions = true;
              convertToFractionMatrix(augmented);
            }
            
            addStep(`Column ${col + 1}: Normalize Pivot`,
              `Divide Row ${col + 1} by ${pivotValue} to make pivot = 1`, 1200);

            const pivotFraction = Fraction.from(pivotValue);
            for (let j = 0; j < 2 * n; j++) {
              augmented[col][j] = augmented[col][j].divide(pivotFraction);
            }
          } else {
            // Can use integer division
            addStep(`Column ${col + 1}: Normalize Pivot (Integer)`,
              `Divide Row ${col + 1} by ${pivotValue} (all results remain integers)`, 1200);

            for (let j = 0; j < 2 * n; j++) {
              augmented[col][j] = augmented[col][j] / pivotValue;
            }
          }

          const pivotCopy = deepCopyMatrix(augmented);
          setTimeout(() => {
            addVisualElement(displayAugmentedMatrix(pivotCopy, `[A | I] after normalizing pivot row`, useFractions));
          }, stepDelay);
        }

        // Eliminate other entries in this column
        for (let row = 0; row < n; row++) {
          if (row !== col) {
            const factor = augmented[row][col];
            if (factor !== 0) {
              if (useFractions) {
                const factorFraction = factor;
                addStep(`Column ${col + 1}: Eliminate Row ${row + 1}`,
                  `Row ${row + 1} = Row ${row + 1} - (${factorFraction.toString()}) √ó Row ${col + 1}`, 1000);

                for (let j = 0; j < 2 * n; j++) {
                  augmented[row][j] = augmented[row][j].subtract(factorFraction.multiply(augmented[col][j]));
                }
              } else {
                addStep(`Column ${col + 1}: Eliminate Row ${row + 1}`,
                  `Row ${row + 1} = Row ${row + 1} - (${factor}) √ó Row ${col + 1}`, 1000);

                for (let j = 0; j < 2 * n; j++) {
                  augmented[row][j] = augmented[row][j] - factor * augmented[col][j];
                }
              }

              const eliminationCopy = deepCopyMatrix(augmented);
              setTimeout(() => {
                addVisualElement(displayAugmentedMatrix(eliminationCopy, `[A | I] after eliminating row ${row + 1}`, useFractions));
              }, stepDelay);
            }
          }
        }

        addStep(`Column ${col + 1} Complete`,
          `Column ${col + 1} now has 1 at position [${col + 1},${col + 1}] and 0s elsewhere`, 800);
      }

      // Extract and display final inverse
      const inverse = [];
      for (let i = 0; i < n; i++) {
        inverse[i] = [];
        for (let j = 0; j < n; j++) {
          if (useFractions) {
            inverse[i][j] = augmented[i][n + j].toFloat();
          } else {
            inverse[i][j] = augmented[i][n + j];
          }
        }
      }

      setTimeout(() => {
        addVisualElement(displayMatrix(inverse, 'Final Inverse Matrix A‚Åª¬π'));

        // Cross-check with cofactor method
        setTimeout(() => {
          try {
            const inverseCofactor = calculateInverseCofactor(A);
            const cofactorMatches = true;
            for (let i = 0; i < n && cofactorMatches; i++) {
              for (let j = 0; j < n && cofactorMatches; j++) {
                if (Math.abs(inverse[i][j] - inverseCofactor[i][j]) > 1e-6) {
                  throw new Error('Mismatch detected');
                }
              }
            }

            if (cofactorMatches) {
              addStep('Cross-Check: Cofactor Method',
                '‚úì Verified: Result matches inverse calculated via cofactor method', 1200);
            }
          } catch (e) {
            addStep('Cross-Check: Cofactor Method',
              '‚úó Warning: Could not verify with cofactor method (likely singular or numerical issues)', 1200);
          }
        }, stepDelay + 500);

        setTimeout(() => {
          addTheoreticalExplanation('Gauss-Jordan Elimination with Integer-First Arithmetic',
            'This implementation prioritizes integer arithmetic to keep calculations simple and exact. Key features: (1) Integer-First Approach - uses integers as long as possible, only introducing fractions when necessary, (2) Smart Division Check - verifies if division will produce integer results before proceeding, (3) Step-by-Step Visualization - shows every row operation and matrix transformation, (4) Fraction Introduction - clearly marks when fractions become unavoidable. The algorithm transforms [A | I] into [I | A‚Åª¬π] through elementary row operations.');
        }, stepDelay + 1000);
      }, stepDelay + 1500);

      return inverse;
    }

    // Helper function to check if integer division is possible
    function useIntegerDivision(row, divisor) {
      for (let j = 0; j < row.length; j++) {
        if (row[j] % divisor !== 0) {
          return false;
        }
      }
      return true;
    }

    // Helper function to convert integer matrix to fraction matrix
    function convertToFractionMatrix(matrix) {
      for (let i = 0; i < matrix.length; i++) {
        for (let j = 0; j < matrix[i].length; j++) {
          matrix[i][j] = Fraction.from(matrix[i][j]);
        }
      }
    }

    // Display augmented matrix (handles both integer and fraction modes)
    function displayAugmentedMatrix(matrix, label = '', useFractions = false) {
      const div = document.createElement('div');
      div.className = 'matrix-display';

      if (label) {
        const labelDiv = document.createElement('div');
        labelDiv.style.marginBottom = '10px';
        labelDiv.style.fontWeight = '600';
        labelDiv.textContent = label;
        div.appendChild(labelDiv);
      }

      const n = matrix.length;

      matrix.forEach(row => {
        const rowDiv = document.createElement('div');
        rowDiv.className = 'matrix-row';

        // Left side: original matrix A
        for (let j = 0; j < n; j++) {
          const cell = document.createElement('div');
          cell.className = 'matrix-cell';
          const val = row[j];
          if (useFractions && val instanceof Fraction) {
            cell.textContent = val.toString();
          } else if (isNaN(val) || !isFinite(val)) {
            cell.textContent = '0';
          } else {
            cell.textContent = Number.isInteger(val) ? val : val.toFixed(2);
          }
          rowDiv.appendChild(cell);
        }

        // Vertical separator
        const separator = document.createElement('div');
        separator.className = 'matrix-cell matrix-separator';
        separator.textContent = '|';
        separator.style.fontWeight = 'bold';
        separator.style.color = '#667eea';
        rowDiv.appendChild(separator);

        // Right side: identity then inverse
        for (let j = n; j < 2 * n; j++) {
          const cell = document.createElement('div');
          cell.className = 'matrix-cell';
          const val = row[j];
          if (useFractions && val instanceof Fraction) {
            cell.textContent = val.toString();
          } else if (isNaN(val) || !isFinite(val)) {
            cell.textContent = '0';
          } else {
            cell.textContent = Number.isInteger(val) ? val : val.toFixed(2);
          }
          rowDiv.appendChild(cell);
        }

        div.appendChild(rowDiv);
      });

      return div;
    }

    // Display augmented matrix with fractions
    function displayAugmentedFractions(matrix, label = '') {
      const div = document.createElement('div');
      div.className = 'matrix-display';

      if (label) {
        const labelDiv = document.createElement('div');
        labelDiv.style.marginBottom = '10px';
        labelDiv.style.fontWeight = '600';
        labelDiv.textContent = label;
        div.appendChild(labelDiv);
      }

      const n = matrix.length;

      matrix.forEach(row => {
        const rowDiv = document.createElement('div');
        rowDiv.className = 'matrix-row';

        // Left side: original matrix A
        for (let j = 0; j < n; j++) {
          const cell = document.createElement('div');
          cell.className = 'matrix-cell';
          const val = row[j];
          if (val instanceof Fraction) {
            cell.textContent = val.toString();
          } else if (isNaN(val) || !isFinite(val)) {
            cell.textContent = '0';
          } else {
            cell.textContent = Number.isInteger(val) ? val : val.toFixed(2);
          }
          rowDiv.appendChild(cell);
        }

        // Vertical separator
        const separator = document.createElement('div');
        separator.className = 'matrix-cell matrix-separator';
        separator.textContent = '|';
        separator.style.fontWeight = 'bold';
        separator.style.color = '#667eea';
        rowDiv.appendChild(separator);

        // Right side: identity then inverse
        for (let j = n; j < 2 * n; j++) {
          const cell = document.createElement('div');
          cell.className = 'matrix-cell';
          const val = row[j];
          if (val instanceof Fraction) {
            cell.textContent = val.toString();
          } else if (isNaN(val) || !isFinite(val)) {
            cell.textContent = '0';
          } else {
            cell.textContent = Number.isInteger(val) ? val : val.toFixed(2);
          }
          rowDiv.appendChild(cell);
        }

        div.appendChild(rowDiv);
      });

      return div;
    }
    
    function highlightRow(matrixId, rowIndex) {
      const matrixDiv = document.getElementById(matrixId);
      if (!matrixDiv) return;
      
      const rows = matrixDiv.querySelectorAll('.matrix-row');
      rows.forEach((row, index) => {
        if (index === rowIndex) {
          row.classList.add('highlight-row');
        } else {
          row.classList.remove('highlight-row');
        }
      });
    }
    
    function highlightCol(matrixId, colIndex) {
      const matrixDiv = document.getElementById(matrixId);
      if (!matrixDiv) return;
      
      const rows = matrixDiv.querySelectorAll('.matrix-row');
      rows.forEach(row => {
        const cells = row.querySelectorAll('.matrix-cell');
        cells.forEach((cell, index) => {
          if (index === colIndex) {
            cell.classList.add('highlight-col');
          } else {
            cell.classList.remove('highlight-col');
          }
        });
      });
    }
    
    function highlightCell(matrixId, rowIndex, colIndex) {
      const matrixDiv = document.getElementById(matrixId);
      if (!matrixDiv) return;
      
      const rows = matrixDiv.querySelectorAll('.matrix-row');
      if (rows[rowIndex]) {
        const cells = rows[rowIndex].querySelectorAll('.matrix-cell');
        if (cells[colIndex]) {
          cells[colIndex].classList.add('highlight-cell');
          setTimeout(() => cells[colIndex].classList.remove('highlight-cell'), 800);
        }
      }
    }
    
    function highlightResultProcessing(matrixId, rowIndex, colIndex) {
      const matrixDiv = document.getElementById(matrixId);
      if (!matrixDiv) return;
      
      const rows = matrixDiv.querySelectorAll('.matrix-row');
      if (rows[rowIndex]) {
        const cells = rows[rowIndex].querySelectorAll('.matrix-cell');
        if (cells[colIndex]) {
          cells[colIndex].classList.add('highlight-processing');
        }
      }
    }
    
    function updateResultCell(matrixId, rowIndex, colIndex, value) {
      const matrixDiv = document.getElementById(matrixId);
      if (!matrixDiv) return;
      
      const rows = matrixDiv.querySelectorAll('.matrix-row');
      if (rows[rowIndex]) {
        const cells = rows[rowIndex].querySelectorAll('.matrix-cell');
        if (cells[colIndex]) {
          cells[colIndex].textContent = Number.isInteger(value) ? value : value.toFixed(2);
          cells[colIndex].classList.add('highlight');
          setTimeout(() => cells[colIndex].classList.remove('highlight'), 1000);
        }
      }
    }
    
    function clearHighlights() {
      document.querySelectorAll('.highlight, .highlight-row, .highlight-col, .highlight-cell, .highlight-processing').forEach(el => {
        el.classList.remove('highlight', 'highlight-row', 'highlight-col', 'highlight-cell', 'highlight-processing');
      });
    }
    
    function addVisualElement(element) {
      const container = document.getElementById('processContainer');
      container.appendChild(element);
      
      // Auto-scroll to keep the latest visual element visible
      setTimeout(() => {
        element.scrollIntoView({ behavior: 'smooth', block: 'end' });
      }, 100);
    }
    
    function getMinor(matrix, row, col) {
      return matrix
        .filter((_, i) => i !== row)
        .map(r => r.filter((_, j) => j !== col));
    }
    
    function calcDet(matrix) {
      const n = matrix.length;
      
      if (n === 1) return matrix[0][0];
      if (n === 2) return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0];
      
      let det = 0;
      for (let j = 0; j < n; j++) {
        det += Math.pow(-1, j) * matrix[0][j] * calcDet(getMinor(matrix, 0, j));
      }
      return det;
    }
    
    // Pure calculation functions (no UI)
    function addMatricesCalc(A, B) {
      if (A.length !== B.length || A[0].length !== B[0].length) {
        throw new Error('Matrices must have the same dimensions for addition');
      }
      
      const result = [];
      for (let i = 0; i < A.length; i++) {
        result[i] = [];
        for (let j = 0; j < A[0].length; j++) {
          result[i][j] = A[i][j] + B[i][j];
        }
      }
      return result;
    }
    
    function subtractMatricesCalc(A, B) {
      if (A.length !== B.length || A[0].length !== B[0].length) {
        throw new Error('Matrices must have the same dimensions for subtraction');
      }
      
      const result = [];
      for (let i = 0; i < A.length; i++) {
        result[i] = [];
        for (let j = 0; j < A[0].length; j++) {
          result[i][j] = A[i][j] - B[i][j];
        }
      }
      return result;
    }
    
    function multiplyMatricesCalc(A, B) {
      const rowsA = A.length;
      const colsA = A[0].length;
      const colsB = B[0].length;
      
      if (colsA !== B.length) {
        throw new Error('Number of columns in A must equal number of rows in B');
      }
      
      const result = Array(rowsA).fill().map(() => Array(colsB).fill(0));
      
      for (let i = 0; i < rowsA; i++) {
        for (let j = 0; j < colsB; j++) {
          for (let k = 0; k < colsA; k++) {
            result[i][j] += A[i][k] * B[k][j];
          }
        }
      }
      return result;
    }
    
    function scalarMultiplyCalc(A, scalar) {
      const result = [];
      for (let i = 0; i < A.length; i++) {
        result[i] = [];
        for (let j = 0; j < A[0].length; j++) {
          result[i][j] = scalar * A[i][j];
        }
      }
      return result;
    }
    
    function transposeMatrixCalc(A) {
      const result = [];
      for (let i = 0; i < A[0].length; i++) {
        result[i] = [];
        for (let j = 0; j < A.length; j++) {
          result[i][j] = A[j][i];
        }
      }
      return result;
    }
    
    // Fraction class for exact arithmetic
    class Fraction {
      constructor(num, den = 1) {
        if (den === 0) throw new Error('Denominator cannot be zero');
        const g = this.gcd(Math.abs(num), Math.abs(den));
        this.num = Math.sign(den) * (num / g);
        this.den = Math.abs(den) / g;
      }

      gcd(a, b) {
        return b === 0 ? a : this.gcd(b, a % b);
      }

      static from(val) {
        if (val instanceof Fraction) return val;
        if (Number.isInteger(val)) return new Fraction(val, 1);
        // Handle floating point by finding fraction representation
        const str = val.toString();
        if (str.includes('e') || str.includes('E')) {
          return new Fraction(val);
        }
        const decimalPlaces = (str.split('.')[1] || '').length;
        const multiplier = Math.pow(10, decimalPlaces);
        return new Fraction(Math.round(val * multiplier), multiplier);
      }

      add(other) {
        other = Fraction.from(other);
        return new Fraction(this.num * other.den + other.num * this.den, this.den * other.den);
      }

      subtract(other) {
        other = Fraction.from(other);
        return new Fraction(this.num * other.den - other.num * this.den, this.den * other.den);
      }

      multiply(other) {
        other = Fraction.from(other);
        return new Fraction(this.num * other.num, this.den * other.den);
      }

      divide(other) {
        other = Fraction.from(other);
        if (other.num === 0) throw new Error('Division by zero');
        return new Fraction(this.num * other.den, this.den * other.num);
      }

      isZero() {
        return this.num === 0;
      }

      isOne() {
        return this.num === this.den;
      }

      negate() {
        return new Fraction(-this.num, this.den);
      }

      toFloat() {
        return this.num / this.den;
      }

      toString() {
        if (this.den === 1) return `${this.num}`;
        if (this.num === 0) return '0';
        return `${this.num}/${this.den}`;
      }

      toLatex() {
        if (this.den === 1) return `${this.num}`;
        return `\\frac{${this.num}}{${this.den}}`;
      }
    }

    function calculateDeterminantCalc(A) {
      const n = A.length;

      if (n !== A[0].length) {
        throw new Error('Matrix must be square to calculate determinant');
      }

      return calcDet(A);
    }

    // Calculate determinant using cofactor expansion (for cross-checking)
    function calculateDeterminantCofactor(A) {
      const n = A.length;
      if (n === 1) return A[0][0];
      if (n === 2) return A[0][0] * A[1][1] - A[0][1] * A[1][0];

      let det = 0;
      for (let j = 0; j < n; j++) {
        det += Math.pow(-1, j) * A[0][j] * calculateDeterminantCofactor(getMinor(A, 0, j));
      }
      return det;
    }

    // Calculate inverse using cofactor method (for cross-checking)
    function calculateInverseCofactor(A) {
      const n = A.length;
      if (n !== A[0].length) {
        throw new Error('Matrix must be square to calculate inverse');
      }

      const det = calculateDeterminantCofactor(A);
      if (Math.abs(det) < 1e-10) {
        throw new Error('Matrix is singular and has no inverse');
      }

      if (n === 1) {
        return [[1 / A[0][0]]];
      }

      if (n === 2) {
        return [
          [A[1][1] / det, -A[0][1] / det],
          [-A[1][0] / det, A[0][0] / det]
        ];
      }

      const adjugate = [];
      for (let i = 0; i < n; i++) {
        adjugate[i] = [];
        for (let j = 0; j < n; j++) {
          const minor = getMinor(A, j, i);
          const cofactor = Math.pow(-1, i + j) * calculateDeterminantCofactor(minor);
          adjugate[i][j] = cofactor / det;
        }
      }

      return adjugate;
    }

    function calculateInverseCalc(A) {
      const n = A.length;

      if (n !== A[0].length) {
        throw new Error('Matrix must be square to calculate inverse');
      }

      // Create augmented matrix with Fractions [A | I]
      const augmented = Array(n).fill().map(() => Array(2 * n).fill(null));
      const rowSwaps = [];

      // Initialize with fractions
      for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
          augmented[i][j] = Fraction.from(A[i][j]);
        }
        // Identity matrix on right
        for (let j = 0; j < n; j++) {
          augmented[i][n + j] = Fraction.from(i === j ? 1 : 0);
        }
      }

      // Gauss-Jordan elimination with row swapping strategy
      for (let col = 0; col < n; col++) {
        // Find best pivot: prefer integer values, then non-zero
        let bestRow = col;
        let bestScore = -1;

        for (let row = col; row < n; row++) {
          const val = augmented[row][col];
          if (val.isZero()) continue;

          // Score: integer gets higher priority
          let score = Math.abs(val.toFloat());
          if (val.den === 1) score += 1000; // Strongly prefer integers

          if (score > bestScore) {
            bestScore = score;
            bestRow = row;
          }
        }

        // Check if we found a non-zero pivot
        if (augmented[bestRow][col].isZero()) {
          throw new Error('Matrix is singular and has no inverse');
        }

        // Swap rows if needed
        if (bestRow !== col) {
          [augmented[col], augmented[bestRow]] = [augmented[bestRow], augmented[col]];
          rowSwaps.push({ from: bestRow, to: col });
        }

        // Normalize pivot row to make pivot = 1
        const pivotValue = augmented[col][col];
        if (!pivotValue.isOne()) {
          for (let j = 0; j < 2 * n; j++) {
            augmented[col][j] = augmented[col][j].divide(pivotValue);
          }
        }

        // Eliminate other entries in this column
        for (let row = 0; row < n; row++) {
          if (row !== col) {
            const factor = augmented[row][col];
            if (!factor.isZero()) {
              for (let j = 0; j < 2 * n; j++) {
                augmented[row][j] = augmented[row][j].subtract(factor.multiply(augmented[col][j]));
              }
            }
          }
        }
      }

      // Extract inverse matrix and convert to floats
      const inverse = [];
      for (let i = 0; i < n; i++) {
        inverse[i] = [];
        for (let j = 0; j < n; j++) {
          inverse[i][j] = augmented[i][n + j].toFloat();
        }
      }

      // Store metadata for display
      inverse._rowSwaps = rowSwaps;

      return inverse;
    }
    
    function runVectorTests() {
      const resultDiv = document.getElementById('result');
      const container = document.getElementById('processContainer');
      
      resultDiv.style.display = 'block';
      container.innerHTML = '';
      
      const testResults = [];
      
      // Test Vector Addition
      testResults.push(testVectorAddition());
      
      // Test Vector Addition with W
      testResults.push(testVectorAdditionW());
      
      // Test Vector Subtraction
      testResults.push(testVectorSubtraction());
      
      // Test Vector Subtraction with W
      testResults.push(testVectorSubtractionW());
      
      // Test Scalar Multiplication
      testResults.push(testScalarMultiplication());
      
      // Test Scalar Multiplication with W
      testResults.push(testScalarMultiplicationW());
      
      // Test Vector Norm
      testResults.push(testVectorNorm());
      
      // Test Vector Norm with W
      testResults.push(testVectorNormW());
      
      // Test Distance Calculation
      testResults.push(testDistanceCalculation());
      
      // Test Vector Components
      testResults.push(testVectorComponents());
      
      // Display results
      displayTestResults(testResults);
    }
    
    function testVectorAddition() {
      // Set test inputs
      document.getElementById('u1').value = '3';
      document.getElementById('u2').value = '4';
      document.getElementById('u3').value = '5';
      document.getElementById('v1').value = '1';
      document.getElementById('v2').value = '2';
      document.getElementById('v3').value = '3';
      
      const u = getVector('u');
      const v = getVector('v');
      const expected = [4, 6, 8]; // 3+1, 4+2, 5+3
      const result = [u[0] + v[0], u[1] + v[1], u[2] + v[2]];
      
      const passed = arraysEqual(result, expected);
      return {
        name: 'Vector Addition (3,4,5) + (1,2,3)',
        passed: passed,
        expected: expected,
        actual: result
      };
    }
    
    function testVectorSubtraction() {
      // Set test inputs
      document.getElementById('u1').value = '5';
      document.getElementById('u2').value = '7';
      document.getElementById('u3').value = '9';
      document.getElementById('v1').value = '2';
      document.getElementById('v2').value = '3';
      document.getElementById('v3').value = '4';
      
      const u = getVector('u');
      const v = getVector('v');
      const expected = [3, 4, 5]; // 5-2, 7-3, 9-4
      const result = [u[0] - v[0], u[1] - v[1], u[2] - v[2]];
      
      const passed = arraysEqual(result, expected);
      return {
        name: 'Vector Subtraction (5,7,9) - (2,3,4)',
        passed: passed,
        expected: expected,
        actual: result
      };
    }
    
    function testScalarMultiplication() {
      // Set test inputs
      document.getElementById('u1').value = '2';
      document.getElementById('u2').value = '3';
      document.getElementById('u3').value = '4';
      document.getElementById('vectorScalar').value = '3';
      
      const u = getVector('u');
      const k = parseFloat(document.getElementById('vectorScalar').value);
      const expected = [6, 9, 12]; // 2*3, 3*3, 4*3
      const result = [k * u[0], k * u[1], k * u[2]];
      
      const passed = arraysEqual(result, expected);
      return {
        name: 'Scalar Multiplication 3 √ó (2,3,4)',
        passed: passed,
        expected: expected,
        actual: result
      };
    }
    
    function testVectorNorm() {
      // Set test inputs
      document.getElementById('u1').value = '3';
      document.getElementById('u2').value = '4';
      document.getElementById('u3').value = '0';
      
      const u = getVector('u');
      const expected = 5; // ‚àö(3¬≤ + 4¬≤ + 0¬≤) = ‚àö(9 + 16) = ‚àö25 = 5
      const result = Math.sqrt(u[0]*u[0] + u[1]*u[1] + u[2]*u[2]);
      
      const passed = Math.abs(result - expected) < 0.001;
      return {
        name: 'Vector Norm ||(3,4,0)||',
        passed: passed,
        expected: expected,
        actual: result
      };
    }
    
    function testDistanceCalculation() {
      // Set test inputs
      document.getElementById('p1x').value = '0';
      document.getElementById('p1y').value = '0';
      document.getElementById('p1z').value = '0';
      document.getElementById('p2x').value = '3';
      document.getElementById('p2y').value = '4';
      document.getElementById('p2z').value = '0';
      
      const p1 = getPoint('p1');
      const p2 = getPoint('p2');
      const diff = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];
      const expected = 5; // ‚àö((3-0)¬≤ + (4-0)¬≤ + (0-0)¬≤) = ‚àö(9 + 16) = ‚àö25 = 5
      const result = Math.sqrt(diff[0]*diff[0] + diff[1]*diff[1] + diff[2]*diff[2]);
      
      const passed = Math.abs(result - expected) < 0.001;
      return {
        name: 'Distance between (0,0,0) and (3,4,0)',
        passed: passed,
        expected: expected,
        actual: result
      };
    }
    
    function testVectorComponents() {
      // Set test inputs
      document.getElementById('p1x').value = '1';
      document.getElementById('p1y').value = '2';
      document.getElementById('p1z').value = '3';
      document.getElementById('p2x').value = '4';
      document.getElementById('p2y').value = '6';
      document.getElementById('p2z').value = '8';
      
      const p1 = getPoint('p1');
      const p2 = getPoint('p2');
      const expected = [3, 4, 5]; // 4-1, 6-2, 8-3
      const result = [p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2]];
      
      const passed = arraysEqual(result, expected);
      return {
        name: 'Vector Components (1,2,3) ‚Üí (4,6,8)',
        passed: passed,
        expected: expected,
        actual: result
      };
    }
    
    function testVectorAdditionW() {
      // Set test inputs
      document.getElementById('u1').value = '1';
      document.getElementById('u2').value = '2';
      document.getElementById('u3').value = '3';
      document.getElementById('w1').value = '4';
      document.getElementById('w2').value = '5';
      document.getElementById('w3').value = '6';
      
      const u = getVector('u');
      const w = getVector('w');
      const expected = [5, 7, 9]; // 1+4, 2+5, 3+6
      const result = [u[0] + w[0], u[1] + w[1], u[2] + w[2]];
      
      const passed = arraysEqual(result, expected);
      return {
        name: 'Vector Addition W (1,2,3) + (4,5,6)',
        passed: passed,
        expected: expected,
        actual: result
      };
    }
    
    function testVectorSubtractionW() {
      // Set test inputs
      document.getElementById('u1').value = '7';
      document.getElementById('u2').value = '8';
      document.getElementById('u3').value = '9';
      document.getElementById('w1').value = '2';
      document.getElementById('w2').value = '3';
      document.getElementById('w3').value = '4';
      
      const u = getVector('u');
      const w = getVector('w');
      const expected = [5, 5, 5]; // 7-2, 8-3, 9-4
      const result = [u[0] - w[0], u[1] - w[1], u[2] - w[2]];
      
      const passed = arraysEqual(result, expected);
      return {
        name: 'Vector Subtraction W (7,8,9) - (2,3,4)',
        passed: passed,
        expected: expected,
        actual: result
      };
    }
    
    function testScalarMultiplicationW() {
      // Set test inputs
      document.getElementById('w1').value = '2';
      document.getElementById('w2').value = '4';
      document.getElementById('w3').value = '6';
      document.getElementById('vectorScalar').value = '2';
      
      const w = getVector('w');
      const k = parseFloat(document.getElementById('vectorScalar').value);
      const expected = [4, 8, 12]; // 2*2, 4*2, 6*2
      const result = [k * w[0], k * w[1], k * w[2]];
      
      const passed = arraysEqual(result, expected);
      return {
        name: 'Scalar Multiplication W 2 √ó (2,4,6)',
        passed: passed,
        expected: expected,
        actual: result
      };
    }
    
    function testVectorNormW() {
      // Set test inputs
      document.getElementById('w1').value = '6';
      document.getElementById('w2').value = '8';
      document.getElementById('w3').value = '0';
      
      const w = getVector('w');
      const expected = 10; // ‚àö(6¬≤ + 8¬≤ + 0¬≤) = ‚àö(36 + 64) = ‚àö100 = 10
      const result = Math.sqrt(w[0]*w[0] + w[1]*w[1] + w[2]*w[2]);
      
      const passed = Math.abs(result - expected) < 0.001;
      return {
        name: 'Vector Norm W ||(6,8,0)||',
        passed: passed,
        expected: expected,
        actual: result
      };
    }
    
    function arraysEqual(a, b) {
      if (a.length !== b.length) return false;
      for (let i = 0; i < a.length; i++) {
        if (Math.abs(a[i] - b[i]) > 0.001) return false;
      }
      return true;
    }
    
    function displayTestResults(results) {
      const container = document.getElementById('processContainer');
      
      const resultsDiv = document.createElement('div');
      resultsDiv.className = 'test-results';
      
      const header = document.createElement('h3');
      header.textContent = 'Vector Operation Tests';
      header.style.color = '#28a745';
      header.style.marginBottom = '20px';
      resultsDiv.appendChild(header);
      
      let passedCount = 0;
      results.forEach(result => {
        if (result.passed) passedCount++;
        
        const testDiv = document.createElement('div');
        testDiv.className = `test-result ${result.passed ? 'test-pass' : 'test-fail'}`;
        
        const nameSpan = document.createElement('span');
        nameSpan.className = 'test-name';
        nameSpan.textContent = result.name;
        
        const statusSpan = document.createElement('span');
        statusSpan.className = 'test-status';
        statusSpan.textContent = result.passed ? 'PASS' : 'FAIL';
        
        testDiv.appendChild(nameSpan);
        testDiv.appendChild(statusSpan);
        
        if (!result.passed) {
          const detailsDiv = document.createElement('div');
          detailsDiv.style.marginTop = '8px';
          detailsDiv.style.fontSize = '14px';
          detailsDiv.innerHTML = `Expected: [${result.expected.join(', ')}]<br>Actual: [${Array.isArray(result.actual) ? result.actual.map(x => typeof x === 'number' ? x.toFixed(3) : x).join(', ') : result.actual.toFixed(3)}]`;
          testDiv.appendChild(detailsDiv);
        }
        
        resultsDiv.appendChild(testDiv);
      });
      
      const summaryDiv = document.createElement('div');
      summaryDiv.style.marginTop = '20px';
      summaryDiv.style.padding = '15px';
      summaryDiv.style.background = passedCount === results.length ? '#d4edda' : '#f8d7da';
      summaryDiv.style.borderRadius = '8px';
      summaryDiv.style.textAlign = 'center';
      summaryDiv.style.fontWeight = '600';
      summaryDiv.innerHTML = `Tests Passed: ${passedCount}/${results.length}`;
      resultsDiv.appendChild(summaryDiv);
      
      container.appendChild(resultsDiv);
    }
    
    // Matrix Test Functions
    function runMatrixTests() {
      const resultDiv = document.getElementById('result');
      const container = document.getElementById('processContainer');
      
      resultDiv.style.display = 'block';
      container.innerHTML = '';
      
      const testResults = [];
      
      // Matrix Addition Tests
      testResults.push(testMatrixAddition2x2());
      testResults.push(testMatrixAddition3x3());
      testResults.push(testMatrixAdditionCommutativity());
      
      // Matrix Subtraction Tests
      testResults.push(testMatrixSubtraction2x2());
      testResults.push(testMatrixSubtraction3x3());
      
      // Scalar Multiplication Tests
      testResults.push(testScalarMultiplication2x2());
      testResults.push(testScalarMultiplication3x3());
      testResults.push(testScalarDistributivity());
      
      // Matrix Multiplication Tests
      testResults.push(testMatrixMultiplication2x2());
      testResults.push(testMatrixMultiplication2x3_3x2());
      testResults.push(testMatrixMultiplicationIdentity());
      
      // Matrix Transpose Tests
      testResults.push(testMatrixTranspose2x3());
      testResults.push(testMatrixTransposeDouble());
      testResults.push(testMatrixTransposeSum());
      
      // Determinant Tests
      testResults.push(testDeterminant2x2());
      testResults.push(testDeterminant3x3());
      testResults.push(testDeterminantIdentity());
      
      // Matrix Inverse Tests
      testResults.push(testMatrixInverse2x2());
      testResults.push(testMatrixInverseIdentity());
      testResults.push(testMatrixInverseProperty());
      
      // Display results
      displayMatrixTestResults(testResults);
    }
    
    function testMatrixAddition2x2() {
      const A = [[1, 2], [3, 4]];
      const B = [[5, 6], [7, 8]];
      const result = addMatricesCalc(A, B);
      const expected = [[6, 8], [10, 12]];
      const passed = matricesEqual(result, expected);
      return {
        name: 'Matrix Addition 2x2 + 2x2',
        passed: passed,
        expected: expected,
        actual: result
      };
    }
    
    function testMatrixAddition3x3() {
      const A = [[1, 0, 2], [3, 2, 1], [4, 0, 3]];
      const B = [[1, 1, 3], [4, 2, 1], [3, 2, 0]];
      const result = addMatricesCalc(A, B);
      const expected = [[2, 1, 5], [7, 4, 2], [7, 2, 3]];
      const passed = matricesEqual(result, expected);
      return {
        name: 'Matrix Addition 3x3 + 3x3',
        passed: passed,
        expected: expected,
        actual: result
      };
    }
    
    function testMatrixAdditionCommutativity() {
      const A = [[1, 2], [3, 4]];
      const B = [[5, 6], [7, 8]];
      const AB = addMatricesCalc(A, B);
      const BA = addMatricesCalc(B, A);
      const passed = matricesEqual(AB, BA);
      return {
        name: 'Matrix Addition Commutativity: A + B = B + A',
        passed: passed,
        expected: 'Equal matrices',
        actual: passed ? 'Equal' : 'Not equal'
      };
    }
    
    function testMatrixSubtraction2x2() {
      const A = [[5, 6], [7, 8]];
      const B = [[1, 2], [3, 4]];
      const result = subtractMatricesCalc(A, B);
      const expected = [[4, 4], [4, 4]];
      const passed = matricesEqual(result, expected);
      return {
        name: 'Matrix Subtraction 2x2 - 2x2',
        passed: passed,
        expected: expected,
        actual: result
      };
    }
    
    function testMatrixSubtraction3x3() {
      const A = [[1, 0, 2], [3, 2, 1], [4, 0, 3]];
      const B = [[1, 1, 3], [4, 2, 1], [3, 2, 0]];
      const result = subtractMatricesCalc(A, B);
      const expected = [[0, -1, -1], [-1, 0, 0], [1, -2, 3]];
      const passed = matricesEqual(result, expected);
      return {
        name: 'Matrix Subtraction 3x3 - 3x3',
        passed: passed,
        expected: expected,
        actual: result
      };
    }
    
    function testScalarMultiplication2x2() {
      const A = [[1, 2], [3, 4]];
      const result = scalarMultiplyCalc(A, 3);
      const expected = [[3, 6], [9, 12]];
      const passed = matricesEqual(result, expected);
      return {
        name: 'Scalar Multiplication 2x2 √ó 3',
        passed: passed,
        expected: expected,
        actual: result
      };
    }
    
    function testScalarMultiplication3x3() {
      const A = [[1, 0, 2], [3, 2, 1], [4, 0, 3]];
      const result = scalarMultiplyCalc(A, -2);
      const expected = [[-2, 0, -4], [-6, -4, -2], [-8, 0, -6]];
      const passed = matricesEqual(result, expected);
      return {
        name: 'Scalar Multiplication 3x3 √ó (-2)',
        passed: passed,
        expected: expected,
        actual: result
      };
    }
    
    function testScalarDistributivity() {
      const A = [[1, 2], [3, 4]];
      const B = [[5, 6], [7, 8]];
      const k = 3;
      const left = scalarMultiplyCalc(addMatricesCalc(A, B), k);
      const right = addMatricesCalc(scalarMultiplyCalc(A, k), scalarMultiplyCalc(B, k));
      const passed = matricesEqual(left, right);
      return {
        name: 'Scalar Distributivity: k(A + B) = kA + kB',
        passed: passed,
        expected: 'Equal matrices',
        actual: passed ? 'Equal' : 'Not equal'
      };
    }
    
    function testMatrixMultiplication2x2() {
      const A = [[1, 2], [3, 4]];
      const B = [[5, 6], [7, 8]];
      const result = multiplyMatricesCalc(A, B);
      const expected = [[19, 22], [43, 50]];
      const passed = matricesEqual(result, expected);
      return {
        name: 'Matrix Multiplication 2x2 √ó 2x2',
        passed: passed,
        expected: expected,
        actual: result
      };
    }
    
    function testMatrixMultiplication2x3_3x2() {
      const A = [[1, 2, 3], [4, 5, 6]];
      const B = [[7, 8], [9, 10], [11, 12]];
      const result = multiplyMatricesCalc(A, B);
      const expected = [[58, 64], [139, 154]];
      const passed = matricesEqual(result, expected);
      return {
        name: 'Matrix Multiplication 2x3 √ó 3x2',
        passed: passed,
        expected: expected,
        actual: result
      };
    }
    
    function testMatrixMultiplicationIdentity() {
      const A = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];
      const I = [[1, 0, 0], [0, 1, 0], [0, 0, 1]];
      const result = multiplyMatricesCalc(A, I);
      const passed = matricesEqual(result, A);
      return {
        name: 'Matrix Multiplication Identity: A √ó I = A',
        passed: passed,
        expected: 'Equal to original matrix',
        actual: passed ? 'Equal' : 'Not equal'
      };
    }
    
    function testMatrixTranspose2x3() {
      const A = [[1, 2, 3], [4, 5, 6]];
      const result = transposeMatrixCalc(A);
      const expected = [[1, 4], [2, 5], [3, 6]];
      const passed = matricesEqual(result, expected);
      return {
        name: 'Matrix Transpose 2x3 to 3x2',
        passed: passed,
        expected: expected,
        actual: result
      };
    }
    
    function testMatrixTransposeDouble() {
      const A = [[1, 2, 3], [4, 5, 6]];
      const result = transposeMatrixCalc(transposeMatrixCalc(A));
      const passed = matricesEqual(result, A);
      return {
        name: 'Matrix Transpose Double: (A^T)^T = A',
        passed: passed,
        expected: 'Equal to original matrix',
        actual: passed ? 'Equal' : 'Not equal'
      };
    }
    
    function testMatrixTransposeSum() {
      const A = [[1, 2], [3, 4]];
      const B = [[5, 6], [7, 8]];
      const left = transposeMatrixCalc(addMatricesCalc(A, B));
      const right = addMatricesCalc(transposeMatrixCalc(A), transposeMatrixCalc(B));
      const passed = matricesEqual(left, right);
      return {
        name: 'Matrix Transpose of Sum: (A + B)^T = A^T + B^T',
        passed: passed,
        expected: 'Equal matrices',
        actual: passed ? 'Equal' : 'Not equal'
      };
    }
    
    function testDeterminant2x2() {
      const A = [[1, 2], [3, 4]];
      const result = calcDet(A);
      const expected = -2; // 1*4 - 2*3 = 4 - 6 = -2
      const passed = Math.abs(result - expected) < 1e-10;
      return {
        name: 'Determinant 2x2 Matrix',
        passed: passed,
        expected: expected,
        actual: result
      };
    }
    
    function testDeterminant3x3() {
      const A = [[1, 0, 2], [3, 2, 1], [4, 0, 3]];
      const result = calcDet(A);
      const expected = -10; // 1*(2*3-1*0) - 0*(3*3-1*4) + 2*(3*0-2*4) = 6 + 0 - 16 = -10
      const passed = Math.abs(result - expected) < 1e-10;
      return {
        name: 'Determinant 3x3 Matrix',
        passed: passed,
        expected: expected,
        actual: result
      };
    }
    
    function testDeterminantIdentity() {
      const I = [[1, 0, 0], [0, 1, 0], [0, 0, 1]];
      const result = calcDet(I);
      const passed = Math.abs(result - 1) < 1e-10;
      return {
        name: 'Determinant Identity Matrix = 1',
        passed: passed,
        expected: 1,
        actual: result
      };
    }
    
    function testMatrixInverse2x2() {
      const A = [[1, 2], [3, 4]];
      const result = calculateInverseCalc(A);
      const expected = [[-2, 1], [1.5, -0.5]]; // (1/(1*4-2*3)) * [4, -2; -3, 1] = (1/-2) * [4, -2; -3, 1] = [-2, 1; 1.5, -0.5]
      const passed = matricesEqual(result, expected);
      return {
        name: 'Matrix Inverse 2x2',
        passed: passed,
        expected: expected,
        actual: result
      };
    }
    
    function testMatrixInverseIdentity() {
      const I = [[1, 0], [0, 1]];
      const result = calculateInverseCalc(I);
      const passed = matricesEqual(result, I);
      return {
        name: 'Matrix Inverse Identity = Itself',
        passed: passed,
        expected: 'Equal to identity',
        actual: passed ? 'Equal' : 'Not equal'
      };
    }
    
    function testMatrixInverseProperty() {
      const A = [[2, 1], [1, 1]];
      const A_inv = calculateInverseCalc(A);
      const product = multiplyMatricesCalc(A, A_inv);
      const I = [[1, 0], [0, 1]];
      const passed = matricesEqual(product, I, 1e-8); // Allow for small floating point errors
      return {
        name: 'Matrix Inverse Property: A √ó A‚Åª¬π = I',
        passed: passed,
        expected: 'Equal to identity matrix',
        actual: passed ? 'Equal' : 'Not equal'
      };
    }
    
    function matricesEqual(A, B, tolerance = 1e-10) {
      if (A.length !== B.length || A[0].length !== B[0].length) return false;
      for (let i = 0; i < A.length; i++) {
        for (let j = 0; j < A[0].length; j++) {
          if (Math.abs(A[i][j] - B[i][j]) > tolerance) return false;
        }
      }
      return true;
    }
    
    function displayMatrixTestResults(results) {
      const resultContent = document.getElementById('processContainer');
      
      const resultsDiv = document.createElement('div');
      resultsDiv.className = 'test-results';
      
      const header = document.createElement('h3');
      header.textContent = 'Matrix Operation Tests';
      header.style.color = '#667eea';
      header.style.marginBottom = '20px';
      resultsDiv.appendChild(header);
      
      let passedCount = 0;
      results.forEach(result => {
        if (result.passed) passedCount++;
        
        const testDiv = document.createElement('div');
        testDiv.className = `test-result ${result.passed ? 'test-pass' : 'test-fail'}`;
        
        const nameSpan = document.createElement('span');
        nameSpan.className = 'test-name';
        nameSpan.textContent = result.name;
        
        const statusSpan = document.createElement('span');
        statusSpan.className = 'test-status';
        statusSpan.textContent = result.passed ? 'PASS' : 'FAIL';
        
        testDiv.appendChild(nameSpan);
        testDiv.appendChild(statusSpan);
        
        if (!result.passed) {
          const detailsDiv = document.createElement('div');
          detailsDiv.style.marginTop = '8px';
          detailsDiv.style.fontSize = '14px';
          if (Array.isArray(result.expected) && Array.isArray(result.expected[0])) {
            // Matrix display
            detailsDiv.innerHTML = `Expected:<br>${displayMatrix(result.expected).outerHTML}<br>Actual:<br>${displayMatrix(result.actual).outerHTML}`;
          } else {
            detailsDiv.innerHTML = `Expected: ${Array.isArray(result.expected) ? '[' + result.expected.map(row => '[' + row.join(', ') + ']').join('; ') + ']' : result.expected}<br>Actual: ${Array.isArray(result.actual) ? '[' + result.actual.map(row => '[' + row.join(', ') + ']').join('; ') + ']' : result.actual}`;
          }
          testDiv.appendChild(detailsDiv);
        }
        
        resultsDiv.appendChild(testDiv);
      });
      
      const summaryDiv = document.createElement('div');
      summaryDiv.style.marginTop = '20px';
      summaryDiv.style.padding = '15px';
      summaryDiv.style.background = passedCount === results.length ? '#d4edda' : '#f8d7da';
      summaryDiv.style.borderRadius = '8px';
      summaryDiv.style.textAlign = 'center';
      summaryDiv.style.fontWeight = '600';
      summaryDiv.innerHTML = `Tests Passed: ${passedCount}/${results.length}`;
      resultsDiv.appendChild(summaryDiv);
      
      resultContent.appendChild(resultsDiv);
    }
    
    updateMatrices();
  </script>
</body>
</html>