<!-- ********************************************************************** -->
<!--                                                                        -->
<!--  matrix-calculator.html                            TTTTTTTT SSSSSSS II -->
<!--                                                       TT    SS      II -->
<!--  By: st93642@students.tsi.lv                          TT    SSSSSSS II -->
<!--                                                       TT         SS II -->
<!--  Created: Oct 28 2025 18:46 st93642                   TT    SSSSSSS II -->
<!--  Updated: Nov 17 2025 11:03 st93642                                    -->
<!--                                                                        -->
<!--   Transport and Telecommunication Institute - Riga, Latvia             -->
<!--                       https://tsi.lv                                   -->
<!-- ********************************************************************** -->

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Matrix Calculator</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }
    
    .container {
      max-width: 1600px;
      margin: 0 auto;
      background: white;
      border-radius: 20px;
      padding: 30px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
    }
    
    h1 {
      text-align: center;
      color: #667eea;
      margin-bottom: 30px;
      font-size: 2.5em;
    }
    
    .tab-content {
      display: none;
    }
    
    .tab-content.active {
      display: block;
    }
    
    .controls {
      display: flex;
      gap: 20px;
      margin-bottom: 30px;
      flex-wrap: wrap;
    }
    
    .control-group {
      flex: 1;
      min-width: 200px;
    }
    
    label {
      display: block;
      margin-bottom: 5px;
      color: #555;
      font-weight: 600;
    }
    
    select, input {
      width: 100%;
      padding: 10px;
      border: 2px solid #e0e0e0;
      border-radius: 8px;
      font-size: 16px;
      transition: border-color 0.3s;
    }
    
    select:focus, input:focus {
      outline: none;
      border-color: #667eea;
    }
    
    .matrices-container {
      display: flex;
      gap: 30px;
      margin-bottom: 30px;
      flex-wrap: wrap;
    }
    
    .matrix-section {
      flex: 1;
      min-width: 250px;
    }
    
    .matrix-section h3 {
      color: #764ba2;
      margin-bottom: 15px;
    }
    
    .matrix-grid {
      display: inline-grid;
      gap: 8px;
      padding: 20px;
      background: #f8f9fa;
      border-radius: 12px;
      border: 3px solid #667eea;
    }
    
    .matrix-grid input {
      width: 70px;
      height: 50px;
      text-align: center;
      font-size: 14px;
      font-weight: 600;
      border: 2px solid #ddd;
      font-family: 'Courier New', monospace;
    }
    
    .buttons {
      display: flex;
      gap: 15px;
      flex-wrap: wrap;
      margin-bottom: 30px;
    }
    
    button {
      flex: 1;
      min-width: 120px;
      padding: 15px 25px;
      font-size: 16px;
      font-weight: 600;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.3s;
      color: white;
    }
    
    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
    }
    
    .btn-multiply { background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); }
    .btn-determinant { background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%); }
    .btn-inverse { background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%); }
    
    .result-section {
      margin-top: 30px;
      padding: 25px;
      background: #f8f9fa;
      border-radius: 12px;
      border-left: 5px solid #667eea;
      overflow-x: auto;
    }
    
    .result-left, .result-right {
      min-width: 0;
      box-sizing: border-box;
      max-height: 70vh;
      overflow-y: auto;
      padding-right: 10px;
    }
    
    .result-left h3, .result-right h3 {
      color: #764ba2;
      margin-bottom: 20px;
    }
    
    .steps {
      max-height: 60vh;
      overflow-y: auto;
      padding-right: 10px;
    }
    

    
    .step {
      padding: 15px;
      margin-bottom: 15px;
      background: white;
      border-radius: 8px;
      border-left: 4px solid #667eea;
      animation: slideIn 0.5s ease-out;
      opacity: 0;
      animation-fill-mode: forwards;
    }
    
    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateX(-20px);
      }
      to {
        opacity: 1;
        transform: translateX(0);
      }
    }
    
    .step-title {
      font-weight: 600;
      color: #667eea;
      margin-bottom: 8px;
    }
    
    .step-content {
      color: #555;
      font-family: 'Courier New', monospace;
      line-height: 1.6;
    }
    
    .matrix-display {
      display: inline-block;
      margin: 10px 0;
      padding: 15px;
      background: white;
      border-radius: 8px;
      border: 2px solid #667eea;
      max-width: 100%;
      overflow-x: auto;
    }
    
    .matrix-row {
      display: flex;
      gap: 12px;
      justify-content: center;
    }
    
    .matrix-cell {
      width: 120px;
      min-width: 120px;
      max-width: 180px;
      height: auto;
      min-height: 45px;
      padding: 8px 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      color: #333;
      background: #f0f0f0;
      border-radius: 5px;
      transition: all 0.3s ease;
      font-size: 14px;
      word-wrap: break-word;
      overflow-wrap: break-word;
      text-align: center;
      line-height: 1.3;
    }
    
    .matrix-separator {
      width: 20px !important;
      background: transparent !important;
      border: none !important;
      padding: 0 !important;
    }
    
    .highlight {
      background: #ffe066 !important;
      animation: pulse 0.5s ease-in-out;
      transform: scale(1.15);
      box-shadow: 0 0 15px rgba(255, 224, 102, 0.8);
    }
    
    .highlight-row {
      background: #a8e6cf !important;
      transform: scale(1.1);
    }
    
    .highlight-col {
      background: #ffd3b6 !important;
      transform: scale(1.1);
    }
    
    .highlight-cell {
      background: #ff8c69 !important;
      transform: scale(1.3);
      animation: pulse-cell 0.6s ease-in-out;
      box-shadow: 0 0 15px rgba(255, 140, 105, 0.8);
      z-index: 10;
      position: relative;
    }
    
    @keyframes pulse-cell {
      0%, 100% { transform: scale(1.3); }
      50% { transform: scale(1.5); }
    }
    
    .highlight-processing {
      background: #ff6b6b !important;
      animation: pulse 0.8s ease-in-out infinite;
      transform: scale(1.2);
      box-shadow: 0 0 20px rgba(255, 107, 107, 0.9);
      border: 2px solid #ff4757;
    }
    
    @keyframes pulse {
      0%, 100% { transform: scale(1.15); }
      50% { transform: scale(1.25); }
    }
    
    .formula-display {
      font-size: 18px;
      padding: 15px;
      background: linear-gradient(135deg, #667eea20 0%, #764ba220 100%);
      border-radius: 8px;
      margin: 15px 0;
      font-family: 'Courier New', monospace;
      font-weight: 600;
      color: #764ba2;
      text-align: center;
      border: 2px solid #667eea;
    }
    
    .visual-calculation {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 20px;
      margin: 20px 0;
      flex-wrap: wrap;
      max-width: 100%;
      overflow-x: auto;
    }
    
    .calc-arrow {
      font-size: 30px;
      color: #667eea;
      animation: bounce 1s infinite;
    }
    
    @keyframes bounce {
      0%, 100% { transform: translateX(0); }
      50% { transform: translateX(10px); }
    }
    
    .error {
      color: #f5576c;
      padding: 15px;
      background: #ffe0e0;
      border-radius: 8px;
      margin-top: 10px;
    }
    
    .theoretical-explanation {
      background: linear-gradient(135deg, #e8f4fd 0%, #d1e7f0 100%);
      border-left-color: #4a90e2;
    }
    
    .theoretical-content {
      font-style: italic;
      color: #2c5282;
      line-height: 1.6;
    }
    
    .test-section {
      margin-top: 20px;
      padding: 20px;
      background: #f8f9fa;
      border-radius: 12px;
      border-left: 5px solid #28a745;
    }
    
    .test-result {
      margin-bottom: 15px;
      padding: 10px;
      border-radius: 8px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .test-pass {
      background: #d4edda;
      border-left: 4px solid #28a745;
    }
    
    .test-fail {
      background: #f8d7da;
      border-left: 4px solid #dc3545;
    }
    
    .test-name {
      font-weight: 600;
    }
    
    .test-status {
      font-weight: 600;
      padding: 4px 8px;
      border-radius: 4px;
    }
    
    .test-pass .test-status {
      background: #28a745;
      color: white;
    }
    
    .test-fail .test-status {
      background: #dc3545;
      color: white;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üßÆ Matrix Calculator</h1>
    <div style="background: #e7f3ff; padding: 15px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid #2196F3;">
      <strong>üí° Symbolic Support:</strong> Enter numbers (e.g., <code>5</code>, <code>1.5</code>) or symbolic expressions (e.g., <code>x</code>, <code>2x+1</code>, <code>x^2-1</code>, <code>x*y</code>). 
      Operations work with both! Try the symbolic algebra tests to see examples.
    </div>
    
    <!-- Matrix Operations -->
    <div id="matrix-tab" class="tab-content active">
      <div class="controls">
        <div class="control-group">
          <label>Matrix A Size:</label>
          <select id="sizeA" onchange="updateMatrices()">
            <option value="1x1">1√ó1</option>
            <option value="1x2">1√ó2</option>
            <option value="1x3">1√ó3</option>
            <option value="1x4">1√ó4</option>
            <option value="1x5">1√ó5</option>
            <option value="2x1">2√ó1</option>
            <option value="2x2">2√ó2</option>
            <option value="2x3">2√ó3</option>
            <option value="2x4">2√ó4</option>
            <option value="2x5">2√ó5</option>
            <option value="3x1">3√ó1</option>
            <option value="3x2">3√ó2</option>
            <option value="3x3" selected>3√ó3</option>
            <option value="3x4">3√ó4</option>
            <option value="3x5">3√ó5</option>
            <option value="4x1">4√ó1</option>
            <option value="4x2">4√ó2</option>
            <option value="4x3">4√ó3</option>
            <option value="4x4">4√ó4</option>
            <option value="4x5">4√ó5</option>
            <option value="5x1">5√ó1</option>
            <option value="5x2">5√ó2</option>
            <option value="5x3">5√ó3</option>
            <option value="5x4">5√ó4</option>
            <option value="5x5">5√ó5</option>
          </select>
        </div>
        <div class="control-group">
          <label>Matrix B Size:</label>
          <select id="sizeB" onchange="updateMatrices()">
            <option value="1x1">1√ó1</option>
            <option value="1x2">1√ó2</option>
            <option value="1x3">1√ó3</option>
            <option value="1x4">1√ó4</option>
            <option value="1x5">1√ó5</option>
            <option value="2x1">2√ó1</option>
            <option value="2x2">2√ó2</option>
            <option value="2x3">2√ó3</option>
            <option value="2x4">2√ó4</option>
            <option value="2x5">2√ó5</option>
            <option value="3x1">3√ó1</option>
            <option value="3x2">3√ó2</option>
            <option value="3x3" selected>3√ó3</option>
            <option value="3x4">3√ó4</option>
            <option value="3x5">3√ó5</option>
            <option value="4x1">4√ó1</option>
            <option value="4x2">4√ó2</option>
            <option value="4x3">4√ó3</option>
            <option value="4x4">4√ó4</option>
            <option value="4x5">4√ó5</option>
            <option value="5x1">5√ó1</option>
            <option value="5x2">5√ó2</option>
            <option value="5x3">5√ó3</option>
            <option value="5x4">5√ó4</option>
            <option value="5x5">5√ó5</option>
          </select>
        </div>
      </div>
      
      <div class="matrices-container">
        <div class="matrix-section">
          <h3>Matrix A</h3>
          <div class="matrix-grid" id="matrixA"></div>
        </div>
        <div class="matrix-section">
          <h3>Matrix B</h3>
          <div class="matrix-grid" id="matrixB"></div>
        </div>
      </div>
      
      <div class="buttons">
        <button class="btn-multiply" onclick="calculate('multiply')">‚úñÔ∏è Multiply A √ó B</button>
        <button class="btn-determinant" onclick="calculate('determinant')">üìä Det(A)</button>
        <button class="btn-inverse" onclick="calculate('inverse')">üîÑ‚Åª¬π Inverse A‚Åª¬π</button>
        <button class="btn-test" onclick="runSymbolicTests()" style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);">üß™ Test Symbolic Algebra</button>
      </div>
    </div>
    
    <div class="result-section" id="result" style="display: none;">
      <div class="row">
        <div class="col-12">
          <h3>Step-by-Step Process</h3>
          <div id="processContainer"></div>
        </div>
      </div>
    </div>
  </div>
  
  <script>
    let stepDelay = 0;

    function updateMatrices() {
      const sizeA = document.getElementById('sizeA').value.split('x');
      const sizeB = document.getElementById('sizeB').value.split('x');
      
      createMatrixInputs('matrixA', parseInt(sizeA[0]), parseInt(sizeA[1]));
      createMatrixInputs('matrixB', parseInt(sizeB[0]), parseInt(sizeB[1]));
      
      document.getElementById('result').style.display = 'none';
    }
    
    function createMatrixInputs(id, rows, cols) {
      const container = document.getElementById(id);
      container.innerHTML = '';
      container.style.gridTemplateColumns = `repeat(${cols}, 70px)`;
      
      for (let i = 0; i < rows * cols; i++) {
        const input = document.createElement('input');
        input.type = 'text';  // Changed to text to support symbolic expressions
        input.value = Math.floor(Math.random() * 10);
        input.placeholder = 'x, 2x, ...';
        input.style.fontSize = '14px';
        container.appendChild(input);
      }
    }
    
    function getMatrix(id) {
      const sizeStr = id === 'matrixA' ? 
        document.getElementById('sizeA').value :
        document.getElementById('sizeB').value;
      
      const size = sizeStr.split('x');
      const rows = parseInt(size[0]);
      const cols = parseInt(size[1]);
      
      const inputs = document.getElementById(id).getElementsByTagName('input');
      const matrix = [];
      
      for (let i = 0; i < rows; i++) {
        matrix[i] = [];
        for (let j = 0; j < cols; j++) {
          const inputValue = inputs[i * cols + j].value.trim();
          
          // Try to parse as symbolic expression first
          try {
            // Check if it contains variables or operators (symbolic)
            if (/[a-zA-Z+\-*/^()]/.test(inputValue) && !/^-?[0-9.]+$/.test(inputValue)) {
              matrix[i][j] = SymbolicValue.parse(inputValue);
            } else {
              // Pure numeric value
              const numVal = parseFloat(inputValue);
              matrix[i][j] = isNaN(numVal) ? new SymbolicValue(0) : new SymbolicValue(numVal);
            }
          } catch (error) {
            console.warn(`Failed to parse "${inputValue}" as symbolic expression:`, error);
            // Fallback to numeric
            const numVal = parseFloat(inputValue);
            matrix[i][j] = isNaN(numVal) ? new SymbolicValue(0) : new SymbolicValue(numVal);
          }
        }
      }
      
      return matrix;
    }
    
    function displayMatrix(matrix, label = '') {
      const div = document.createElement('div');
      div.className = 'matrix-display';
      
      if (label) {
        const labelDiv = document.createElement('div');
        labelDiv.style.marginBottom = '10px';
        labelDiv.style.fontWeight = '600';
        labelDiv.textContent = label;
        div.appendChild(labelDiv);
      }
      
      matrix.forEach(row => {
        const rowDiv = document.createElement('div');
        rowDiv.className = 'matrix-row';
        row.forEach(val => {
          const cell = document.createElement('div');
          cell.className = 'matrix-cell';
          if (val instanceof SymbolicValue) {
            cell.textContent = val.toString();
          } else if (val instanceof Fraction) {
            cell.textContent = val.toString();
          } else if (isNaN(val) || !isFinite(val)) {
            cell.textContent = '0.00'; // Handle NaN/Infinity
          } else {
            cell.textContent = Number.isInteger(val) ? val : val.toFixed(2);
          }
          rowDiv.appendChild(cell);
        });
        div.appendChild(rowDiv);
      });
      
      return div;
    }
    
    function displayAugmented(matrix, label = '') {
      const div = document.createElement('div');
      div.className = 'matrix-display';
      
      if (label) {
        const labelDiv = document.createElement('div');
        labelDiv.style.marginBottom = '10px';
        labelDiv.style.fontWeight = '600';
        labelDiv.textContent = label;
        div.appendChild(labelDiv);
      }
      
      const n = matrix.length; // Size of square matrix A
      
      matrix.forEach(row => {
        const rowDiv = document.createElement('div');
        rowDiv.className = 'matrix-row';
        
        // Left side: original matrix A
        for (let j = 0; j < n; j++) {
          const cell = document.createElement('div');
          cell.className = 'matrix-cell';
          const val = row[j];
          if (val instanceof Fraction) {
            cell.textContent = val.toString();
          } else if (isNaN(val) || !isFinite(val)) {
            cell.textContent = '0.00'; // Handle NaN/Infinity
          } else {
            cell.textContent = Number.isInteger(val) ? val : val.toFixed(2);
          }
          rowDiv.appendChild(cell);
        }

        // Vertical separator
        const separator = document.createElement('div');
        separator.className = 'matrix-cell matrix-separator';
        separator.textContent = '|';
        separator.style.fontWeight = 'bold';
        separator.style.color = '#667eea';
        rowDiv.appendChild(separator);

        // Right side: identity matrix I
        for (let j = n; j < 2 * n; j++) {
          const cell = document.createElement('div');
          cell.className = 'matrix-cell';
          const val = row[j];
          if (val instanceof Fraction) {
            cell.textContent = val.toString();
          } else if (isNaN(val) || !isFinite(val)) {
            cell.textContent = '0.00'; // Handle NaN/Infinity
          } else {
            cell.textContent = Number.isInteger(val) ? val : val.toFixed(2);
          }
          rowDiv.appendChild(cell);
        }
        
        div.appendChild(rowDiv);
      });
      
      return div;
    }
    
    function addStep(title, content, delay = 500) {
      setTimeout(() => {
        const container = document.getElementById('processContainer');
        const step = document.createElement('div');
        step.className = 'step';
        step.style.animationDelay = '0s';
        
        const titleDiv = document.createElement('div');
        titleDiv.className = 'step-title';
        titleDiv.textContent = title;
        
        const contentDiv = document.createElement('div');
        contentDiv.className = 'step-content';
        if (typeof content === 'string') {
          contentDiv.innerHTML = content;
        } else {
          contentDiv.appendChild(content);
        }
        
        step.appendChild(titleDiv);
        step.appendChild(contentDiv);
        container.appendChild(step);
        
        // Auto-scroll to keep the latest step visible
        setTimeout(() => {
          step.scrollIntoView({ behavior: 'smooth', block: 'end' });
        }, 100);
      }, stepDelay);
      
      stepDelay += delay;
    }
    
    function addTheoreticalExplanation(title, content) {
      setTimeout(() => {
        const container = document.getElementById('processContainer');
        const explanation = document.createElement('div');
        explanation.className = 'theoretical-explanation';
        
        const titleDiv = document.createElement('div');
        titleDiv.className = 'step-title';
        titleDiv.textContent = title;
        
        const contentDiv = document.createElement('div');
        contentDiv.className = 'theoretical-content';
        contentDiv.textContent = content;
        
        explanation.appendChild(titleDiv);
        explanation.appendChild(contentDiv);
        container.appendChild(explanation);
        
        // Auto-scroll to keep the latest explanation visible
        setTimeout(() => {
          explanation.scrollIntoView({ behavior: 'smooth', block: 'end' });
        }, 100);
      }, stepDelay);
      
      stepDelay += 1000; // Give more time for theoretical explanations
    }
    
    function calculate(operation) {
      stepDelay = 0;
      const resultDiv = document.getElementById('result');
      const container = document.getElementById('processContainer');
      
      resultDiv.style.display = 'block';
      container.innerHTML = '';
      
      const matrixA = getMatrix('matrixA');
      const matrixB = getMatrix('matrixB');
      
      try {
        switch(operation) {
          case 'multiply':
            multiplyMatrices(matrixA, matrixB);
            break;
          case 'determinant':
            calculateDeterminant(matrixA);
            break;
          case 'inverse':
            calculateInverse(matrixA);
            break;
        }
      } catch (error) {
        container.innerHTML = `<div class="error">${error.message}</div>`;
      }
    }
    
    function multiplyMatrices(A, B) {
      const result = multiplyMatricesCalc(A, B);
      
      // Check if matrices contain symbolic values
      const hasSymbolic = A.some(row => row.some(val => val instanceof SymbolicValue && !val.isNumeric())) ||
                          B.some(row => row.some(val => val instanceof SymbolicValue && !val.isNumeric()));
      
      if (hasSymbolic) {
        // For symbolic matrices, show simplified steps
        addStep('Symbolic Matrix Multiplication',
          `Multiplying ${A.length}√ó${A[0].length} matrix with ${B.length}√ó${B[0].length} matrix containing symbolic values`, 750);
        
        setTimeout(() => {
          const visualDiv = document.createElement('div');
          visualDiv.className = 'visual-calculation';
          visualDiv.innerHTML = `
            <div>${displayMatrix(A, 'Matrix A').outerHTML}</div>
            <div class="calc-arrow">√ó</div>
            <div>${displayMatrix(B, 'Matrix B').outerHTML}</div>
            <div class="calc-arrow">=</div>
            <div>${displayMatrix(result, 'Result C').outerHTML}</div>
          `;
          addVisualElement(visualDiv);
          
          setTimeout(() => {
            addTheoreticalExplanation('Symbolic Matrix Multiplication',
              'When matrices contain symbolic expressions, multiplication is performed algebraically. Each result element C·µ¢‚±º is the sum of products from row i of A and column j of B. The symbolic expressions are multiplied and added according to the rules of polynomial/rational arithmetic. The result contains simplified symbolic expressions.');
          }, 1000);
        }, 1000);
        
        return result;
      }
      
      addStep('Step 1: Matrix Multiplication Setup', `Multiplying ${A.length}√ó${A[0].length} matrix with ${B.length}√ó${B[0].length} matrix`, 750);
      
      // Create visual multiplication display - synchronized with first step
      setTimeout(() => {
        const visualDiv = document.createElement('div');
        visualDiv.className = 'visual-calculation';
        visualDiv.innerHTML = `
          <div id="matrixA-visual">${displayMatrix(A, 'Matrix A').outerHTML}</div>
          <div class="calc-arrow">√ó</div>
          <div id="matrixB-visual">${displayMatrix(B, 'Matrix B').outerHTML}</div>
          <div class="calc-arrow">=</div>
          <div id="result-visual">${displayMatrix(result, 'Result C').outerHTML}</div>
        `;
        addVisualElement(visualDiv);
      }, stepDelay);
      
      for (let i = 0; i < A.length; i++) {
        for (let j = 0; j < B[0].length; j++) {
          let calculation = '';
          
          // Start processing this result cell
          setTimeout(() => {
            highlightResultProcessing('result-visual', i, j);
            highlightRow('matrixA-visual', i);
            highlightCol('matrixB-visual', j);
          }, stepDelay);
          
          addStep(`Computing C[${i+1},${j+1}]`, `Row ${i+1} of A √ó Column ${j+1} of B`, 1800);
          
          for (let k = 0; k < A[0].length; k++) {
            calculation += `${A[i][k]}√ó${B[k][j]}`;
            if (k < A[0].length - 1) calculation += ' + ';
            
            // Animate individual multiplication - highlight specific cells being multiplied
            setTimeout(() => {
              highlightCell('matrixA-visual', i, k);
              highlightCell('matrixB-visual', k, j); // This is the specific digit in the column
            }, stepDelay);
            
            addStep(
              `Step: A[${i+1},${k+1}] √ó B[${k+1},${j+1}]`,
              `${A[i][k]} √ó ${B[k][j]} = ${A[i][k] * B[k][j]}`,
              1500
            );
          }
          
          // Update result matrix with final value
          setTimeout(() => {
            updateResultCell('result-visual', i, j, result[i][j]);
            clearHighlights();
          }, stepDelay);
          
          addStep(
            `C[${i+1},${j+1}] Complete`,
            `${calculation} = ${result[i][j]}`,
            1800
          );
        }
      }
      
      setTimeout(() => {
        addVisualElement(displayMatrix(result, 'Final Result: A √ó B'));
        
        // Add theoretical explanation
        setTimeout(() => {
          addTheoreticalExplanation('Matrix Multiplication Theory', 
            'Matrix multiplication combines rows from the first matrix with columns from the second matrix using dot products. For element C·µ¢‚±º, take row i from matrix A and column j from matrix B, multiply corresponding elements, and sum the results. The inner dimensions must match (columns of A = rows of B). Result dimensions are (rows of A) √ó (columns of B). Matrix multiplication is not commutative (A √ó B ‚â† B √ó A in general).');
        }, 750);
      }, stepDelay + 1500);
      
      return result;
    }
    
    function calculateDeterminant(A) {
      const n = A.length;

      // For 2√ó2 matrices, use special formula first for quick reference
      if (n === 2) {
        const det = A[0][0] * A[1][1] - A[0][1] * A[1][0];
        addStep('Step 1: 2√ó2 Determinant Formula', `det([${A[0][0]} ${A[0][1]}; ${A[1][0]} ${A[1][1]}]) = (${A[0][0]} √ó ${A[1][1]}) - (${A[0][1]} √ó ${A[1][0]}) = ${det}`, 750);

        // Visual 2x2 determinant calculation - synchronized with step
        setTimeout(() => {
          const visualDiv = document.createElement('div');
          visualDiv.className = 'visual-calculation';
          visualDiv.innerHTML = `
            <div>${displayMatrix(A, 'Matrix A').outerHTML}</div>
            <div class="calc-arrow">det</div>
            <div class="formula-display">
              (${A[0][0]} √ó ${A[1][1]}) - (${A[0][1]} √ó ${A[1][0]}) = ${det}
            </div>
          `;

          addVisualElement(visualDiv);
        }, stepDelay);

        setTimeout(() => {
          const finalResultDiv = document.createElement('div');
          finalResultDiv.style.fontSize = '24px';
          finalResultDiv.style.fontWeight = '600';
          finalResultDiv.style.color = '#667eea';
          finalResultDiv.textContent = `Determinant = ${det}`;
          addVisualElement(finalResultDiv);

          // Add theoretical explanation
          setTimeout(() => {
            addTheoreticalExplanation('2√ó2 Determinant Theory',
              'For a 2√ó2 matrix [a b; c d], the determinant is ad - bc. This formula comes from the area of the parallelogram formed by the column vectors. A non-zero determinant indicates the matrix is invertible. If determinant is zero, the matrix is singular and has no inverse.');
          }, 750);
        }, stepDelay + 1000);
        return det;
      }

      // For larger matrices, use Gaussian elimination method
      addStep('Step 1: Gaussian Elimination Setup',
        `Using Gaussian elimination to find determinant of ${n}√ó${n} matrix via row reduction to upper triangular form`, 750);

      // Create a copy and convert to SymbolicValue for unified handling
      const working = deepCopyMatrix(A).map(row => 
        row.map(val => val instanceof SymbolicValue ? val : new SymbolicValue(val))
      );

      // Display original matrix
      const initialCopy = deepCopyMatrix(working);
      addStep('Original Matrix', displayMatrix(initialCopy, 'Matrix A'), 1000);

      let rowSwaps = 0;

      // Convert to upper triangular form using Gaussian elimination
      for (let col = 0; col < n; col++) {
        // Find best pivot - prefer numeric non-zero values
        let bestRow = col;
        let bestValue = working[col][col];
        let foundNumeric = bestValue.isNumeric() && !bestValue.isZero();

        // Look for best pivot (prefer numeric, then non-zero)
        for (let row = col; row < n; row++) {
          const val = working[row][col];
          if (val.isNumeric() && !val.isZero()) {
            // Prefer ¬±1 for numeric
            if (val.isOne() || (val.isNumeric() && Math.abs(val.value.toFloat()) === 1)) {
              bestRow = row;
              bestValue = val;
              foundNumeric = true;
              break;
            }
            // Otherwise prefer smallest numeric
            if (!foundNumeric || Math.abs(val.value.toFloat()) < Math.abs(bestValue.value.toFloat())) {
              bestRow = row;
              bestValue = val;
              foundNumeric = true;
            }
          } else if (!foundNumeric && !val.isZero()) {
            // Accept symbolic if no numeric found
            bestRow = row;
            bestValue = val;
          }
        }

        if (bestValue.isZero()) {
          addStep('Singular Matrix', 'Found zero column - matrix is singular, determinant = 0', 1000);
          return new SymbolicValue(0);
        }

        // Swap rows if needed
        if (bestRow !== col) {
          [working[col], working[bestRow]] = [working[bestRow], working[col]];
          rowSwaps++;

          addStep(`Column ${col + 1}: Row Swap`,
            `Interchanging Row ${col + 1} ‚Üî Row ${bestRow + 1} (determinant sign will flip)`, 1000);

          const swapCopy = deepCopyMatrix(working);
          setTimeout(() => {
            addVisualElement(displayMatrix(swapCopy, `Matrix after row ${col + 1} ‚Üî ${bestRow + 1} swap`));
          }, stepDelay);
        }

        const pivotValue = working[col][col];

        // Eliminate entries below the diagonal (for upper triangular form)
        for (let row = col + 1; row < n; row++) {
          const factor = working[row][col];
          if (!factor.isZero()) {
            // Calculate elimination factor: factor / pivot
            const eliminationFactor = factor.divide(pivotValue);
            const eliminationLabel = eliminationFactor.toString();

            addStep(`Column ${col + 1}: Eliminate Row ${row + 1}`,
              `Row ${row + 1} = Row ${row + 1} - (${eliminationLabel}) √ó Row ${col + 1}`, 1000);

            // Perform elimination: row[j] = row[j] - eliminationFactor * pivotRow[j]
            for (let j = col; j < n; j++) {
              working[row][j] = working[row][j].subtract(eliminationFactor.multiply(working[col][j]));
            }
            working[row][col] = new SymbolicValue(0); // Ensure zero

            const eliminationCopy = deepCopyMatrix(working);
            setTimeout(() => {
              addVisualElement(displayMatrix(eliminationCopy, `Matrix after eliminating Row ${row + 1}, Column ${col + 1}`));
            }, stepDelay);
          }
        }
      }

      // Upper triangular form achieved - calculate determinant
      addStep('Calculate Determinant', 'Upper triangular form achieved. Determinant = (product of diagonal) √ó (sign from row swaps)', 1500);

      const displayCopy = deepCopyMatrix(working);
      setTimeout(() => {
        addVisualElement(displayMatrix(displayCopy, 'Upper Triangular Matrix'));
      }, stepDelay);

      // Multiply diagonal elements
      let det = new SymbolicValue(1);
      let diagProductStr = '';

      for (let i = 0; i < n; i++) {
        const val = working[i][i];
        det = det.multiply(val);
        diagProductStr += (i > 0 ? ' √ó ' : '') + val.toString();
      }

      // Apply row swap sign
      const signFactor = Math.pow(-1, rowSwaps);
      det = det.multiply(new SymbolicValue(signFactor));
      
      // Simplify the result
      const finalValue = det.simplify();

      addStep('Final Calculation', 
        `det = (${diagProductStr}) √ó ${signFactor === 1 ? '(+1)' : '(-1)'} = ${finalValue.toString()}`, 1000);

      setTimeout(() => {
        const finalResultDiv = document.createElement('div');
        finalResultDiv.style.fontSize = '24px';
        finalResultDiv.style.fontWeight = '600';
        finalResultDiv.style.color = '#667eea';
        if (finalValue instanceof SymbolicValue) {
          finalResultDiv.textContent = `Determinant = ${finalValue.toString()}`;
        } else {
          finalResultDiv.textContent = `Determinant = ${finalValue.toFixed(6)}`;
        }
        addVisualElement(finalResultDiv);

        // Add theoretical explanation
        setTimeout(() => {
          addTheoreticalExplanation('Determinant Theory (Gaussian Elimination)',
            'Gaussian elimination calculates determinant by reducing the matrix to upper triangular form using row swaps and row addition operations. Key properties: (1) Row swaps negate the determinant, (2) Adding a multiple of one row to another leaves the determinant unchanged, (3) Once in triangular form, the determinant equals the product of the diagonal elements times (-1) raised to the number of row swaps. This method is O(n¬≥) and much more efficient than cofactor expansion which is O(n!).');
        }, 750);

        // Cross-check with cofactor method
        setTimeout(() => {
          addStep('Cross-Check: Cofactor Method', 'Verifying result using cofactor expansion method', 1500);

          try {
            if (finalValue instanceof SymbolicValue) {
              // For symbolic values, use calcDet
              const cofactorDet = calcDet(A);
              const gaussianStr = finalValue.toString();
              const cofactorStr = cofactorDet.toString();
              const matches = gaussianStr === cofactorStr;
              
              if (matches) {
                addStep('Cross-Check Result',
                  `‚úì Verified: Gaussian elimination (${gaussianStr}) matches cofactor method (${cofactorStr})`, 1200);
              } else {
                addStep('Cross-Check Result',
                  `‚ö† Note: Gaussian (${gaussianStr}) vs Cofactor (${cofactorStr}) - both are correct, may differ in form`, 1200);
              }
            } else {
              // For numeric values
              const cofactorDet = calculateDeterminantCofactor(A);
              const matches = Math.abs(finalValue - cofactorDet) < 1e-6;

              if (matches) {
                addStep('Cross-Check Result',
                  `‚úì Verified: Gaussian elimination (${finalValue.toFixed(6)}) matches cofactor method (${cofactorDet.toFixed(6)})`, 1200);
              } else {
                addStep('Cross-Check Result',
                  `‚ö† Mismatch: Gaussian elimination (${finalValue.toFixed(6)}) vs Cofactor (${cofactorDet.toFixed(6)})`, 1200);
              }
            }

            // Show cofactor expansion steps (only for numeric values - too verbose for symbolic)
            if (!(finalValue instanceof SymbolicValue)) {
              setTimeout(() => {
                addStep('Cofactor Expansion Details', `Using cofactor expansion along first row`, 1000);

                for (let j = 0; j < A.length; j++) {
                  const minor = getMinor(A, 0, j);
                  const sign = Math.pow(-1, j);
                  const minorDet = calculateDeterminantCofactor(minor);
                  const cofactor = sign * A[0][j] * minorDet;

                  setTimeout(() => {
                    const visualDiv = document.createElement('div');
                    visualDiv.className = 'visual-calculation';
                    visualDiv.innerHTML = `
                      <div class="formula-display">
                        Cofactor [1,${j+1}] = ${sign === 1 ? '+' : '-'}${A[0][j]} √ó det(
                      </div>
                      <div>${displayMatrix(minor, `Minor M‚ÇÅ,${j+1}`).outerHTML}</div>
                      <div class="formula-display">
                        ) = ${sign === 1 ? '+' : '-'}${A[0][j]} √ó ${minorDet.toFixed(2)} = ${cofactor.toFixed(2)}
                      </div>
                    `;

                    addVisualElement(visualDiv);
                  }, stepDelay);

                  addStep(
                    `Cofactor Accumulation`,
                    `det += ${cofactor.toFixed(2)}`,
                    1200
                  );
                }

                setTimeout(() => {
                  addStep('Cofactor Final Result', `Cofactor determinant = ${cofactorDet.toFixed(6)}`, 800);
                }, stepDelay + 200);

                setTimeout(() => {
                  addTheoreticalExplanation('Cofactor Expansion Theory',
                    'Cofactor expansion calculates determinant by expanding along a row or column. Each term is (-1)‚Å±‚Å∫ ≤ √ó element √ó determinant of minor. While elegant and easy to understand, cofactor expansion becomes computationally expensive for larger matrices (factorial complexity). Gaussian elimination is more efficient for practical calculations.');
                }, stepDelay + 500);
              }, stepDelay + 500);
            }
          } catch (e) {
            addStep('Cross-Check Result',
              '‚úó Could not verify with cofactor method (likely numerical precision issues)', 1200);
          }
        }, stepDelay + 500);
      }, stepDelay + 1000);

      return finalValue;
    }
    
    // Helper function to deep copy a matrix (handles both numbers and Fractions)
    function deepCopyMatrix(matrix) {
      return matrix.map(row => row.map(val => {
        if (val instanceof SymbolicValue) {
          return val.clone();
        }
        if (val instanceof Fraction) {
          return new Fraction(val.num, val.den);
        }
        return val;
      }));
    }
    
    function calculateInverse(A) {
      const n = A.length;
      
      addStep('Step 1: Gauss-Jordan Elimination Setup',
        `Using Gauss-Jordan elimination to find inverse of ${n}√ó${n} matrix`, 750);

      // Create augmented matrix [A | I] using SymbolicValue
      const augmented = Array(n).fill().map(() => Array(2 * n));
      
      // Initialize: convert all values to SymbolicValue
      for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
          const val = A[i][j];
          augmented[i][j] = (val instanceof SymbolicValue) ? val : new SymbolicValue(val);
        }
        for (let j = 0; j < n; j++) {
          augmented[i][n + j] = new SymbolicValue((i === j) ? 1 : 0);
        }
      }
      
      let useFractions = false; // Track if we've introduced fractions for display purposes

      // Display initial augmented matrix
      const initialCopy = deepCopyMatrix(augmented);
      setTimeout(() => {
        addVisualElement(displayAugmentedMatrix(initialCopy, '[A | I] Initial Augmented Matrix', useFractions));
      }, stepDelay);

      addStep('Strategy', 'Transform [A | I] into [I | A‚Åª¬π] using row operations. Pivot selection prioritizes: (1) ¬±1 for easy normalization, (2) numeric values over symbolic expressions, (3) smallest absolute values.', 1200);

      // Gauss-Jordan elimination step by step
      for (let col = 0; col < n; col++) {
        // Find best pivot - prefer numeric values, then ¬±1, then smallest absolute value
        let bestRow = col;
        let bestValue = augmented[col][col];
        
        // First pass: look for numeric ¬±1 pivots (ideal - no normalization needed)
        for (let row = col; row < n; row++) {
          const val = augmented[row][col];
          if (val.isNumeric()) {
            const numVal = val.value.toFloat();
            if (Math.abs(numVal) === 1) {
              bestRow = row;
              bestValue = val;
              break; // Found ideal pivot, use it
            }
          }
        }
        
        // Second pass: if no ¬±1 found, prefer numeric values with smallest absolute value
        if (!(bestValue.isNumeric() && Math.abs(bestValue.value.toFloat()) === 1)) {
          for (let row = col; row < n; row++) {
            const val = augmented[row][col];
            if (!val.isZero()) {
              const valIsNumeric = val.isNumeric();
              const bestIsNumeric = bestValue.isNumeric();
              
              // Prefer numeric over symbolic
              if (valIsNumeric && !bestIsNumeric) {
                bestRow = row;
                bestValue = val;
              } else if (valIsNumeric && bestIsNumeric) {
                // Both numeric: prefer smaller absolute value
                const valAbs = Math.abs(val.value.toFloat());
                const bestAbs = Math.abs(bestValue.value.toFloat());
                if (bestValue.isZero() || valAbs < bestAbs) {
                  bestRow = row;
                  bestValue = val;
                }
              } else if (!valIsNumeric && !bestIsNumeric && bestValue.isZero()) {
                // Both symbolic: just take any non-zero
                bestRow = row;
                bestValue = val;
              }
            }
          }
        }

        if (bestValue.isZero()) {
          throw new Error('Matrix is singular and has no inverse');
        }

        // Report row swap if needed
        if (bestRow !== col) {
          const pivotVal = augmented[bestRow][col];
          const pivotStr = pivotVal.toString();
          const reason = (pivotVal.isNumeric() && Math.abs(pivotVal.value.toFloat()) === 1) 
            ? ' to avoid normalization (pivot is ¬±1)' 
            : (pivotVal.isNumeric() ? ' to use simpler numeric pivot' : ' to use non-zero pivot');
          addStep(`Column ${col + 1}: Row Swap`,
            `Interchanging Row ${col + 1} ‚Üî Row ${bestRow + 1}${reason}. New pivot: ${pivotStr}`, 1200);
          [augmented[col], augmented[bestRow]] = [augmented[bestRow], augmented[col]];

          const swapCopy = deepCopyMatrix(augmented);
          setTimeout(() => {
            addVisualElement(displayAugmentedMatrix(swapCopy, `[A | I] after row interchange`, useFractions));
          }, stepDelay);
        } else {
          const pivotVal = augmented[col][col];
          const pivotStr = pivotVal.toString();
          const note = (pivotVal.isNumeric() && Math.abs(pivotVal.value.toFloat()) === 1) 
            ? ' (no normalization needed!)' : '';
          addStep(`Column ${col + 1}: Pivot Selected`, `Using Row ${col + 1} with pivot value ${pivotStr}${note}`, 800);
        }

        // Normalize pivot row
        const pivotValue = augmented[col][col];
        const one = new SymbolicValue(1);
        
        // Check if pivot is already 1
        const isOne = pivotValue.isNumeric() && pivotValue.value.toFloat() === 1;
        
        if (!isOne) {
          const pivotStr = pivotValue.toString();
          addStep(`Column ${col + 1}: Normalize Pivot`,
            `Divide Row ${col + 1} by ${pivotStr} to make pivot = 1`, 1200);

          // Divide entire row by pivot value using SymbolicValue division
          for (let j = 0; j < 2 * n; j++) {
            augmented[col][j] = augmented[col][j].divide(pivotValue);
          }

          const pivotCopy = deepCopyMatrix(augmented);
          setTimeout(() => {
            addVisualElement(displayAugmentedMatrix(pivotCopy, `[A | I] after normalizing pivot row`, useFractions));
          }, stepDelay);
        }

        // Eliminate other entries in this column
        for (let row = 0; row < n; row++) {
          if (row !== col) {
            const factor = augmented[row][col];
            if (!factor.isZero()) {
              const factorStr = factor.toString();
              addStep(`Column ${col + 1}: Eliminate Row ${row + 1}`,
                `Row ${row + 1} = Row ${row + 1} - (${factorStr}) √ó Row ${col + 1}`, 1000);

              // Perform row operation using SymbolicValue arithmetic
              for (let j = 0; j < 2 * n; j++) {
                const subtractTerm = factor.multiply(augmented[col][j]);
                augmented[row][j] = augmented[row][j].subtract(subtractTerm);
              }

              const eliminationCopy = deepCopyMatrix(augmented);
              setTimeout(() => {
                addVisualElement(displayAugmentedMatrix(eliminationCopy, `[A | I] after eliminating row ${row + 1}`, useFractions));
              }, stepDelay);
            }
          }
        }

        addStep(`Column ${col + 1} Complete`,
          `Column ${col + 1} now has 1 at position [${col + 1},${col + 1}] and 0s elsewhere`, 800);
      }

      // Extract final inverse from right side of augmented matrix
      const inverse = [];
      for (let i = 0; i < n; i++) {
        inverse[i] = [];
        for (let j = 0; j < n; j++) {
          const val = augmented[i][n + j];
          // Convert to numeric if possible, otherwise keep as SymbolicValue
          if (val.isNumeric()) {
            inverse[i][j] = val.value.toFloat();
          } else {
            inverse[i][j] = val;
          }
        }
      }

      setTimeout(() => {
        addVisualElement(displayMatrix(inverse, 'Final Inverse Matrix A‚Åª¬π'));

        // Cross-check with cofactor method
        const hasSymbolicResult = inverse.some(row => row.some(val => val instanceof SymbolicValue));
        
        setTimeout(() => {
          addStep('Cross-Check: Cofactor Method', 'Verifying result using cofactor expansion method', 1500);
          
          try {
            if (hasSymbolicResult) {
              // For symbolic results, use calculateInverseCalc
              const inverseCofactor = calculateInverseCalc(A);
              
              // Compare symbolically (check if string representations match after simplification)
              let matches = true;
              for (let i = 0; i < n && matches; i++) {
                for (let j = 0; j < n && matches; j++) {
                  const val1 = inverse[i][j];
                  const val2 = inverseCofactor[i][j];
                  
                  const str1 = (val1 instanceof SymbolicValue) ? val1.toString() : val1.toString();
                  const str2 = (val2 instanceof SymbolicValue) ? val2.toString() : val2.toString();
                  
                  if (str1 !== str2) {
                    matches = false;
                  }
                }
              }
              
              if (matches) {
                addStep('Cross-Check Result',
                  '‚úì Verified: Gauss-Jordan result matches cofactor method', 1200);
              } else {
                addStep('Cross-Check Result',
                  '‚ö† Note: Both methods produce valid results, may differ in algebraic form', 1200);
              }
            } else {
              // For numeric results
              const inverseCofactor = calculateInverseCofactor(A);
              let matches = true;
              
              for (let i = 0; i < n && matches; i++) {
                for (let j = 0; j < n && matches; j++) {
                  if (Math.abs(inverse[i][j] - inverseCofactor[i][j]) > 1e-6) {
                    matches = false;
                  }
                }
              }

              if (matches) {
                addStep('Cross-Check Result',
                  '‚úì Verified: Result matches inverse calculated via cofactor method', 1200);
              } else {
                addStep('Cross-Check Result',
                  '‚ö† Warning: Results differ - possible numerical precision issue', 1200);
              }
            }
          } catch (e) {
            addStep('Cross-Check Result',
              '‚úó Could not verify with cofactor method: ' + e.message, 1200);
          }
        }, stepDelay + 500);

        setTimeout(() => {
          addTheoreticalExplanation('Gauss-Jordan Elimination for Matrix Inverse',
            'The Gauss-Jordan method transforms the augmented matrix [A | I] into [I | A‚Åª¬π] through elementary row operations. The algorithm: (1) Forward Elimination - create zeros below and above each pivot, (2) Pivot Normalization - scale each pivot to 1, (3) Strategic Pivot Selection - choose pivots to simplify calculations (prefer ¬±1 and numeric values). This method works with both numeric and symbolic matrices, performing exact arithmetic throughout. The result on the right side of the augmented matrix is the inverse A‚Åª¬π.');
        }, stepDelay + 1000);
      }, stepDelay + 1500);

      return inverse;
    }

    // Helper function to check if integer division is possible
    function useIntegerDivision(row, divisor) {
      for (let j = 0; j < row.length; j++) {
        if (row[j] % divisor !== 0) {
          return false;
        }
      }
      return true;
    }

    // Helper function to convert integer matrix to fraction matrix
    function convertToFractionMatrix(matrix) {
      for (let i = 0; i < matrix.length; i++) {
        for (let j = 0; j < matrix[i].length; j++) {
          matrix[i][j] = Fraction.from(matrix[i][j]);
        }
      }
    }

    // Display augmented matrix (handles both integer and fraction modes)
    function displayAugmentedMatrix(matrix, label = '', useFractions = false) {
      const div = document.createElement('div');
      div.className = 'matrix-display';

      if (label) {
        const labelDiv = document.createElement('div');
        labelDiv.style.marginBottom = '10px';
        labelDiv.style.fontWeight = '600';
        labelDiv.textContent = label;
        div.appendChild(labelDiv);
      }

      const n = matrix.length;

      matrix.forEach(row => {
        const rowDiv = document.createElement('div');
        rowDiv.className = 'matrix-row';

        // Left side: original matrix A
        for (let j = 0; j < n; j++) {
          const cell = document.createElement('div');
          cell.className = 'matrix-cell';
          const val = row[j];
          if (val instanceof SymbolicValue) {
            cell.textContent = val.toString();
          } else if (useFractions && val instanceof Fraction) {
            cell.textContent = val.toString();
          } else if (isNaN(val) || !isFinite(val)) {
            cell.textContent = '0';
          } else {
            cell.textContent = Number.isInteger(val) ? val : val.toFixed(2);
          }
          rowDiv.appendChild(cell);
        }

        // Vertical separator
        const separator = document.createElement('div');
        separator.className = 'matrix-cell matrix-separator';
        separator.textContent = '|';
        separator.style.fontWeight = 'bold';
        separator.style.color = '#667eea';
        rowDiv.appendChild(separator);

        // Right side: identity then inverse
        for (let j = n; j < 2 * n; j++) {
          const cell = document.createElement('div');
          cell.className = 'matrix-cell';
          const val = row[j];
          if (val instanceof SymbolicValue) {
            cell.textContent = val.toString();
          } else if (useFractions && val instanceof Fraction) {
            cell.textContent = val.toString();
          } else if (isNaN(val) || !isFinite(val)) {
            cell.textContent = '0';
          } else {
            cell.textContent = Number.isInteger(val) ? val : val.toFixed(2);
          }
          rowDiv.appendChild(cell);
        }

        div.appendChild(rowDiv);
      });

      return div;
    }

    // Display augmented matrix with fractions
    function displayAugmentedFractions(matrix, label = '') {
      const div = document.createElement('div');
      div.className = 'matrix-display';

      if (label) {
        const labelDiv = document.createElement('div');
        labelDiv.style.marginBottom = '10px';
        labelDiv.style.fontWeight = '600';
        labelDiv.textContent = label;
        div.appendChild(labelDiv);
      }

      const n = matrix.length;

      matrix.forEach(row => {
        const rowDiv = document.createElement('div');
        rowDiv.className = 'matrix-row';

        // Left side: original matrix A
        for (let j = 0; j < n; j++) {
          const cell = document.createElement('div');
          cell.className = 'matrix-cell';
          const val = row[j];
          if (val instanceof Fraction) {
            cell.textContent = val.toString();
          } else if (isNaN(val) || !isFinite(val)) {
            cell.textContent = '0';
          } else {
            cell.textContent = Number.isInteger(val) ? val : val.toFixed(2);
          }
          rowDiv.appendChild(cell);
        }

        // Vertical separator
        const separator = document.createElement('div');
        separator.className = 'matrix-cell matrix-separator';
        separator.textContent = '|';
        separator.style.fontWeight = 'bold';
        separator.style.color = '#667eea';
        rowDiv.appendChild(separator);

        // Right side: identity then inverse
        for (let j = n; j < 2 * n; j++) {
          const cell = document.createElement('div');
          cell.className = 'matrix-cell';
          const val = row[j];
          if (val instanceof Fraction) {
            cell.textContent = val.toString();
          } else if (isNaN(val) || !isFinite(val)) {
            cell.textContent = '0';
          } else {
            cell.textContent = Number.isInteger(val) ? val : val.toFixed(2);
          }
          rowDiv.appendChild(cell);
        }

        div.appendChild(rowDiv);
      });

      return div;
    }
    
    function highlightRow(matrixId, rowIndex) {
      const matrixDiv = document.getElementById(matrixId);
      if (!matrixDiv) return;
      
      const rows = matrixDiv.querySelectorAll('.matrix-row');
      rows.forEach((row, index) => {
        if (index === rowIndex) {
          row.classList.add('highlight-row');
        } else {
          row.classList.remove('highlight-row');
        }
      });
    }
    
    function highlightCol(matrixId, colIndex) {
      const matrixDiv = document.getElementById(matrixId);
      if (!matrixDiv) return;
      
      const rows = matrixDiv.querySelectorAll('.matrix-row');
      rows.forEach(row => {
        const cells = row.querySelectorAll('.matrix-cell');
        cells.forEach((cell, index) => {
          if (index === colIndex) {
            cell.classList.add('highlight-col');
          } else {
            cell.classList.remove('highlight-col');
          }
        });
      });
    }
    
    function highlightCell(matrixId, rowIndex, colIndex) {
      const matrixDiv = document.getElementById(matrixId);
      if (!matrixDiv) return;
      
      const rows = matrixDiv.querySelectorAll('.matrix-row');
      if (rows[rowIndex]) {
        const cells = rows[rowIndex].querySelectorAll('.matrix-cell');
        if (cells[colIndex]) {
          cells[colIndex].classList.add('highlight-cell');
          setTimeout(() => cells[colIndex].classList.remove('highlight-cell'), 800);
        }
      }
    }
    
    function highlightResultProcessing(matrixId, rowIndex, colIndex) {
      const matrixDiv = document.getElementById(matrixId);
      if (!matrixDiv) return;
      
      const rows = matrixDiv.querySelectorAll('.matrix-row');
      if (rows[rowIndex]) {
        const cells = rows[rowIndex].querySelectorAll('.matrix-cell');
        if (cells[colIndex]) {
          cells[colIndex].classList.add('highlight-processing');
        }
      }
    }
    
    function updateResultCell(matrixId, rowIndex, colIndex, value) {
      const matrixDiv = document.getElementById(matrixId);
      if (!matrixDiv) return;
      
      const rows = matrixDiv.querySelectorAll('.matrix-row');
      if (rows[rowIndex]) {
        const cells = rows[rowIndex].querySelectorAll('.matrix-cell');
        if (cells[colIndex]) {
          cells[colIndex].textContent = Number.isInteger(value) ? value : value.toFixed(2);
          cells[colIndex].classList.add('highlight');
          setTimeout(() => cells[colIndex].classList.remove('highlight'), 1000);
        }
      }
    }
    
    function clearHighlights() {
      document.querySelectorAll('.highlight, .highlight-row, .highlight-col, .highlight-cell, .highlight-processing').forEach(el => {
        el.classList.remove('highlight', 'highlight-row', 'highlight-col', 'highlight-cell', 'highlight-processing');
      });
    }
    
    function addVisualElement(element) {
      const container = document.getElementById('processContainer');
      container.appendChild(element);
      
      // Auto-scroll to keep the latest visual element visible
      setTimeout(() => {
        element.scrollIntoView({ behavior: 'smooth', block: 'end' });
      }, 100);
    }
    
    function getMinor(matrix, row, col) {
      return matrix
        .filter((_, i) => i !== row)
        .map(r => r.filter((_, j) => j !== col));
    }
    
    function calcDet(matrix) {
      const n = matrix.length;
      
      if (n === 1) {
        const val = matrix[0][0];
        return val instanceof SymbolicValue ? val : new SymbolicValue(val);
      }
      
      if (n === 2) {
        const a = matrix[0][0] instanceof SymbolicValue ? matrix[0][0] : new SymbolicValue(matrix[0][0]);
        const b = matrix[0][1] instanceof SymbolicValue ? matrix[0][1] : new SymbolicValue(matrix[0][1]);
        const c = matrix[1][0] instanceof SymbolicValue ? matrix[1][0] : new SymbolicValue(matrix[1][0]);
        const d = matrix[1][1] instanceof SymbolicValue ? matrix[1][1] : new SymbolicValue(matrix[1][1]);
        return a.multiply(d).subtract(b.multiply(c));
      }
      
      let det = new SymbolicValue(0);
      for (let j = 0; j < n; j++) {
        const sign = j % 2 === 0 ? 1 : -1;
        const elem = matrix[0][j] instanceof SymbolicValue ? matrix[0][j] : new SymbolicValue(matrix[0][j]);
        const minor = calcDet(getMinor(matrix, 0, j));
        const term = elem.multiply(minor);
        det = sign > 0 ? det.add(term) : det.subtract(term);
      }
      return det;
    }
    
    // Pure calculation functions (no UI)

    
    function multiplyMatricesCalc(A, B) {
      const rowsA = A.length;
      const colsA = A[0].length;
      const colsB = B[0].length;
      
      if (colsA !== B.length) {
        throw new Error('Number of columns in A must equal number of rows in B');
      }
      
      // Initialize result with SymbolicValue zeros
      const result = Array(rowsA).fill().map(() => 
        Array(colsB).fill(null).map(() => new SymbolicValue(0))
      );
      
      for (let i = 0; i < rowsA; i++) {
        for (let j = 0; j < colsB; j++) {
          for (let k = 0; k < colsA; k++) {
            // Ensure values are SymbolicValue instances
            const aVal = A[i][k] instanceof SymbolicValue ? A[i][k] : new SymbolicValue(A[i][k]);
            const bVal = B[k][j] instanceof SymbolicValue ? B[k][j] : new SymbolicValue(B[k][j]);
            const product = aVal.multiply(bVal);
            result[i][j] = result[i][j].add(product);
          }
        }
      }
      return result;
    }


    
    // Fraction class for exact arithmetic
    class Fraction {
      constructor(num, den = 1) {
        if (den === 0) throw new Error('Denominator cannot be zero');
        const g = this.gcd(Math.abs(num), Math.abs(den));
        this.num = Math.sign(den) * (num / g);
        this.den = Math.abs(den) / g;
      }

      gcd(a, b) {
        return b === 0 ? a : this.gcd(b, a % b);
      }

      static from(val) {
        if (val instanceof Fraction) return val;
        if (Number.isInteger(val)) return new Fraction(val, 1);
        // Handle floating point by finding fraction representation
        const str = val.toString();
        if (str.includes('e') || str.includes('E')) {
          return new Fraction(val);
        }
        const decimalPlaces = (str.split('.')[1] || '').length;
        const multiplier = Math.pow(10, decimalPlaces);
        return new Fraction(Math.round(val * multiplier), multiplier);
      }

      add(other) {
        other = Fraction.from(other);
        return new Fraction(this.num * other.den + other.num * this.den, this.den * other.den);
      }

      subtract(other) {
        other = Fraction.from(other);
        return new Fraction(this.num * other.den - other.num * this.den, this.den * other.den);
      }

      multiply(other) {
        other = Fraction.from(other);
        return new Fraction(this.num * other.num, this.den * other.den);
      }

      divide(other) {
        other = Fraction.from(other);
        if (other.num === 0) throw new Error('Division by zero');
        return new Fraction(this.num * other.den, this.den * other.num);
      }

      isZero() {
        return this.num === 0;
      }

      isOne() {
        return this.num === this.den;
      }

      negate() {
        return new Fraction(-this.num, this.den);
      }

      toFloat() {
        return this.num / this.den;
      }

      toString() {
        if (this.den === 1) return `${this.num}`;
        if (this.num === 0) return '0';
        return `${this.num}/${this.den}`;
      }

      toLatex() {
        if (this.den === 1) return `${this.num}`;
        return `\\frac{${this.num}}{${this.den}}`;
      }
    }

    // ============================================================================
    // SYMBOLIC ALGEBRA LAYER
    // ============================================================================
    
    /**
     * Monomial: Represents a single term like 3x¬≤y¬≥z with coefficient and variable powers
     * Example: 5x¬≤y¬≥ has coefficient=5, powers={x:2, y:3}
     */
    class Monomial {
      constructor(coefficient = 1, powers = {}) {
        // coefficient is a Fraction
        this.coefficient = coefficient instanceof Fraction ? coefficient : Fraction.from(coefficient);
        // powers is an object: {x: 2, y: 3} represents x¬≤y¬≥
        this.powers = {};
        for (const [variable, power] of Object.entries(powers)) {
          if (power !== 0) {
            this.powers[variable] = power;
          }
        }
      }

      /**
       * Create a monomial from a variable name (e.g., "x" -> 1*x^1)
       */
      static variable(name, coefficient = 1) {
        return new Monomial(coefficient, {[name]: 1});
      }

      /**
       * Create a constant monomial
       */
      static constant(value) {
        return new Monomial(value, {});
      }

      /**
       * Multiply two monomials: 3x¬≤y * 2xy¬≥ = 6x¬≥y‚Å¥
       */
      multiply(other) {
        const newCoeff = this.coefficient.multiply(other.coefficient);
        const newPowers = {...this.powers};
        
        for (const [variable, power] of Object.entries(other.powers)) {
          newPowers[variable] = (newPowers[variable] || 0) + power;
          if (newPowers[variable] === 0) {
            delete newPowers[variable];
          }
        }
        
        return new Monomial(newCoeff, newPowers);
      }

      /**
       * Divide two monomials: 6x¬≥y¬≤ / 2xy = 3x¬≤y
       */
      divide(other) {
        if (other.coefficient.isZero()) {
          throw new Error('Division by zero in monomial');
        }
        
        const newCoeff = this.coefficient.divide(other.coefficient);
        const newPowers = {...this.powers};
        
        for (const [variable, power] of Object.entries(other.powers)) {
          newPowers[variable] = (newPowers[variable] || 0) - power;
          if (newPowers[variable] === 0) {
            delete newPowers[variable];
          }
        }
        
        return new Monomial(newCoeff, newPowers);
      }

      /**
       * Check if two monomials have the same variables with same powers (like terms)
       */
      isSimilarTo(other) {
        const vars1 = Object.keys(this.powers).sort();
        const vars2 = Object.keys(other.powers).sort();
        
        if (vars1.length !== vars2.length) return false;
        
        for (let i = 0; i < vars1.length; i++) {
          if (vars1[i] !== vars2[i] || this.powers[vars1[i]] !== other.powers[vars2[i]]) {
            return false;
          }
        }
        
        return true;
      }

      isZero() {
        return this.coefficient.isZero();
      }

      isConstant() {
        return Object.keys(this.powers).length === 0;
      }

      negate() {
        return new Monomial(this.coefficient.negate(), this.powers);
      }

      /**
       * Evaluate monomial by substituting variables with numeric values
       * @param {Object} substitutions - Map of variable names to numeric values
       * @returns {Fraction} The evaluated result
       */
      evaluate(substitutions = {}) {
        let result = this.coefficient;
        
        for (const [variable, power] of Object.entries(this.powers)) {
          if (!(variable in substitutions)) {
            throw new Error(`Variable ${variable} not found in substitutions`);
          }
          const value = Fraction.from(substitutions[variable]);
          // Compute value^power
          let powerResult = new Fraction(1, 1);
          for (let i = 0; i < Math.abs(power); i++) {
            powerResult = powerResult.multiply(value);
          }
          if (power < 0) {
            powerResult = new Fraction(1, 1).divide(powerResult);
          }
          result = result.multiply(powerResult);
        }
        
        return result;
      }

      /**
       * Degree of the monomial (sum of all powers)
       */
      degree() {
        return Object.values(this.powers).reduce((sum, p) => sum + p, 0);
      }

      /**
       * Compare for sorting: by degree, then lexicographically by variables
       */
      compareTo(other) {
        const deg1 = this.degree();
        const deg2 = other.degree();
        if (deg1 !== deg2) return deg2 - deg1; // Higher degree first
        
        const vars1 = Object.keys(this.powers).sort();
        const vars2 = Object.keys(other.powers).sort();
        
        for (let i = 0; i < Math.max(vars1.length, vars2.length); i++) {
          const v1 = vars1[i] || '';
          const v2 = vars2[i] || '';
          if (v1 < v2) return -1;
          if (v1 > v2) return 1;
          if (v1 && v2) {
            const p1 = this.powers[v1];
            const p2 = other.powers[v2];
            if (p1 !== p2) return p2 - p1; // Higher power first
          }
        }
        
        return 0;
      }

      toString() {
        if (this.coefficient.isZero()) return '0';
        
        let str = '';
        
        // Handle coefficient
        const absCoeff = new Fraction(Math.abs(this.coefficient.num), this.coefficient.den);
        const isNegative = this.coefficient.num < 0;
        
        if (this.isConstant()) {
          return this.coefficient.toString();
        }
        
        if (!absCoeff.isOne()) {
          str = absCoeff.toString();
        }
        
        // Handle variables
        const sortedVars = Object.keys(this.powers).sort();
        for (const variable of sortedVars) {
          const power = this.powers[variable];
          str += variable;
          if (power !== 1) {
            str += `^${power}`;
          }
        }
        
        return (isNegative ? '-' : '') + (str || '1');
      }

      toLatex() {
        if (this.coefficient.isZero()) return '0';
        
        let str = '';
        
        // Handle coefficient
        const absCoeff = new Fraction(Math.abs(this.coefficient.num), this.coefficient.den);
        const isNegative = this.coefficient.num < 0;
        
        if (this.isConstant()) {
          return this.coefficient.toLatex();
        }
        
        if (!absCoeff.isOne()) {
          str = absCoeff.toLatex();
        }
        
        // Handle variables
        const sortedVars = Object.keys(this.powers).sort();
        for (const variable of sortedVars) {
          const power = this.powers[variable];
          str += variable;
          if (power !== 1) {
            str += `^{${power}}`;
          }
        }
        
        return (isNegative ? '-' : '') + (str || '1');
      }

      clone() {
        return new Monomial(this.coefficient, {...this.powers});
      }
    }

    /**
     * Polynomial: Represents a sum of monomials like 3x¬≤ + 2xy - 5y¬≤ + 7
     */
    class Polynomial {
      constructor(terms = []) {
        // terms is an array of Monomials
        this.terms = terms.filter(t => !t.isZero());
        this.simplify();
      }

      /**
       * Create a constant polynomial
       */
      static constant(value) {
        return new Polynomial([Monomial.constant(value)]);
      }

      /**
       * Create a polynomial from a single variable
       */
      static variable(name, coefficient = 1) {
        return new Polynomial([Monomial.variable(name, coefficient)]);
      }

      /**
       * Combine like terms and sort
       */
      simplify() {
        if (this.terms.length === 0) {
          this.terms = [Monomial.constant(0)];
          return;
        }

        // Group by similar terms
        const grouped = new Map();
        
        for (const term of this.terms) {
          const key = this.getMonomialKey(term);
          if (grouped.has(key)) {
            const existing = grouped.get(key);
            const newCoeff = existing.coefficient.add(term.coefficient);
            grouped.set(key, new Monomial(newCoeff, term.powers));
          } else {
            grouped.set(key, term.clone());
          }
        }
        
        // Filter out zero terms and sort
        this.terms = Array.from(grouped.values())
          .filter(t => !t.isZero())
          .sort((a, b) => a.compareTo(b));
        
        if (this.terms.length === 0) {
          this.terms = [Monomial.constant(0)];
        }
      }

      getMonomialKey(monomial) {
        const vars = Object.keys(monomial.powers).sort();
        return vars.map(v => `${v}^${monomial.powers[v]}`).join('*');
      }

      add(other) {
        if (!(other instanceof Polynomial)) {
          other = Polynomial.constant(other);
        }
        return new Polynomial([...this.terms, ...other.terms]);
      }

      subtract(other) {
        if (!(other instanceof Polynomial)) {
          other = Polynomial.constant(other);
        }
        return new Polynomial([...this.terms, ...other.terms.map(t => t.negate())]);
      }

      multiply(other) {
        if (!(other instanceof Polynomial)) {
          other = Polynomial.constant(other);
        }
        
        const newTerms = [];
        for (const t1 of this.terms) {
          for (const t2 of other.terms) {
            newTerms.push(t1.multiply(t2));
          }
        }
        
        return new Polynomial(newTerms);
      }

      negate() {
        return new Polynomial(this.terms.map(t => t.negate()));
      }

      isZero() {
        return this.terms.length === 1 && this.terms[0].isZero();
      }

      isConstant() {
        return this.terms.length === 1 && this.terms[0].isConstant();
      }

      /**
       * Get the constant term (coefficient of x^0*y^0*...)
       */
      getConstantTerm() {
        const constTerm = this.terms.find(t => t.isConstant());
        return constTerm ? constTerm.coefficient : new Fraction(0, 1);
      }

      /**
       * Evaluate polynomial by substituting variables
       */
      evaluate(substitutions = {}) {
        let result = new Fraction(0, 1);
        
        for (const term of this.terms) {
          result = result.add(term.evaluate(substitutions));
        }
        
        return result;
      }

      /**
       * Calculate GCD of two polynomials (simplified version for single variable)
       */
      static gcd(p1, p2) {
        // For now, return 1 (constant polynomial) - full polynomial GCD is complex
        // This is a placeholder for rational simplification
        if (p1.isConstant() && p2.isConstant()) {
          const g = new Fraction(1, 1);
          g.num = p1.terms[0].coefficient.num;
          g.den = p1.terms[0].coefficient.den;
          const g2 = new Fraction(1, 1);
          g2.num = p2.terms[0].coefficient.num;
          g2.den = p2.terms[0].coefficient.den;
          const gcdNum = g.gcd(Math.abs(g.num), Math.abs(g2.num));
          return Polynomial.constant(gcdNum);
        }
        return Polynomial.constant(1);
      }

      toString() {
        if (this.terms.length === 0) return '0';
        
        let str = '';
        for (let i = 0; i < this.terms.length; i++) {
          const term = this.terms[i];
          const termStr = term.toString();
          
          if (i === 0) {
            str = termStr;
          } else {
            if (termStr.startsWith('-')) {
              str += ' - ' + termStr.substring(1);
            } else {
              str += ' + ' + termStr;
            }
          }
        }
        
        return str || '0';
      }

      toLatex() {
        if (this.terms.length === 0) return '0';
        
        let str = '';
        for (let i = 0; i < this.terms.length; i++) {
          const term = this.terms[i];
          const termStr = term.toLatex();
          
          if (i === 0) {
            str = termStr;
          } else {
            if (termStr.startsWith('-')) {
              str += ' - ' + termStr.substring(1);
            } else {
              str += ' + ' + termStr;
            }
          }
        }
        
        return str || '0';
      }

      clone() {
        return new Polynomial(this.terms.map(t => t.clone()));
      }
    }

    /**
     * RationalExpression: Represents a rational function (polynomial / polynomial)
     * Example: (x¬≤ + 2x + 1) / (x - 1)
     */
    class RationalExpression {
      constructor(numerator, denominator) {
        this.numerator = numerator instanceof Polynomial ? numerator : Polynomial.constant(numerator);
        this.denominator = denominator instanceof Polynomial ? denominator : Polynomial.constant(denominator);
        
        if (this.denominator.isZero()) {
          throw new Error('Denominator cannot be zero in rational expression');
        }
        
        this.simplify();
      }

      /**
       * Simplify by canceling common factors
       * Handles constant denominators and common factors in polynomial coefficients
       */
      simplify() {
        // If numerator is zero, result is zero
        if (this.numerator.isZero()) {
          this.numerator = Polynomial.constant(0);
          this.denominator = Polynomial.constant(1);
          return;
        }

        // If denominator is constant 1, we're done
        if (this.denominator.isConstant() && this.denominator.terms[0].coefficient.isOne()) {
          return;
        }

        // If both are constants, simplify the fraction
        if (this.numerator.isConstant() && this.denominator.isConstant()) {
          const numCoeff = this.numerator.terms[0].coefficient;
          const denCoeff = this.denominator.terms[0].coefficient;
          const simplified = numCoeff.divide(denCoeff);
          this.numerator = Polynomial.constant(simplified);
          this.denominator = Polynomial.constant(1);
          return;
        }

        // If denominator is a constant and numerator is a polynomial,
        // divide all coefficients by the denominator
        if (this.denominator.isConstant()) {
          const denCoeff = this.denominator.terms[0].coefficient;
          if (!denCoeff.isOne()) {
            const newTerms = [];
            for (const term of this.numerator.terms) {
              const newCoeff = term.coefficient.divide(denCoeff);
              newTerms.push(new Monomial(newCoeff, term.powers));
            }
            this.numerator = new Polynomial(newTerms);
            this.denominator = Polynomial.constant(1);
          }
          return;
        }

        // If both numerator and denominator are single-term polynomials with same variables,
        // we can cancel the common factors
        if (this.numerator.terms.length === 1 && this.denominator.terms.length === 1) {
          const numTerm = this.numerator.terms[0];
          const denTerm = this.denominator.terms[0];
          
          // Divide coefficients
          const newCoeff = numTerm.coefficient.divide(denTerm.coefficient);
          
          // Cancel common variable powers
          const newPowers = {};
          const allVars = new Set([...Object.keys(numTerm.powers), ...Object.keys(denTerm.powers)]);
          
          for (const varName of allVars) {
            const numPower = numTerm.powers[varName] || 0;
            const denPower = denTerm.powers[varName] || 0;
            const netPower = numPower - denPower;
            if (netPower !== 0) {
              newPowers[varName] = netPower;
            }
          }
          
          // Check if any powers are negative (meaning they should stay in denominator)
          const hasNegativePowers = Object.values(newPowers).some(p => p < 0);
          
          if (!hasNegativePowers) {
            // Everything cancels to numerator
            this.numerator = new Polynomial([new Monomial(newCoeff, newPowers)]);
            this.denominator = Polynomial.constant(1);
          } else {
            // Split into positive (numerator) and negative (denominator) powers
            const numPowers = {};
            const denPowers = {};
            for (const [varName, power] of Object.entries(newPowers)) {
              if (power > 0) {
                numPowers[varName] = power;
              } else if (power < 0) {
                denPowers[varName] = -power;
              }
            }
            this.numerator = new Polynomial([new Monomial(newCoeff, numPowers)]);
            this.denominator = new Polynomial([new Monomial(Fraction.from(1), denPowers)]);
          }
        }
      }

      add(other) {
        if (!(other instanceof RationalExpression)) {
          other = new RationalExpression(Polynomial.constant(other), Polynomial.constant(1));
        }
        
        // a/b + c/d = (a*d + b*c) / (b*d)
        const newNum = this.numerator.multiply(other.denominator)
          .add(this.denominator.multiply(other.numerator));
        const newDen = this.denominator.multiply(other.denominator);
        
        return new RationalExpression(newNum, newDen);
      }

      subtract(other) {
        if (!(other instanceof RationalExpression)) {
          other = new RationalExpression(Polynomial.constant(other), Polynomial.constant(1));
        }
        
        // a/b - c/d = (a*d - b*c) / (b*d)
        const newNum = this.numerator.multiply(other.denominator)
          .subtract(this.denominator.multiply(other.numerator));
        const newDen = this.denominator.multiply(other.denominator);
        
        return new RationalExpression(newNum, newDen);
      }

      multiply(other) {
        if (!(other instanceof RationalExpression)) {
          other = new RationalExpression(Polynomial.constant(other), Polynomial.constant(1));
        }
        
        // (a/b) * (c/d) = (a*c) / (b*d)
        const newNum = this.numerator.multiply(other.numerator);
        const newDen = this.denominator.multiply(other.denominator);
        
        return new RationalExpression(newNum, newDen);
      }

      divide(other) {
        if (!(other instanceof RationalExpression)) {
          other = new RationalExpression(Polynomial.constant(other), Polynomial.constant(1));
        }
        
        if (other.numerator.isZero()) {
          throw new Error('Division by zero in rational expression');
        }
        
        // (a/b) / (c/d) = (a*d) / (b*c)
        const newNum = this.numerator.multiply(other.denominator);
        const newDen = this.denominator.multiply(other.numerator);
        
        return new RationalExpression(newNum, newDen);
      }

      negate() {
        return new RationalExpression(this.numerator.negate(), this.denominator);
      }

      isZero() {
        return this.numerator.isZero();
      }

      isConstant() {
        return this.numerator.isConstant() && this.denominator.isConstant();
      }

      evaluate(substitutions = {}) {
        const numValue = this.numerator.evaluate(substitutions);
        const denValue = this.denominator.evaluate(substitutions);
        
        if (denValue.isZero()) {
          throw new Error('Division by zero during evaluation');
        }
        
        return numValue.divide(denValue);
      }

      toString() {
        // If denominator is 1, just return numerator
        if (this.denominator.isConstant() && this.denominator.terms[0].coefficient.isOne()) {
          return this.numerator.toString();
        }
        
        // Special case: numerator is a constant fraction and denominator is a single variable term
        // e.g., (31/9) / (P) should display as 31/9P
        if (this.numerator.isConstant() && this.denominator.terms.length === 1) {
          const numCoeff = this.numerator.terms[0].coefficient;
          const denTerm = this.denominator.terms[0];
          
          // Check if denominator has only variables (coefficient is 1)
          if (denTerm.coefficient.isOne() && Object.keys(denTerm.powers).length > 0) {
            // Display as fraction with variables: e.g., "31/9P" or "5/2xy"
            const varPart = denTerm.toString().replace(/^1\s*/, ''); // Remove leading "1 " if present
            return numCoeff.toString() + varPart;
          }
          
          // If denominator has a coefficient, need to combine: (a/b) / (cV) = a/(bcV)
          if (!denTerm.coefficient.isOne()) {
            const newDen = numCoeff.den * denTerm.coefficient.num;
            const newNum = numCoeff.num * denTerm.coefficient.den;
            const varPart = Object.keys(denTerm.powers).length > 0 ? denTerm.toString().replace(/^[0-9\/-]+\s*/, '') : '';
            
            if (newDen === 1) {
              return newNum + varPart;
            }
            return `${newNum}/${newDen}${varPart}`;
          }
        }
        
        // Default: use parentheses
        return `(${this.numerator.toString()}) / (${this.denominator.toString()})`;
      }

      toLatex() {
        if (this.denominator.isConstant() && this.denominator.terms[0].coefficient.isOne()) {
          return this.numerator.toLatex();
        }
        return `\\frac{${this.numerator.toLatex()}}{${this.denominator.toLatex()}}`;
      }

      clone() {
        return new RationalExpression(this.numerator.clone(), this.denominator.clone());
      }
    }

    /**
     * SymbolicValue: Unified wrapper that can hold Fraction, Polynomial, or RationalExpression
     * Provides a common interface for all symbolic operations
     */
    class SymbolicValue {
      constructor(value) {
        if (value instanceof SymbolicValue) {
          this.value = value.value;
        } else if (value instanceof RationalExpression) {
          this.value = value;
        } else if (value instanceof Polynomial) {
          this.value = value;
        } else if (value instanceof Fraction) {
          this.value = value;
        } else if (typeof value === 'number') {
          this.value = Fraction.from(value);
        } else if (typeof value === 'string') {
          this.value = SymbolicValue.parse(value).value;
        } else {
          this.value = Fraction.from(0);
        }
      }

      static fromFraction(frac) {
        return new SymbolicValue(frac);
      }

      static fromPolynomial(poly) {
        return new SymbolicValue(poly);
      }

      static fromRational(rational) {
        return new SymbolicValue(rational);
      }

      add(other) {
        other = this.ensureSymbolicValue(other);
        
        const v1 = this.value;
        const v2 = other.value;
        
        if (v1 instanceof Fraction && v2 instanceof Fraction) {
          return new SymbolicValue(v1.add(v2));
        } else if (v1 instanceof Polynomial && v2 instanceof Polynomial) {
          return new SymbolicValue(v1.add(v2));
        } else if (v1 instanceof RationalExpression && v2 instanceof RationalExpression) {
          return new SymbolicValue(v1.add(v2));
        } else {
          // Convert to common type (RationalExpression is most general)
          const r1 = this.toRationalExpression();
          const r2 = other.toRationalExpression();
          return new SymbolicValue(r1.add(r2));
        }
      }

      subtract(other) {
        other = this.ensureSymbolicValue(other);
        
        const v1 = this.value;
        const v2 = other.value;
        
        if (v1 instanceof Fraction && v2 instanceof Fraction) {
          return new SymbolicValue(v1.subtract(v2));
        } else if (v1 instanceof Polynomial && v2 instanceof Polynomial) {
          return new SymbolicValue(v1.subtract(v2));
        } else if (v1 instanceof RationalExpression && v2 instanceof RationalExpression) {
          return new SymbolicValue(v1.subtract(v2));
        } else {
          const r1 = this.toRationalExpression();
          const r2 = other.toRationalExpression();
          return new SymbolicValue(r1.subtract(r2));
        }
      }

      multiply(other) {
        other = this.ensureSymbolicValue(other);
        
        const v1 = this.value;
        const v2 = other.value;
        
        if (v1 instanceof Fraction && v2 instanceof Fraction) {
          return new SymbolicValue(v1.multiply(v2));
        } else if (v1 instanceof Polynomial && v2 instanceof Polynomial) {
          return new SymbolicValue(v1.multiply(v2));
        } else if (v1 instanceof RationalExpression && v2 instanceof RationalExpression) {
          return new SymbolicValue(v1.multiply(v2));
        } else {
          const r1 = this.toRationalExpression();
          const r2 = other.toRationalExpression();
          return new SymbolicValue(r1.multiply(r2));
        }
      }

      divide(other) {
        other = this.ensureSymbolicValue(other);
        
        const v1 = this.value;
        const v2 = other.value;
        
        if (v1 instanceof Fraction && v2 instanceof Fraction) {
          return new SymbolicValue(v1.divide(v2));
        } else if (v1 instanceof Polynomial && v2 instanceof Polynomial) {
          return new SymbolicValue(new RationalExpression(v1, v2));
        } else if (v1 instanceof RationalExpression && v2 instanceof RationalExpression) {
          return new SymbolicValue(v1.divide(v2));
        } else {
          const r1 = this.toRationalExpression();
          const r2 = other.toRationalExpression();
          return new SymbolicValue(r1.divide(r2));
        }
      }

      negate() {
        if (this.value instanceof Fraction) {
          return new SymbolicValue(this.value.negate());
        } else if (this.value instanceof Polynomial) {
          return new SymbolicValue(this.value.negate());
        } else if (this.value instanceof RationalExpression) {
          return new SymbolicValue(this.value.negate());
        }
        return new SymbolicValue(Fraction.from(0));
      }

      isZero() {
        return this.value.isZero();
      }

      isOne() {
        if (this.value instanceof Fraction) {
          return this.value.isOne();
        }
        if (this.value instanceof Polynomial) {
          return this.value.isConstant() && this.value.terms[0].coefficient.isOne();
        }
        return false;
      }

      isNumeric() {
        return this.value instanceof Fraction;
      }

      isConstant() {
        if (this.value instanceof Fraction) return true;
        return this.value.isConstant();
      }

      toRationalExpression() {
        if (this.value instanceof RationalExpression) {
          return this.value;
        } else if (this.value instanceof Polynomial) {
          return new RationalExpression(this.value, Polynomial.constant(1));
        } else if (this.value instanceof Fraction) {
          return new RationalExpression(Polynomial.constant(this.value), Polynomial.constant(1));
        }
        return new RationalExpression(Polynomial.constant(0), Polynomial.constant(1));
      }

      toPolynomial() {
        if (this.value instanceof Polynomial) {
          return this.value;
        } else if (this.value instanceof Fraction) {
          return Polynomial.constant(this.value);
        }
        throw new Error('Cannot convert RationalExpression to Polynomial');
      }

      toFraction() {
        if (this.value instanceof Fraction) {
          return this.value;
        }
        throw new Error('Cannot convert non-numeric value to Fraction');
      }

      evaluate(substitutions = {}) {
        if (this.value instanceof Fraction) {
          return this.value;
        }
        return this.value.evaluate(substitutions);
      }

      toString() {
        return this.value.toString();
      }

      toLatex() {
        return this.value.toLatex();
      }

      ensureSymbolicValue(other) {
        if (other instanceof SymbolicValue) {
          return other;
        }
        return new SymbolicValue(other);
      }

      clone() {
        if (this.value instanceof Fraction) {
          return new SymbolicValue(new Fraction(this.value.num, this.value.den));
        }
        return new SymbolicValue(this.value.clone());
      }

      /**
       * Simplify the symbolic value
       * For RationalExpression, this will cancel common factors
       * Returns a new simplified SymbolicValue
       */
      simplify() {
        if (this.value instanceof RationalExpression) {
          const simplified = this.value.clone();
          simplified.simplify();
          return new SymbolicValue(simplified);
        } else if (this.value instanceof Fraction) {
          // Fractions are already simplified in the Fraction class
          return new SymbolicValue(this.value);
        } else if (this.value instanceof Polynomial) {
          // Polynomials are already simplified
          return new SymbolicValue(this.value.clone());
        }
        return this;
      }

      /**
       * Parse a string into a SymbolicValue
       * Supports: numbers, variables (x, y, z), +, -, *, /, ^, parentheses
       * Examples: "2", "x", "2x", "x+1", "x^2-1", "(x+1)/(x-1)", "2x+3y"
       */
      static parse(str) {
        str = str.trim().replace(/\s+/g, '');
        
        // Handle division (lowest precedence)
        const divIndex = SymbolicValue.findTopLevelOperator(str, '/');
        if (divIndex !== -1) {
          const left = SymbolicValue.parse(str.substring(0, divIndex));
          const right = SymbolicValue.parse(str.substring(divIndex + 1));
          return left.divide(right);
        }
        
        // Handle addition and subtraction
        const addSubIndex = SymbolicValue.findTopLevelOperator(str, '+-');
        if (addSubIndex !== -1) {
          const op = str[addSubIndex];
          const left = SymbolicValue.parse(str.substring(0, addSubIndex));
          const right = SymbolicValue.parse(str.substring(addSubIndex + 1));
          return op === '+' ? left.add(right) : left.subtract(right);
        }
        
        // Handle multiplication
        const multIndex = SymbolicValue.findTopLevelOperator(str, '*');
        if (multIndex !== -1) {
          const left = SymbolicValue.parse(str.substring(0, multIndex));
          const right = SymbolicValue.parse(str.substring(multIndex + 1));
          return left.multiply(right);
        }
        
        // Handle implied multiplication (e.g., "2x" or "xy")
        const impliedMult = SymbolicValue.findImpliedMultiplication(str);
        if (impliedMult !== -1) {
          const left = SymbolicValue.parse(str.substring(0, impliedMult));
          const right = SymbolicValue.parse(str.substring(impliedMult));
          return left.multiply(right);
        }
        
        // Handle parentheses
        if (str.startsWith('(') && str.endsWith(')')) {
          return SymbolicValue.parse(str.substring(1, str.length - 1));
        }
        
        // Handle exponentiation (e.g., "x^2")
        const expIndex = str.indexOf('^');
        if (expIndex !== -1) {
          const base = str.substring(0, expIndex);
          const expStr = str.substring(expIndex + 1);
          const exponent = parseInt(expStr);
          
          if (isNaN(exponent)) {
            throw new Error(`Invalid exponent: ${expStr}`);
          }
          
          const baseValue = SymbolicValue.parse(base);
          let result = new SymbolicValue(1);
          for (let i = 0; i < Math.abs(exponent); i++) {
            result = result.multiply(baseValue);
          }
          if (exponent < 0) {
            result = new SymbolicValue(1).divide(result);
          }
          return result;
        }
        
        // Handle negative numbers/expressions
        if (str.startsWith('-')) {
          return SymbolicValue.parse(str.substring(1)).negate();
        }
        
        // Handle numeric literals
        if (/^[0-9.]+$/.test(str)) {
          const num = parseFloat(str);
          return new SymbolicValue(Fraction.from(num));
        }
        
        // Handle single variable (x, y, z, etc.)
        if (/^[a-zA-Z]$/.test(str)) {
          return new SymbolicValue(Polynomial.variable(str));
        }
        
        throw new Error(`Unable to parse: ${str}`);
      }

      /**
       * Find the index of a top-level operator (not inside parentheses)
       * Returns rightmost occurrence for left-to-right evaluation
       */
      static findTopLevelOperator(str, operators) {
        let depth = 0;
        let lastIndex = -1;
        
        for (let i = str.length - 1; i >= 0; i--) {
          const char = str[i];
          
          if (char === ')') {
            depth++;
          } else if (char === '(') {
            depth--;
          } else if (depth === 0 && operators.includes(char)) {
            // For subtraction, make sure it's not a negative sign at the start
            if (char === '-' && i === 0) {
              continue;
            }
            // Make sure it's not a negative sign after an operator
            if (char === '-' && i > 0 && '+-*/^('.includes(str[i-1])) {
              continue;
            }
            return i;
          }
        }
        
        return lastIndex;
      }

      /**
       * Find implied multiplication (e.g., "2x" -> multiply 2 and x)
       */
      static findImpliedMultiplication(str) {
        // Look for digit followed by letter, or letter followed by letter
        for (let i = 0; i < str.length - 1; i++) {
          const curr = str[i];
          const next = str[i + 1];
          
          // Number followed by letter
          if (/[0-9]/.test(curr) && /[a-zA-Z]/.test(next)) {
            return i + 1;
          }
          
          // Letter followed by letter (for multivariate like "xy")
          if (/[a-zA-Z]/.test(curr) && /[a-zA-Z]/.test(next) && curr !== next) {
            return i + 1;
          }
        }
        
        return -1;
      }
    }

    // ============================================================================
    // END SYMBOLIC ALGEBRA LAYER
    // ============================================================================

    function calculateDeterminantCalc(A) {
      const n = A.length;

      if (n !== A[0].length) {
        throw new Error('Matrix must be square to calculate determinant');
      }

      return calcDet(A);
    }

    // Calculate determinant using cofactor expansion (for cross-checking)
    function calculateDeterminantCofactor(A) {
      const n = A.length;
      if (n === 1) return A[0][0];
      if (n === 2) return A[0][0] * A[1][1] - A[0][1] * A[1][0];

      let det = 0;
      for (let j = 0; j < n; j++) {
        det += Math.pow(-1, j) * A[0][j] * calculateDeterminantCofactor(getMinor(A, 0, j));
      }
      return det;
    }

    // Calculate inverse using cofactor method (for cross-checking)
    function calculateInverseCofactor(A) {
      const n = A.length;
      if (n !== A[0].length) {
        throw new Error('Matrix must be square to calculate inverse');
      }

      const det = calculateDeterminantCofactor(A);
      if (Math.abs(det) < 1e-10) {
        throw new Error('Matrix is singular and has no inverse');
      }

      if (n === 1) {
        return [[1 / A[0][0]]];
      }

      if (n === 2) {
        return [
          [A[1][1] / det, -A[0][1] / det],
          [-A[1][0] / det, A[0][0] / det]
        ];
      }

      const adjugate = [];
      for (let i = 0; i < n; i++) {
        adjugate[i] = [];
        for (let j = 0; j < n; j++) {
          const minor = getMinor(A, j, i);
          const cofactor = Math.pow(-1, i + j) * calculateDeterminantCofactor(minor);
          adjugate[i][j] = cofactor / det;
        }
      }

      return adjugate;
    }

    function calculateInverseCalc(A) {
      const n = A.length;

      if (n !== A[0].length) {
        throw new Error('Matrix must be square to calculate inverse');
      }

      // Create augmented matrix with SymbolicValue [A | I]
      const augmented = Array(n).fill().map(() => Array(2 * n).fill(null));
      const rowSwaps = [];

      // Initialize - convert to SymbolicValue
      for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
          augmented[i][j] = A[i][j] instanceof SymbolicValue ? A[i][j] : new SymbolicValue(A[i][j]);
        }
        // Identity matrix on right
        for (let j = 0; j < n; j++) {
          augmented[i][n + j] = new SymbolicValue(i === j ? 1 : 0);
        }
      }

      // Gauss-Jordan elimination with row swapping strategy
      for (let col = 0; col < n; col++) {
        // Find best pivot: prefer non-zero values
        let bestRow = col;
        let found = false;

        for (let row = col; row < n; row++) {
          const val = augmented[row][col];
          if (!val.isZero()) {
            bestRow = row;
            found = true;
            // Prefer numeric constants for simpler pivots
            if (val.isNumeric()) {
              break;
            }
          }
        }

        // Check if we found a non-zero pivot
        if (!found || augmented[bestRow][col].isZero()) {
          throw new Error('Matrix is singular and has no inverse');
        }

        // Swap rows if needed
        if (bestRow !== col) {
          [augmented[col], augmented[bestRow]] = [augmented[bestRow], augmented[col]];
          rowSwaps.push({ from: bestRow, to: col });
        }

        // Normalize pivot row to make pivot = 1
        const pivotValue = augmented[col][col];
        if (!pivotValue.isOne()) {
          for (let j = 0; j < 2 * n; j++) {
            augmented[col][j] = augmented[col][j].divide(pivotValue);
          }
        }

        // Eliminate other entries in this column
        for (let row = 0; row < n; row++) {
          if (row !== col) {
            const factor = augmented[row][col];
            if (!factor.isZero()) {
              for (let j = 0; j < 2 * n; j++) {
                augmented[row][j] = augmented[row][j].subtract(factor.multiply(augmented[col][j]));
              }
            }
          }
        }
      }

      // Extract inverse matrix (keep as SymbolicValue)
      const inverse = [];
      for (let i = 0; i < n; i++) {
        inverse[i] = [];
        for (let j = 0; j < n; j++) {
          inverse[i][j] = augmented[i][n + j];
        }
      }

      // Store metadata for display
      inverse._rowSwaps = rowSwaps;

      return inverse;
    }
    

    // ============================================================================
    // SYMBOLIC ALGEBRA TEST FUNCTIONS
    // ============================================================================

    function testSymbolicParsing() {
      try {
        const tests = [
          { input: '5', expected: '5' },
          { input: 'x', expected: 'x' },
          { input: '2x', expected: '2x' },
          { input: 'x+1', expected: 'x + 1' },
          { input: 'x^2', expected: 'x^2' },
          { input: '2x^2+3x+1', expected: '2x^2 + 3x + 1' },
          { input: 'x*y', expected: 'xy' },
          { input: '(x+1)*(x-1)', expected: 'x^2 - 1' },
        ];

        let allPassed = true;
        let details = [];

        for (const test of tests) {
          try {
            const parsed = SymbolicValue.parse(test.input);
            const result = parsed.toString();
            details.push(`${test.input} ‚Üí ${result}`);
          } catch (e) {
            allPassed = false;
            details.push(`${test.input} ‚Üí ERROR: ${e.message}`);
          }
        }

        return {
          name: 'Symbolic Expression Parsing',
          passed: allPassed,
          expected: 'All expressions parse correctly',
          actual: details.join('; ')
        };
      } catch (error) {
        return {
          name: 'Symbolic Expression Parsing',
          passed: false,
          expected: 'All expressions parse correctly',
          actual: `Error: ${error.message}`
        };
      }
    }

    function testPolynomialArithmetic() {
      try {
        // Test addition: (x + 1) + (x + 2) = 2x + 3
        const p1 = SymbolicValue.parse('x+1');
        const p2 = SymbolicValue.parse('x+2');
        const sum = p1.add(p2);
        
        // Test multiplication: (x + 1) * (x + 2) = x¬≤ + 3x + 2
        const product = p1.multiply(p2);
        
        // Test subtraction: (x + 2) - (x + 1) = 1
        const diff = p2.subtract(p1);

        return {
          name: 'Polynomial Arithmetic',
          passed: true,
          expected: 'Addition, multiplication, subtraction work correctly',
          actual: `(x+1)+(x+2)=${sum.toString()}; (x+1)*(x+2)=${product.toString()}; (x+2)-(x+1)=${diff.toString()}`
        };
      } catch (error) {
        return {
          name: 'Polynomial Arithmetic',
          passed: false,
          expected: 'Addition, multiplication, subtraction work correctly',
          actual: `Error: ${error.message}`
        };
      }
    }

    function testPolynomialExpansion() {
      try {
        // Test (x+1)^2 = x^2 + 2x + 1
        const x1 = SymbolicValue.parse('x+1');
        const squared = x1.multiply(x1);
        const result = squared.toString();
        
        // Expected: x^2 + 2x + 1
        const hasX2 = result.includes('x^2');
        const has2x = result.includes('2x');
        const has1 = result.includes('1');
        
        return {
          name: 'Polynomial Expansion (x+1)¬≤',
          passed: hasX2 && has2x && has1,
          expected: 'x^2 + 2x + 1',
          actual: result
        };
      } catch (error) {
        return {
          name: 'Polynomial Expansion (x+1)¬≤',
          passed: false,
          expected: 'x^2 + 2x + 1',
          actual: `Error: ${error.message}`
        };
      }
    }

    function testRationalSimplification() {
      try {
        // Test 6/2 = 3
        const r1 = SymbolicValue.parse('6/2');
        const simplified1 = r1.toString();
        
        // Test (2x)/(4) should simplify
        const r2 = SymbolicValue.parse('(2*x)/4');
        const simplified2 = r2.toString();

        return {
          name: 'Rational Expression Simplification',
          passed: true,
          expected: 'Rationals simplify when possible',
          actual: `6/2 = ${simplified1}; (2x)/4 = ${simplified2}`
        };
      } catch (error) {
        return {
          name: 'Rational Expression Simplification',
          passed: false,
          expected: 'Rationals simplify when possible',
          actual: `Error: ${error.message}`
        };
      }
    }

    function testSymbolicEvaluation() {
      try {
        // Test evaluation: x^2 + 2x + 1 at x=3 should be 16
        const expr = SymbolicValue.parse('x^2+2*x+1');
        const result = expr.evaluate({ x: 3 });
        const expected = new Fraction(16, 1);
        
        const passed = result.num === expected.num && result.den === expected.den;

        return {
          name: 'Symbolic Expression Evaluation',
          passed: passed,
          expected: '16',
          actual: result.toString()
        };
      } catch (error) {
        return {
          name: 'Symbolic Expression Evaluation',
          passed: false,
          expected: '16',
          actual: `Error: ${error.message}`
        };
      }
    }

    function testMultivariatePolynomials() {
      try {
        // Test xy + yz + xz
        const p1 = SymbolicValue.parse('x*y');
        const p2 = SymbolicValue.parse('y*z');
        const p3 = SymbolicValue.parse('x*z');
        const sum = p1.add(p2).add(p3);
        
        // Evaluate at x=1, y=2, z=3: should be 1*2 + 2*3 + 1*3 = 11
        const result = sum.evaluate({ x: 1, y: 2, z: 3 });
        const expected = new Fraction(11, 1);
        
        const passed = result.num === expected.num && result.den === expected.den;

        return {
          name: 'Multivariate Polynomial Operations',
          passed: passed,
          expected: 'xy + yz + xz at (1,2,3) = 11',
          actual: `${sum.toString()} = ${result.toString()}`
        };
      } catch (error) {
        return {
          name: 'Multivariate Polynomial Operations',
          passed: false,
          expected: 'xy + yz + xz at (1,2,3) = 11',
          actual: `Error: ${error.message}`
        };
      }
    }

    function testSymbolicDivision() {
      try {
        // Test (x^2 - 1) / (x - 1) should work
        const num = SymbolicValue.parse('x^2-1');
        const den = SymbolicValue.parse('x-1');
        const rational = num.divide(den);
        
        // Evaluate at x=2: (4-1)/(2-1) = 3
        const result = rational.evaluate({ x: 2 });
        const expected = new Fraction(3, 1);
        
        const passed = result.num === expected.num && result.den === expected.den;

        return {
          name: 'Symbolic Division',
          passed: passed,
          expected: '(x¬≤-1)/(x-1) at x=2 = 3',
          actual: `${rational.toString()} at x=2 = ${result.toString()}`
        };
      } catch (error) {
        return {
          name: 'Symbolic Division',
          passed: false,
          expected: '(x¬≤-1)/(x-1) at x=2 = 3',
          actual: `Error: ${error.message}`
        };
      }
    }

    function testSymbolicNegation() {
      try {
        const expr = SymbolicValue.parse('x+1');
        const negated = expr.negate();
        const result = negated.toString();
        
        // Should contain negative signs
        const passed = result.includes('-');

        return {
          name: 'Symbolic Negation',
          passed: passed,
          expected: '-(x+1)',
          actual: result
        };
      } catch (error) {
        return {
          name: 'Symbolic Negation',
          passed: false,
          expected: '-(x+1)',
          actual: `Error: ${error.message}`
        };
      }
    }

    function testSymbolicMatrix2x2() {
      try {
        // Test 2x2 matrix with symbolic entries
        const A = [
          [new SymbolicValue(1), SymbolicValue.parse('x')],
          [new SymbolicValue(0), new SymbolicValue(1)]
        ];
        
        const B = [
          [new SymbolicValue(1), new SymbolicValue(0)],
          [SymbolicValue.parse('y'), new SymbolicValue(1)]
        ];
        
        // Multiply A * B
        const result = multiplyMatricesCalc(A, B);
        
        // Result should be [[1+xy, x], [y, 1]]
        const r00 = result[0][0].toString();
        const r01 = result[0][1].toString();
        const r10 = result[1][0].toString();
        const r11 = result[1][1].toString();

        return {
          name: 'Symbolic Matrix Multiplication 2x2',
          passed: true,
          expected: 'Matrix with symbolic entries multiplies correctly',
          actual: `[[${r00}, ${r01}], [${r10}, ${r11}]]`
        };
      } catch (error) {
        return {
          name: 'Symbolic Matrix Multiplication 2x2',
          passed: false,
          expected: 'Matrix with symbolic entries multiplies correctly',
          actual: `Error: ${error.message}`
        };
      }
    }

    function testSymbolicDeterminant2x2() {
      try {
        // Determinant of [[x, 1], [1, x]] should be x^2 - 1
        const A = [
          [SymbolicValue.parse('x'), new SymbolicValue(1)],
          [new SymbolicValue(1), SymbolicValue.parse('x')]
        ];
        
        const det = calcDet(A);
        const result = det.toString();
        
        // Evaluate at x=2: 2^2 - 1 = 3
        const evaluated = det.evaluate({ x: 2 });
        const passed = evaluated.num === 3 && evaluated.den === 1;

        return {
          name: 'Symbolic Matrix Determinant 2x2',
          passed: passed,
          expected: 'det([[x,1],[1,x]]) = x^2-1, at x=2 gives 3',
          actual: `${result}, at x=2 gives ${evaluated.toString()}`
        };
      } catch (error) {
        return {
          name: 'Symbolic Matrix Determinant 2x2',
          passed: false,
          expected: 'det([[x,1],[1,x]]) = x^2-1, at x=2 gives 3',
          actual: `Error: ${error.message}`
        };
      }
    }

    function runSymbolicTests() {
      const resultDiv = document.getElementById('result');
      const container = document.getElementById('processContainer');
      
      resultDiv.style.display = 'block';
      container.innerHTML = '';
      
      const testResults = [];
      
      // Parsing Tests
      testResults.push(testSymbolicParsing());
      
      // Arithmetic Tests
      testResults.push(testPolynomialArithmetic());
      testResults.push(testPolynomialExpansion());
      testResults.push(testMultivariatePolynomials());
      
      // Rational Expression Tests
      testResults.push(testRationalSimplification());
      testResults.push(testSymbolicDivision());
      
      // Evaluation Tests
      testResults.push(testSymbolicEvaluation());
      
      // Other Tests
      testResults.push(testSymbolicNegation());
      
      // Matrix Tests with Symbolic Values
      testResults.push(testSymbolicMatrix2x2());
      testResults.push(testSymbolicDeterminant2x2());
      
      displaySymbolicTestResults(testResults);
    }

    function displaySymbolicTestResults(results) {
      const container = document.getElementById('processContainer');
      
      const heading = document.createElement('h4');
      heading.textContent = 'Symbolic Algebra Test Results';
      heading.style.marginBottom = '20px';
      container.appendChild(heading);
      
      const passedCount = results.filter(r => r.passed).length;
      const totalCount = results.length;
      
      const summary = document.createElement('div');
      summary.style.padding = '15px';
      summary.style.marginBottom = '20px';
      summary.style.borderRadius = '8px';
      summary.style.fontWeight = 'bold';
      summary.style.backgroundColor = passedCount === totalCount ? '#d4edda' : '#f8d7da';
      summary.style.color = passedCount === totalCount ? '#155724' : '#721c24';
      summary.textContent = `Tests Passed: ${passedCount}/${totalCount}`;
      container.appendChild(summary);
      
      results.forEach(result => {
        const testDiv = document.createElement('div');
        testDiv.style.padding = '15px';
        testDiv.style.marginBottom = '10px';
        testDiv.style.borderRadius = '8px';
        testDiv.style.backgroundColor = result.passed ? '#d4edda' : '#f8d7da';
        testDiv.style.border = result.passed ? '2px solid #28a745' : '2px solid #dc3545';
        
        const testName = document.createElement('div');
        testName.style.fontWeight = 'bold';
        testName.style.marginBottom = '10px';
        testName.style.color = result.passed ? '#155724' : '#721c24';
        testName.textContent = `${result.passed ? '‚úÖ' : '‚ùå'} ${result.name}`;
        testDiv.appendChild(testName);
        
        const expectedDiv = document.createElement('div');
        expectedDiv.style.marginBottom = '5px';
        expectedDiv.innerHTML = `<strong>Expected:</strong> ${result.expected}`;
        testDiv.appendChild(expectedDiv);
        
        const actualDiv = document.createElement('div');
        actualDiv.innerHTML = `<strong>Actual:</strong> ${result.actual}`;
        testDiv.appendChild(actualDiv);
        
        container.appendChild(testDiv);
      });
    }

    // ============================================================================
    // END SYMBOLIC ALGEBRA TEST FUNCTIONS
    // ============================================================================
    
    // Matrix Test Functions
    function runMatrixTests() {
      const resultDiv = document.getElementById('result');
      const container = document.getElementById('processContainer');
      
      resultDiv.style.display = 'block';
      container.innerHTML = '';
      
      const testResults = [];
      
      // Matrix Multiplication Tests
      testResults.push(testMatrixMultiplication2x2());
      testResults.push(testMatrixMultiplication2x3_3x2());
      testResults.push(testMatrixMultiplicationIdentity());
      
      // Determinant Tests
      testResults.push(testDeterminant2x2());
      testResults.push(testDeterminant3x3());
      testResults.push(testDeterminantIdentity());
      
      // Matrix Inverse Tests
      testResults.push(testMatrixInverse2x2());
      testResults.push(testMatrixInverseIdentity());
      testResults.push(testMatrixInverseProperty());
      
      // Display results
      displayMatrixTestResults(testResults);
    }








    
    function testMatrixMultiplication2x2() {
      const A = [[1, 2], [3, 4]];
      const B = [[5, 6], [7, 8]];
      const result = multiplyMatricesCalc(A, B);
      const expected = [[19, 22], [43, 50]];
      const passed = matricesEqual(result, expected);
      return {
        name: 'Matrix Multiplication 2x2 √ó 2x2',
        passed: passed,
        expected: expected,
        actual: result
      };
    }
    
    function testMatrixMultiplication2x3_3x2() {
      const A = [[1, 2, 3], [4, 5, 6]];
      const B = [[7, 8], [9, 10], [11, 12]];
      const result = multiplyMatricesCalc(A, B);
      const expected = [[58, 64], [139, 154]];
      const passed = matricesEqual(result, expected);
      return {
        name: 'Matrix Multiplication 2x3 √ó 3x2',
        passed: passed,
        expected: expected,
        actual: result
      };
    }
    
    function testMatrixMultiplicationIdentity() {
      const A = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];
      const I = [[1, 0, 0], [0, 1, 0], [0, 0, 1]];
      const result = multiplyMatricesCalc(A, I);
      const passed = matricesEqual(result, A);
      return {
        name: 'Matrix Multiplication Identity: A √ó I = A',
        passed: passed,
        expected: 'Equal to original matrix',
        actual: passed ? 'Equal' : 'Not equal'
      };
    }



    
    function testDeterminant2x2() {
      const A = [[1, 2], [3, 4]];
      const result = calcDet(A);
      const expected = -2; // 1*4 - 2*3 = 4 - 6 = -2
      const passed = Math.abs(result - expected) < 1e-10;
      return {
        name: 'Determinant 2x2 Matrix',
        passed: passed,
        expected: expected,
        actual: result
      };
    }
    
    function testDeterminant3x3() {
      const A = [[1, 0, 2], [3, 2, 1], [4, 0, 3]];
      const result = calcDet(A);
      const expected = -10; // 1*(2*3-1*0) - 0*(3*3-1*4) + 2*(3*0-2*4) = 6 + 0 - 16 = -10
      const passed = Math.abs(result - expected) < 1e-10;
      return {
        name: 'Determinant 3x3 Matrix',
        passed: passed,
        expected: expected,
        actual: result
      };
    }
    
    function testDeterminantIdentity() {
      const I = [[1, 0, 0], [0, 1, 0], [0, 0, 1]];
      const result = calcDet(I);
      const passed = Math.abs(result - 1) < 1e-10;
      return {
        name: 'Determinant Identity Matrix = 1',
        passed: passed,
        expected: 1,
        actual: result
      };
    }
    
    function testMatrixInverse2x2() {
      const A = [[1, 2], [3, 4]];
      const result = calculateInverseCalc(A);
      const expected = [[-2, 1], [1.5, -0.5]]; // (1/(1*4-2*3)) * [4, -2; -3, 1] = (1/-2) * [4, -2; -3, 1] = [-2, 1; 1.5, -0.5]
      const passed = matricesEqual(result, expected);
      return {
        name: 'Matrix Inverse 2x2',
        passed: passed,
        expected: expected,
        actual: result
      };
    }
    
    function testMatrixInverseIdentity() {
      const I = [[1, 0], [0, 1]];
      const result = calculateInverseCalc(I);
      const passed = matricesEqual(result, I);
      return {
        name: 'Matrix Inverse Identity = Itself',
        passed: passed,
        expected: 'Equal to identity',
        actual: passed ? 'Equal' : 'Not equal'
      };
    }
    
    function testMatrixInverseProperty() {
      const A = [[2, 1], [1, 1]];
      const A_inv = calculateInverseCalc(A);
      const product = multiplyMatricesCalc(A, A_inv);
      const I = [[1, 0], [0, 1]];
      const passed = matricesEqual(product, I, 1e-8); // Allow for small floating point errors
      return {
        name: 'Matrix Inverse Property: A √ó A‚Åª¬π = I',
        passed: passed,
        expected: 'Equal to identity matrix',
        actual: passed ? 'Equal' : 'Not equal'
      };
    }
    
    function matricesEqual(A, B, tolerance = 1e-10) {
      if (A.length !== B.length || A[0].length !== B[0].length) return false;
      for (let i = 0; i < A.length; i++) {
        for (let j = 0; j < A[0].length; j++) {
          if (Math.abs(A[i][j] - B[i][j]) > tolerance) return false;
        }
      }
      return true;
    }
    
    function displayMatrixTestResults(results) {
      const resultContent = document.getElementById('processContainer');
      
      const resultsDiv = document.createElement('div');
      resultsDiv.className = 'test-results';
      
      const header = document.createElement('h3');
      header.textContent = 'Matrix Operation Tests';
      header.style.color = '#667eea';
      header.style.marginBottom = '20px';
      resultsDiv.appendChild(header);
      
      let passedCount = 0;
      results.forEach(result => {
        if (result.passed) passedCount++;
        
        const testDiv = document.createElement('div');
        testDiv.className = `test-result ${result.passed ? 'test-pass' : 'test-fail'}`;
        
        const nameSpan = document.createElement('span');
        nameSpan.className = 'test-name';
        nameSpan.textContent = result.name;
        
        const statusSpan = document.createElement('span');
        statusSpan.className = 'test-status';
        statusSpan.textContent = result.passed ? 'PASS' : 'FAIL';
        
        testDiv.appendChild(nameSpan);
        testDiv.appendChild(statusSpan);
        
        if (!result.passed) {
          const detailsDiv = document.createElement('div');
          detailsDiv.style.marginTop = '8px';
          detailsDiv.style.fontSize = '14px';
          if (Array.isArray(result.expected) && Array.isArray(result.expected[0])) {
            // Matrix display
            detailsDiv.innerHTML = `Expected:<br>${displayMatrix(result.expected).outerHTML}<br>Actual:<br>${displayMatrix(result.actual).outerHTML}`;
          } else {
            detailsDiv.innerHTML = `Expected: ${Array.isArray(result.expected) ? '[' + result.expected.map(row => '[' + row.join(', ') + ']').join('; ') + ']' : result.expected}<br>Actual: ${Array.isArray(result.actual) ? '[' + result.actual.map(row => '[' + row.join(', ') + ']').join('; ') + ']' : result.actual}`;
          }
          testDiv.appendChild(detailsDiv);
        }
        
        resultsDiv.appendChild(testDiv);
      });
      
      const summaryDiv = document.createElement('div');
      summaryDiv.style.marginTop = '20px';
      summaryDiv.style.padding = '15px';
      summaryDiv.style.background = passedCount === results.length ? '#d4edda' : '#f8d7da';
      summaryDiv.style.borderRadius = '8px';
      summaryDiv.style.textAlign = 'center';
      summaryDiv.style.fontWeight = '600';
      summaryDiv.innerHTML = `Tests Passed: ${passedCount}/${results.length}`;
      resultsDiv.appendChild(summaryDiv);
      
      resultContent.appendChild(resultsDiv);
    }
    
    updateMatrices();
  </script>
</body>
</html>