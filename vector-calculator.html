<!-- ********************************************************************** -->
<!--                                                                        -->
<!--  vector-calculator.html                            TTTTTTTT SSSSSSS II -->
<!--                                                       TT    SS      II -->
<!--  By: st93642@students.tsi.lv                          TT    SSSSSSS II -->
<!--                                                       TT         SS II -->
<!--  Created: Nov 18 2025 00:31 st93642                   TT    SSSSSSS II -->
<!--  Updated: Dec 17 2025 19:37 st93642                                    -->
<!--                                                                        -->
<!--   Transport and Telecommunication Institute - Riga, Latvia             -->
<!--                       https://tsi.lv                                   -->
<!-- ********************************************************************** -->

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Vector Calculator</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <script src="https://www.geogebra.org/apps/deployggb.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }
    
    .container {
      max-width: 1400px;
      margin: 0 auto;
      background: white;
      border-radius: 20px;
      padding: 30px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
    }
    
    h1 {
      text-align: center;
      color: #667eea;
      margin-bottom: 10px;
      font-size: 2.5em;
    }
    
    .subtitle {
      text-align: center;
      color: #764ba2;
      margin-bottom: 30px;
      font-size: 0.95em;
      opacity: 0.8;
    }
    
    .section-header {
      font-size: 1.3em;
      color: #764ba2;
      margin-top: 25px;
      margin-bottom: 15px;
      font-weight: 600;
      border-bottom: 2px solid #667eea;
      padding-bottom: 8px;
    }
    
    .controls {
      display: flex;
      gap: 20px;
      margin-bottom: 25px;
      flex-wrap: wrap;
    }
    
    .control-group {
      flex: 1;
      min-width: 150px;
    }
    
    label {
      display: block;
      margin-bottom: 8px;
      color: #555;
      font-weight: 600;
      font-size: 0.95em;
    }
    
    select, input {
      width: 100%;
      padding: 10px;
      border: 2px solid #e0e0e0;
      border-radius: 8px;
      font-size: 15px;
      transition: border-color 0.3s;
    }
    
    select:focus, input:focus {
      outline: none;
      border-color: #667eea;
    }
    
    .vector-input-group {
      background: #f8f9fa;
      padding: 20px;
      border-radius: 12px;
      border: 2px solid #e0e0e0;
      margin-bottom: 15px;
    }
    
    .vector-input-group h4 {
      color: #667eea;
      margin-bottom: 12px;
      font-size: 0.95em;
    }
    
    .vector-inputs {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    
    .vector-input-field {
      flex: 1;
      min-width: 80px;
    }
    
    .vector-input-field input {
      width: 100%;
      padding: 10px;
      font-size: 14px;
      text-align: center;
      font-weight: 500;
    }
    
    .vector-input-label {
      font-size: 0.8em;
      color: #666;
      text-align: center;
      margin-top: 4px;
      font-weight: 600;
    }
    
    .error-message {
      color: #dc3545;
      font-size: 0.85em;
      margin-top: 5px;
      display: none;
    }
    
    .error-message.show {
      display: block;
    }
    
    .buttons {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 10px;
      margin-bottom: 25px;
      max-width: 100%;
    }
    
    @media (max-width: 768px) {
      .buttons {
        grid-template-columns: repeat(2, 1fr);
      }
    }
    
    @media (max-width: 480px) {
      .buttons {
        grid-template-columns: 1fr;
      }
    }
    
    .btn-operation {
      padding: 12px 16px;
      font-size: 0.9em;
      font-weight: 600;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.3s;
      color: white;
      text-align: center;
      white-space: normal;
      overflow: hidden;
      width: 100%;
    }
    
    .btn-operation:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
    }
    
    .btn-dot { background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); }
    .btn-cross { background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); }
    .btn-norm { background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%); }
    .btn-angle { background: linear-gradient(135deg, #fa709a 0%, #fee140 100%); }
    .btn-projection { background: linear-gradient(135deg, #30cfd0 0%, #330867 100%); }
    .btn-triple { background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%); color: #333; }
    .btn-component { background: linear-gradient(135deg, #ff9a56 0%, #ff6a88 100%); }
    .btn-add { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
    .btn-scalar { background: linear-gradient(135deg, #f5af19 0%, #f12711 100%); }
    .btn-distance { background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%); }
    .btn-exercise { background: linear-gradient(135deg, #8E2DE2 0%, #4A00E0 100%); }
    .btn-viz { background: linear-gradient(135deg, #00C9FF 0%, #92FE9D 100%); color: #333; }
    
    .result-section {
      margin-top: 30px;
      padding: 25px;
      background: #f8f9fa;
      border-radius: 12px;
      border-left: 5px solid #667eea;
      display: none;
    }
    
    .result-section.show {
      display: block;
    }
    
    .result-header {
      color: #764ba2;
      margin-bottom: 20px;
      font-size: 1.1em;
      font-weight: 600;
    }
    
    .result-summary {
      background: white;
      padding: 20px;
      border-radius: 8px;
      margin-bottom: 20px;
      border-left: 4px solid #667eea;
    }
    
    .summary-line {
      margin-bottom: 8px;
      font-size: 0.95em;
      line-height: 1.6;
    }
    
    .summary-line strong {
      color: #667eea;
    }
    
    .summary-result {
      font-size: 1.1em;
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid #e0e0e0;
      color: #333;
      font-weight: 600;
    }
    
    .steps-container {
      max-height: 60vh;
      overflow-y: auto;
      padding-right: 10px;
    }
    
    .step {
      padding: 15px;
      margin-bottom: 15px;
      background: white;
      border-radius: 8px;
      border-left: 4px solid #667eea;
      animation: slideIn 0.5s ease-out;
    }
    
    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateX(-20px);
      }
      to {
        opacity: 1;
        transform: translateX(0);
      }
    }
    
    .step-title {
      font-weight: 600;
      color: #667eea;
      margin-bottom: 8px;
      font-size: 0.95em;
    }
    
    .step-content {
      color: #555;
      font-family: 'Courier New', monospace;
      line-height: 1.6;
      font-size: 0.9em;
    }
    
    .vector-display {
      display: inline-block;
      background: #f0f0f0;
      padding: 8px 12px;
      border-radius: 5px;
      font-weight: 600;
      color: #333;
      margin: 4px 2px;
      font-family: 'Courier New', monospace;
      border: 1px solid #ddd;
    }
    
    .error {
      padding: 15px;
      margin-bottom: 15px;
      background: #f8d7da;
      border: 2px solid #f5c6cb;
      border-radius: 8px;
      color: #721c24;
      font-weight: 500;
    }
    
    .info-box {
      background: #e7f3ff;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 20px;
      border-left: 4px solid #2196F3;
      font-size: 0.9em;
    }
    
    .info-box strong {
      color: #0066cc;
    }
    
    .geogebra-commands {
      background: #f5f5f5;
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 15px;
      margin: 15px 0;
      font-family: 'Courier New', monospace;
      font-size: 0.9em;
      max-height: 300px;
      overflow-y: auto;
    }
    
    .copy-commands-btn {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 600;
      margin-top: 10px;
      transition: all 0.3s;
    }
    
    .copy-commands-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
    }
    
    #ggb-element {
      width: 100%;
      height: 600px;
      border: 2px solid #667eea;
      border-radius: 12px;
      margin: 20px 0;
      display: none;
      box-sizing: border-box;
    }
    
    #ggb-element.show {
      display: block;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üìê Vector Calculator</h1>
    <p class="subtitle">2D & 3D Vector Operations with Step-by-Step Solutions</p>
    
    <div class="info-box">
      <strong>üí° Input Format:</strong> Enter vectors as comma-separated numbers (e.g., <code>2, 3, 4</code> for 3D or <code>1, 2</code> for 2D). Points use the same format. Negative and decimal values are supported.
      <br><br>
      <strong>üìö Exercise Operations:</strong> For textbook exercises, use vectors A, B, C as u, v, w respectively. The operations include linear combinations like 6u+2v, -v+u, 5(v-4u), and -3(v-8w).
      <br><br>
      <strong>üìä Visualization:</strong> Click "Plot Vectors" or any operation's plot button to see your vectors and points plotted instantly in an embedded GeoGebra canvas. Interact with the view using your mouse (rotate, pan, zoom). Works for both 2D and 3D!
    </div>
    
    <!-- Dimension Control -->
    <div class="section-header">Configuration</div>
    <div class="controls">
      <div class="control-group">
        <label>Vector Dimension:</label>
        <select id="dimension" onchange="onDimensionChange()">
          <option value="2">2D (x, y)</option>
          <option value="3" selected>3D (x, y, z)</option>
        </select>
      </div>
    </div>
    
    <!-- Vector Inputs -->
    <div class="section-header">Vector Inputs</div>
    
    <div class="vector-input-group">
      <h4>Vectors A, B, C</h4>
      <div class="vector-inputs">
        <div class="vector-input-field">
          <input type="text" id="vecA" placeholder="e.g., 1, 2, 3" onchange="onInputChange()" oninput="onInputChange()">
          <div class="vector-input-label">Vector <strong>A</strong></div>
          <div class="error-message" id="vecA-error"></div>
        </div>
        <div class="vector-input-field">
          <input type="text" id="vecB" placeholder="e.g., 4, 5, 6" onchange="onInputChange()" oninput="onInputChange()">
          <div class="vector-input-label">Vector <strong>B</strong></div>
          <div class="error-message" id="vecB-error"></div>
        </div>
        <div class="vector-input-field">
          <input type="text" id="vecC" placeholder="e.g., 7, 8, 9" onchange="onInputChange()" oninput="onInputChange()">
          <div class="vector-input-label">Vector <strong>C</strong></div>
          <div class="error-message" id="vecC-error"></div>
        </div>
      </div>
    </div>
    
    <div class="vector-input-group">
      <h4>Points P‚ÇÅ, P‚ÇÇ</h4>
      <div class="vector-inputs">
        <div class="vector-input-field">
          <input type="text" id="p1" placeholder="e.g., 1, 2, 3" onchange="onInputChange()" oninput="onInputChange()">
          <div class="vector-input-label">Point <strong>P‚ÇÅ</strong></div>
          <div class="error-message" id="p1-error"></div>
        </div>
        <div class="vector-input-field">
          <input type="text" id="p2" placeholder="e.g., 4, 5, 6" onchange="onInputChange()" oninput="onInputChange()">
          <div class="vector-input-label">Point <strong>P‚ÇÇ</strong></div>
          <div class="error-message" id="p2-error"></div>
        </div>
      </div>
    </div>
    
    <!-- Operation Buttons -->
    <div class="section-header">Basic Operations</div>
    <div class="buttons">
      <button class="btn-operation btn-dot" onclick="calculate('dot')">‚Ä¢ Dot Product A¬∑B</button>
      <button class="btn-operation btn-cross" onclick="calculate('cross')">‚®Ø Cross Product A√óB</button>
      <button class="btn-operation btn-norm" onclick="calculate('norm')">|| Norm |A|</button>
      <button class="btn-operation btn-angle" onclick="calculate('angle')">‚à† Angle Between</button>
      <button class="btn-operation btn-projection" onclick="calculate('projection')">‚Üí Projection</button>
      <button class="btn-operation btn-triple" onclick="calculate('triple')">‚âã Scalar Triple A¬∑(B√óC)</button>
      <button class="btn-operation btn-component" onclick="calculate('component')">‚Éó Vector from Points</button>
      <button class="btn-operation btn-add" onclick="calculate('add')">+ Add/Subtract Vectors</button>
      <button class="btn-operation btn-scalar" onclick="calculate('scalar')">√ó Scalar Multiply</button>
      <button class="btn-operation btn-distance" onclick="calculate('distance')">üìè Distance P‚ÇÅP‚ÇÇ</button>
    </div>
    
    <div class="section-header">Exercise Operations</div>
    <div class="buttons">
      <button class="btn-operation btn-exercise" onclick="calculateExercise('v-minus-w')">v - w</button>
      <button class="btn-operation btn-exercise" onclick="calculateExercise('6u-plus-2v')">6u + 2v</button>
      <button class="btn-operation btn-exercise" onclick="calculateExercise('-v-plus-u')">-v + u</button>
      <button class="btn-operation btn-exercise" onclick="calculateExercise('5-times-v-minus-4u')">5(v - 4u)</button>
      <button class="btn-operation btn-exercise" onclick="calculateExercise('-3-times-v-minus-8w')">-3(v - 8w)</button>
      <button class="btn-operation btn-test" onclick="runVectorTests()">üß™ Run Tests</button>
    </div>
    
    <div class="section-header">Visualization</div>
    <div class="buttons">
      <button class="btn-operation btn-viz" onclick="plotCoordinateSystem()">üìê Coordinate System</button>
      <button class="btn-operation btn-viz" onclick="plotVectors()">üìä Plot Vectors & Points</button>
    </div>
    
    <!-- GeoGebra Embedded Container -->
    <div id="ggb-element"></div>
    
    <!-- Results Section -->
    <div class="result-section" id="resultSection">
      <div class="result-header">Calculation Results</div>
      <div class="result-summary" id="resultSummary"></div>
      <div class="steps-container" id="stepsContainer"></div>
    </div>

    <!-- Test Results Section -->
    <div class="test-section" id="testSection">
      <div class="result-header">Unit Test Results</div>
      <div id="testSummary"></div>
      <div id="testResults" style="max-height: 70vh; overflow-y: auto;"></div>
    </div>
    </div>
  
  <script>
    const VectorModule = (() => {
      const validateDimension = (dim) => {
        if (![2, 3].includes(dim)) throw new Error('Dimension must be 2 or 3');
        return dim;
      };
      
      const parseVector = (input, requiredDim = null) => {
        if (!input || typeof input !== 'string') throw new Error('Vector input cannot be empty');
        
        const trimmed = input.trim();
        if (!trimmed) throw new Error('Vector input cannot be empty');
        
        const parts = trimmed.split(',').map(s => {
          const num = parseFloat(s.trim());
          if (isNaN(num)) throw new Error(`Invalid number: ${s.trim()}`);
          return num;
        });
        
        if (parts.length === 0) throw new Error('Vector must have at least one component');
        
        if (parts.length === 2 && requiredDim === 3) {
          parts.push(0);
        }
        
        if (requiredDim && parts.length !== requiredDim) {
          throw new Error(`Expected ${requiredDim}D vector, got ${parts.length}D`);
        }
        
        return parts;
      };
      
      const formatVector = (vec) => {
        return '(' + vec.map(v => {
          if (Number.isInteger(v)) return v.toString();
          return v.toFixed(4).replace(/0+$/, '').replace(/\.$/, '');
        }).join(', ') + ')';
      };
      
      const isZeroVector = (vec) => {
        return vec.every(v => Math.abs(v) < 1e-10);
      };
      
      const vectorAddition = (a, b) => {
        if (a.length !== b.length) throw new Error('Vectors must have same dimension');
        return a.map((v, i) => v + b[i]);
      };
      
      const vectorSubtraction = (a, b) => {
        if (a.length !== b.length) throw new Error('Vectors must have same dimension');
        return a.map((v, i) => v - b[i]);
      };
      
      const scalarMultiplication = (vec, scalar) => {
        return vec.map(v => v * scalar);
      };
      
      const dotProduct = (a, b) => {
        if (a.length !== b.length) throw new Error('Vectors must have same dimension for dot product');
        let sum = 0;
        for (let i = 0; i < a.length; i++) {
          sum += a[i] * b[i];
        }
        return sum;
      };
      
      const crossProduct = (a, b) => {
        if (a.length !== 3 || b.length !== 3) throw new Error('Cross product only works for 3D vectors');
        return [
          a[1] * b[2] - a[2] * b[1],
          a[2] * b[0] - a[0] * b[2],
          a[0] * b[1] - a[1] * b[0]
        ];
      };
      
      const vectorNorm = (vec) => {
        const sumSquares = vec.reduce((sum, v) => sum + v * v, 0);
        return Math.sqrt(sumSquares);
      };
      
      const angleBetween = (a, b) => {
        if (a.length !== b.length) throw new Error('Vectors must have same dimension');
        
        const normA = vectorNorm(a);
        const normB = vectorNorm(b);
        
        if (normA < 1e-10 || normB < 1e-10) throw new Error('Cannot find angle with zero vector');
        
        const dot = dotProduct(a, b);
        const cosTheta = dot / (normA * normB);
        const clamped = Math.max(-1, Math.min(1, cosTheta));
        const radians = Math.acos(clamped);
        const degrees = radians * 180 / Math.PI;
        
        return { radians, degrees, cosTheta };
      };
      
      const orthogonalProjection = (a, b) => {
        if (a.length !== b.length) throw new Error('Vectors must have same dimension');
        
        const dotAB = dotProduct(a, b);
        const dotBB = dotProduct(b, b);
        
        if (dotBB < 1e-10) throw new Error('Cannot project onto zero vector');
        
        const scalar = dotAB / dotBB;
        return scalarMultiplication(b, scalar);
      };
      
      const scalarTripleProduct = (a, b, c) => {
        if (a.length !== 3 || b.length !== 3 || c.length !== 3) {
          throw new Error('Scalar triple product requires 3D vectors');
        }
        const cross = crossProduct(b, c);
        return dotProduct(a, cross);
      };
      
      const componentFromPoints = (p1, p2) => {
        if (p1.length !== p2.length) throw new Error('Points must have same dimension');
        return vectorSubtraction(p2, p1);
      };
      
      const pointDistance = (p1, p2) => {
        const vec = componentFromPoints(p1, p2);
        return vectorNorm(vec);
      };
      
      return {
        validateDimension,
        parseVector,
        formatVector,
        isZeroVector,
        vectorAddition,
        vectorSubtraction,
        scalarMultiplication,
        dotProduct,
        crossProduct,
        vectorNorm,
        angleBetween,
        orthogonalProjection,
        scalarTripleProduct,
        componentFromPoints,
        pointDistance
      };
    })();
    
    let stepDelay = 0;
    
    function onDimensionChange() {
      clearResults();
      const dim = parseInt(document.getElementById('dimension').value);
      updatePlaceholders(dim);
    }
    
    function updatePlaceholders(dim) {
      const placeholders = dim === 2 
        ? { vec: 'e.g., 1, 2', point: 'e.g., 0, 0' }
        : { vec: 'e.g., 1, 2, 3', point: 'e.g., 0, 0, 0' };
      
      document.getElementById('vecA').placeholder = placeholders.vec;
      document.getElementById('vecB').placeholder = placeholders.vec;
      document.getElementById('vecC').placeholder = placeholders.vec;
      document.getElementById('p1').placeholder = placeholders.point;
      document.getElementById('p2').placeholder = placeholders.point;
    }
    
    function onInputChange() {
      validateAllInputs();
    }
    
    function validateAllInputs() {
      const dim = parseInt(document.getElementById('dimension').value);
      const fields = ['vecA', 'vecB', 'vecC', 'p1', 'p2'];
      let allValid = true;
      
      fields.forEach(fieldId => {
        const input = document.getElementById(fieldId).value.trim();
        const errorDiv = document.getElementById(`${fieldId}-error`);
        
        if (input === '') {
          errorDiv.classList.remove('show');
          return;
        }
        
        try {
          VectorModule.parseVector(input, dim);
          errorDiv.classList.remove('show');
        } catch (error) {
          errorDiv.textContent = error.message;
          errorDiv.classList.add('show');
          allValid = false;
        }
      });
      
      return allValid;
    }
    
    function getVectorInput(fieldId) {
      const input = document.getElementById(fieldId).value.trim();
      if (!input) return null;
      const dim = parseInt(document.getElementById('dimension').value);
      try {
        return VectorModule.parseVector(input, dim);
      } catch (error) {
        throw new Error(`${fieldId.toUpperCase()}: ${error.message}`);
      }
    }
    
    function clearResults() {
      document.getElementById('resultSection').classList.remove('show');
      document.getElementById('resultSummary').innerHTML = '';
      document.getElementById('stepsContainer').innerHTML = '';
    }
    
    function addStep(title, content) {
      setTimeout(() => {
        const container = document.getElementById('stepsContainer');
        const step = document.createElement('div');
        step.className = 'step';
        
        const titleDiv = document.createElement('div');
        titleDiv.className = 'step-title';
        titleDiv.textContent = title;
        
        const contentDiv = document.createElement('div');
        contentDiv.className = 'step-content';
        contentDiv.innerHTML = content;
        
        step.appendChild(titleDiv);
        step.appendChild(contentDiv);
        container.appendChild(step);
        
        setTimeout(() => {
          step.scrollIntoView({ behavior: 'smooth', block: 'end' });
        }, 50);
      }, stepDelay);
      
      stepDelay += 300;
    }
    
    function showResult(title, summary, steps, plotButton = null) {
      stepDelay = 0;
      clearResults();

      const resultSection = document.getElementById('resultSection');
      const summaryDiv = document.getElementById('resultSummary');

      let summaryHtml = `<div class="result-header">${title}</div>${summary}`;
      if (plotButton) {
        summaryHtml += `<div style="margin-top: 15px; text-align: center;">${plotButton}</div>`;
      }
      summaryDiv.innerHTML = summaryHtml;
      resultSection.classList.add('show');

      steps.forEach(step => {
        addStep(step.title, step.content);
      });
    }
    
    function showError(message) {
      clearResults();
      const resultSection = document.getElementById('resultSection');
      const summaryDiv = document.getElementById('resultSummary');
      
      summaryDiv.innerHTML = `<div class="error">${message}</div>`;
      resultSection.classList.add('show');
    }
    
    function calculate(operation) {
      try {
        validateAllInputs();
        
        switch(operation) {
          case 'dot': calculateDot(); break;
          case 'cross': calculateCross(); break;
          case 'norm': calculateNorm(); break;
          case 'angle': calculateAngle(); break;
          case 'projection': calculateProjection(); break;
          case 'triple': calculateTriple(); break;
          case 'component': calculateComponent(); break;
          case 'add': calculateAdd(); break;
          case 'scalar': calculateScalar(); break;
          case 'distance': calculateDistance(); break;
        }
      } catch (error) {
        showError(error.message);
      }
    }
    
    function calculateDot() {
      const A = getVectorInput('vecA');
      const B = getVectorInput('vecB');
      
      if (!A || !B) throw new Error('Please enter vectors A and B');
      
      const result = VectorModule.dotProduct(A, B);
      
      const steps = [];
      steps.push({
        title: 'Step 1: Dot Product Formula',
        content: `For vectors A = ${VectorModule.formatVector(A)} and B = ${VectorModule.formatVector(B)}<br>
                  A¬∑B = ${A.map((v, i) => `${v} √ó ${B[i]}`).join(' + ')}`
      });
      
      steps.push({
        title: 'Step 2: Calculation',
        content: `${A.map((v, i) => `${v} √ó ${B[i]} = ${v * B[i]}`).join('<br>')}
                  <br><br>Sum: ${A.map((v, i) => v * B[i]).join(' + ')} = <strong>${result}</strong>`
      });
      
      const summary = `
        <div class="summary-line"><strong>Vectors:</strong> A = ${VectorModule.formatVector(A)}, B = ${VectorModule.formatVector(B)}</div>
        <div class="summary-line"><strong>Operation:</strong> Dot Product (A ¬∑ B)</div>
        <div class="summary-result">Result: <span class="vector-display">${result}</span></div>
      `;
      
      showResult('Dot Product Result', summary, steps);
    }
    
    function calculateCross() {
      const dim = parseInt(document.getElementById('dimension').value);
      if (dim !== 3) throw new Error('Cross product is only defined for 3D vectors');
      
      const A = getVectorInput('vecA');
      const B = getVectorInput('vecB');
      
      if (!A || !B) throw new Error('Please enter vectors A and B');
      
      const result = VectorModule.crossProduct(A, B);
      
      const steps = [];3,-9
      steps.push({
        title: 'Step 1: Cross Product Formula',
        content: `For vectors A = ${VectorModule.formatVector(A)} and B = ${VectorModule.formatVector(B)}<br>
                  A √ó B = (a‚ÇÇb‚ÇÉ - a‚ÇÉb‚ÇÇ, a‚ÇÉb‚ÇÅ - a‚ÇÅb‚ÇÉ, a‚ÇÅb‚ÇÇ - a‚ÇÇb‚ÇÅ)`
      });
      
      steps.push({
        title: 'Step 2: Component Calculations',
        content: `i-component: ${A[1]} √ó ${B[2]} - ${A[2]} √ó ${B[1]} = ${result[0]}<br>
                  j-component: ${A[2]} √ó ${B[0]} - ${A[0]} √ó ${B[2]} = ${result[1]}<br>
                  k-component: ${A[0]} √ó ${B[1]} - ${A[1]} √ó ${B[0]} = ${result[2]}`
      });
      
      const summary = `
        <div class="summary-line"><strong>Vectors:</strong> A = ${VectorModule.formatVector(A)}, B = ${VectorModule.formatVector(B)}</div>
        <div class="summary-line"><strong>Operation:</strong> Cross Product (A √ó B)</div>
        <div class="summary-result">Result: <span class="vector-display">${VectorModule.formatVector(result)}</span></div>
      `;

      const plotButtonId = 'plotBtn_' + Math.random().toString(36).substr(2, 9);
      const plotButton = `
        <div class="plot-buttons">
          <button id="${plotButtonId}" class="btn-operation btn-viz" style="margin: 5px;">üìä Plot A √ó B</button>
        </div>
      `;

      showResult('Cross Product Result', summary, steps, plotButton);

      setTimeout(() => {
        const btn = document.getElementById(plotButtonId);
        if (btn) {
          const resultCopy = result;
          const ACopy = A;
          const BCopy = B;
          btn.onclick = () => plotOperationResult('Cross Product', resultCopy, {A: ACopy, B: BCopy});
        }
      }, 0);
    }
    
    function calculateNorm() {
      const A = getVectorInput('vecA');
      if (!A) throw new Error('Please enter vector A');
      
      if (VectorModule.isZeroVector(A)) throw new Error('Cannot calculate norm of zero vector');
      
      const result = VectorModule.vectorNorm(A);
      
      const steps = [];
      steps.push({
        title: 'Step 1: Norm Formula',
        content: `For vector A = ${VectorModule.formatVector(A)}<br>
                  |A| = ‚àö(a‚ÇÅ¬≤ + a‚ÇÇ¬≤${A.length === 3 ? ' + a‚ÇÉ¬≤' : ''})`
      });
      
      steps.push({
        title: 'Step 2: Calculation',
        content: `|A| = ‚àö(${A.map(v => `${v}¬≤`).join(' + ')})<br>
                  = ‚àö(${A.map(v => v * v).join(' + ')})<br>
                  = ‚àö${A.reduce((sum, v) => sum + v * v, 0)}<br>
                  = <strong>${result.toFixed(6)}</strong>`
      });
      
      const summary = `
        <div class="summary-line"><strong>Vector:</strong> A = ${VectorModule.formatVector(A)}</div>
        <div class="summary-line"><strong>Operation:</strong> Vector Norm (|A|)</div>
        <div class="summary-result">Result: <span class="vector-display">${result.toFixed(6)}</span></div>
      `;
      
      showResult('Vector Norm Result', summary, steps);
    }
    
    function calculateAngle() {
      const A = getVectorInput('vecA');
      const B = getVectorInput('vecB');
      
      if (!A || !B) throw new Error('Please enter vectors A and B');
      
      const result = VectorModule.angleBetween(A, B);
      
      const steps = [];
      steps.push({
        title: 'Step 1: Angle Formula',
        content: `For vectors A = ${VectorModule.formatVector(A)} and B = ${VectorModule.formatVector(B)}<br>
                  Œ∏ = arccos(A¬∑B / (|A| √ó |B|))`
      });
      
      const dotAB = VectorModule.dotProduct(A, B);
      const normA = VectorModule.vectorNorm(A);
      const normB = VectorModule.vectorNorm(B);
      
      steps.push({
        title: 'Step 2: Calculate Dot Product and Norms',
        content: `A¬∑B = ${dotAB.toFixed(4)}<br>
                  |A| = ${normA.toFixed(4)}<br>
                  |B| = ${normB.toFixed(4)}`
      });
      
      steps.push({
        title: 'Step 3: Calculate Angle',
        content: `cos(Œ∏) = ${dotAB.toFixed(4)} / (${normA.toFixed(4)} √ó ${normB.toFixed(4)}) = ${result.cosTheta.toFixed(4)}<br>
                  Œ∏ = arccos(${result.cosTheta.toFixed(4)})<br>
                  Œ∏ = <strong>${result.radians.toFixed(4)} radians</strong> = <strong>${result.degrees.toFixed(2)}¬∞</strong>`
      });
      
      const summary = `
        <div class="summary-line"><strong>Vectors:</strong> A = ${VectorModule.formatVector(A)}, B = ${VectorModule.formatVector(B)}</div>
        <div class="summary-line"><strong>Operation:</strong> Angle Between Vectors</div>
        <div class="summary-result">Result: <span class="vector-display">${result.degrees.toFixed(2)}¬∞ (${result.radians.toFixed(4)} rad)</span></div>
      `;
      
      showResult('Angle Between Vectors', summary, steps);
    }
    
    function calculateProjection() {
      const A = getVectorInput('vecA');
      const B = getVectorInput('vecB');
      
      if (!A || !B) throw new Error('Please enter vectors A and B');
      
      const result = VectorModule.orthogonalProjection(A, B);
      
      const dotAB = VectorModule.dotProduct(A, B);
      const dotBB = VectorModule.dotProduct(B, B);
      const scalar = dotAB / dotBB;
      
      const steps = [];
      steps.push({
        title: 'Step 1: Projection Formula',
        content: `For vectors A = ${VectorModule.formatVector(A)} and B = ${VectorModule.formatVector(B)}<br>
                  proj_B(A) = (A¬∑B / B¬∑B) √ó B`
      });
      
      steps.push({
        title: 'Step 2: Calculate Dot Products',
        content: `A¬∑B = ${dotAB.toFixed(4)}<br>
                  B¬∑B = ${dotBB.toFixed(4)}<br>
                  Scalar: ${dotAB.toFixed(4)} / ${dotBB.toFixed(4)} = ${scalar.toFixed(4)}`
      });
      
      steps.push({
        title: 'Step 3: Scalar Multiplication',
        content: `proj_B(A) = ${scalar.toFixed(4)} √ó ${VectorModule.formatVector(B)}<br>
                  = ${VectorModule.formatVector(result)}`
      });
      
      const summary = `
        <div class="summary-line"><strong>Vector A:</strong> ${VectorModule.formatVector(A)}</div>
        <div class="summary-line"><strong>Vector B:</strong> ${VectorModule.formatVector(B)}</div>
        <div class="summary-line"><strong>Operation:</strong> Projection of A onto B</div>
        <div class="summary-result">Result: <span class="vector-display">${VectorModule.formatVector(result)}</span></div>
      `;

      const plotButtonId = 'plotBtn_' + Math.random().toString(36).substr(2, 9);
      const plotButton = `
        <div class="plot-buttons">
          <button id="${plotButtonId}" class="btn-operation btn-viz" style="margin: 5px;">üìä Plot proj_B(A)</button>
        </div>
      `;

      showResult('Orthogonal Projection', summary, steps, plotButton);

      setTimeout(() => {
        const btn = document.getElementById(plotButtonId);
        if (btn) {
          const resultCopy = result;
          const ACopy = A;
          const BCopy = B;
          btn.onclick = () => plotOperationResult('Orthogonal Projection', resultCopy, {A: ACopy, B: BCopy});
        }
      }, 0);
    }
    
    function calculateTriple() {
      const dim = parseInt(document.getElementById('dimension').value);
      if (dim !== 3) throw new Error('Scalar triple product is only defined for 3D vectors');
      
      const A = getVectorInput('vecA');
      const B = getVectorInput('vecB');
      const C = getVectorInput('vecC');
      
      if (!A || !B || !C) throw new Error('Please enter vectors A, B, and C');
      
      const cross = VectorModule.crossProduct(B, C);
      const result = VectorModule.dotProduct(A, cross);
      
      const steps = [];
      steps.push({
        title: 'Step 1: Scalar Triple Product Formula',
        content: `For vectors A = ${VectorModule.formatVector(A)}, B = ${VectorModule.formatVector(B)}, C = ${VectorModule.formatVector(C)}<br>
                  A¬∑(B√óC) = First calculate B√óC, then dot with A`
      });
      
      steps.push({
        title: 'Step 2: Calculate Cross Product B√óC',
        content: `B√óC = (${B[1]}√ó${C[2]} - ${B[2]}√ó${C[1]}, ${B[2]}√ó${C[0]} - ${B[0]}√ó${C[2]}, ${B[0]}√ó${C[1]} - ${B[1]}√ó${C[0]})<br>
                  = ${VectorModule.formatVector(cross)}`
      });
      
      steps.push({
        title: 'Step 3: Dot Product A¬∑(B√óC)',
        content: `${A.map((v, i) => `${v} √ó ${cross[i]}`).join(' + ')}<br>
                  = ${A.map((v, i) => v * cross[i]).join(' + ')}<br>
                  = <strong>${result.toFixed(4)}</strong>`
      });
      
      const summary = `
        <div class="summary-line"><strong>Vectors:</strong> A = ${VectorModule.formatVector(A)}, B = ${VectorModule.formatVector(B)}, C = ${VectorModule.formatVector(C)}</div>
        <div class="summary-line"><strong>Operation:</strong> Scalar Triple Product (A¬∑(B√óC))</div>
        <div class="summary-result">Result: <span class="vector-display">${result.toFixed(4)}</span></div>
      `;
      
      showResult('Scalar Triple Product', summary, steps);
    }
    
    function calculateComponent() {
      const P1 = getVectorInput('p1');
      const P2 = getVectorInput('p2');
      
      if (!P1 || !P2) throw new Error('Please enter points P‚ÇÅ and P‚ÇÇ');
      
      const result = VectorModule.componentFromPoints(P1, P2);
      
      const steps = [];
      steps.push({
        title: 'Step 1: Vector from Points',
        content: `For points P‚ÇÅ = ${VectorModule.formatVector(P1)} and P‚ÇÇ = ${VectorModule.formatVector(P2)}<br>
                  Vector = P‚ÇÇ - P‚ÇÅ`
      });
      
      steps.push({
        title: 'Step 2: Subtraction',
        content: `${P2.map((v, i) => `${v} - ${P1[i]}`).join('<br>')}<br>
                  = ${result.map(v => v).join(', ')}`
      });
      
      const summary = `
        <div class="summary-line"><strong>Point P‚ÇÅ:</strong> ${VectorModule.formatVector(P1)}</div>
        <div class="summary-line"><strong>Point P‚ÇÇ:</strong> ${VectorModule.formatVector(P2)}</div>
        <div class="summary-line"><strong>Operation:</strong> Vector from P‚ÇÅ to P‚ÇÇ</div>
        <div class="summary-result">Result: <span class="vector-display">${VectorModule.formatVector(result)}</span></div>
      `;

      const plotButtonId = 'plotBtn_' + Math.random().toString(36).substr(2, 9);
      const plotButton = `
        <div class="plot-buttons">
          <button id="${plotButtonId}" class="btn-operation btn-viz" style="margin: 5px;">üìä Plot Vector P‚ÇÅP‚ÇÇ</button>
        </div>
      `;

      showResult('Vector from Points', summary, steps, plotButton);

      setTimeout(() => {
        const btn = document.getElementById(plotButtonId);
        if (btn) {
          const resultCopy = result;
          const P1Copy = P1;
          const P2Copy = P2;
          btn.onclick = () => plotOperationResult('Vector from Points', resultCopy, {P1: P1Copy, P2: P2Copy});
        }
      }, 0);
    }
    
    function calculateAdd() {
      const A = getVectorInput('vecA');
      const B = getVectorInput('vecB');
      
      if (!A || !B) throw new Error('Please enter vectors A and B');
      
      const resultAdd = VectorModule.vectorAddition(A, B);
      const resultSub = VectorModule.vectorSubtraction(A, B);
      
      const stepsAdd = [];
      stepsAdd.push({
        title: 'Step 1: Vector Addition',
        content: `For vectors A = ${VectorModule.formatVector(A)} and B = ${VectorModule.formatVector(B)}<br>
                  A + B = (${A.map((v, i) => `${v} + ${B[i]}`).join(', ')})`
      });
      
      stepsAdd.push({
        title: 'Step 2: Result',
        content: `A + B = ${VectorModule.formatVector(resultAdd)}`
      });
      
      stepsAdd.push({
        title: 'Step 3: Vector Subtraction',
        content: `A - B = (${A.map((v, i) => `${v} - ${B[i]}`).join(', ')})<br>
                  = ${VectorModule.formatVector(resultSub)}`
      });
      
      const summary = `
        <div class="summary-line"><strong>Vectors:</strong> A = ${VectorModule.formatVector(A)}, B = ${VectorModule.formatVector(B)}</div>
        <div class="summary-line"><strong>Addition:</strong> A + B = <span class="vector-display">${VectorModule.formatVector(resultAdd)}</span></div>
        <div class="summary-line"><strong>Subtraction:</strong> A - B = <span class="vector-display">${VectorModule.formatVector(resultSub)}</span></div>
      `;

      const plotBtnId1 = 'plotBtn_' + Math.random().toString(36).substr(2, 9);
      const plotBtnId2 = 'plotBtn_' + Math.random().toString(36).substr(2, 9);
      const plotButton = `
        <div class="plot-buttons">
          <button id="${plotBtnId1}" class="btn-operation btn-viz" style="margin: 5px;">üìä Plot A + B</button>
          <button id="${plotBtnId2}" class="btn-operation btn-viz" style="margin: 5px;">üìä Plot A - B</button>
        </div>
      `;

      showResult('Vector Addition & Subtraction', summary, stepsAdd, plotButton);

      setTimeout(() => {
        const btn1 = document.getElementById(plotBtnId1);
        if (btn1) {
          const resultAddCopy = resultAdd;
          const ACopy = A;
          const BCopy = B;
          btn1.onclick = () => plotOperationResult('Vector Addition', resultAddCopy, {A: ACopy, B: BCopy});
        }
        const btn2 = document.getElementById(plotBtnId2);
        if (btn2) {
          const resultSubCopy = resultSub;
          const ACopy = A;
          const BCopy = B;
          btn2.onclick = () => plotOperationResult('Vector Subtraction', resultSubCopy, {A: ACopy, B: BCopy});
        }
      }, 0);
    }
    
    function calculateScalar() {
      const A = getVectorInput('vecA');
      if (!A) throw new Error('Please enter vector A');
      
      const scalarInput = document.getElementById('vecB').value.trim();
      if (!scalarInput) throw new Error('Please enter a scalar value in vector B field');
      
      let scalar;
      try {
        scalar = parseFloat(scalarInput);
        if (isNaN(scalar)) throw new Error('Invalid scalar value');
      } catch (error) {
        throw new Error('Please enter a single number for scalar multiplication');
      }
      
      const result = VectorModule.scalarMultiplication(A, scalar);
      
      const steps = [];
      steps.push({
        title: 'Step 1: Scalar Multiplication',
        content: `For vector A = ${VectorModule.formatVector(A)} and scalar k = ${scalar}<br>
                  k √ó A = ${scalar} √ó ${VectorModule.formatVector(A)}`
      });
      
      steps.push({
        title: 'Step 2: Multiply Each Component',
        content: `${A.map(v => `${scalar} √ó ${v} = ${scalar * v}`).join('<br>')}`
      });
      
      steps.push({
        title: 'Step 3: Result',
        content: `${scalar} √ó A = ${VectorModule.formatVector(result)}`
      });
      
      const summary = `
        <div class="summary-line"><strong>Vector:</strong> A = ${VectorModule.formatVector(A)}</div>
        <div class="summary-line"><strong>Scalar:</strong> k = ${scalar}</div>
        <div class="summary-line"><strong>Operation:</strong> Scalar Multiplication</div>
        <div class="summary-result">Result: <span class="vector-display">${VectorModule.formatVector(result)}</span></div>
      `;

      const plotButtonId = 'plotBtn_' + Math.random().toString(36).substr(2, 9);
      const plotButton = `
        <div class="plot-buttons">
          <button id="${plotButtonId}" class="btn-operation btn-viz" style="margin: 5px;">üìä Plot k√óA</button>
        </div>
      `;

      showResult('Scalar Multiplication', summary, steps, plotButton);

      setTimeout(() => {
        const btn = document.getElementById(plotButtonId);
        if (btn) {
          const resultCopy = result;
          const ACopy = A;
          btn.onclick = () => plotOperationResult('Scalar Multiplication', resultCopy, {A: ACopy});
        }
      }, 0);
    }
    
    function calculateDistance() {
      const P1 = getVectorInput('p1');
      const P2 = getVectorInput('p2');
      
      if (!P1 || !P2) throw new Error('Please enter points P‚ÇÅ and P‚ÇÇ');
      
      const result = VectorModule.pointDistance(P1, P2);
      
      const steps = [];
      steps.push({
        title: 'Step 1: Distance Formula',
        content: `For points P‚ÇÅ = ${VectorModule.formatVector(P1)} and P‚ÇÇ = ${VectorModule.formatVector(P2)}<br>
                  Distance = ‚àö((p‚ÇÇ‚Çì - p‚ÇÅ‚Çì)¬≤ + (p‚ÇÇ·µß - p‚ÇÅ·µß)¬≤${P1.length === 3 ? ' + (p‚ÇÇ·µ§ - p‚ÇÅ·µ§)¬≤' : ''})`
      });
      
      const vec = VectorModule.vectorSubtraction(P2, P1);
      steps.push({
        title: 'Step 2: Calculate Differences',
        content: `${P2.map((v, i) => `${v} - ${P1[i]} = ${v - P1[i]}`).join('<br>')}`
      });
      
      steps.push({
        title: 'Step 3: Square and Sum',
        content: `‚àö(${vec.map(v => `${v}¬≤`).join(' + ')})<br>
                  = ‚àö(${vec.map(v => v * v).join(' + ')})<br>
                  = ‚àö${vec.reduce((sum, v) => sum + v * v, 0)}<br>
                  = <strong>${result.toFixed(6)}</strong>`
      });
      
      const summary = `
        <div class="summary-line"><strong>Point P‚ÇÅ:</strong> ${VectorModule.formatVector(P1)}</div>
        <div class="summary-line"><strong>Point P‚ÇÇ:</strong> ${VectorModule.formatVector(P2)}</div>
        <div class="summary-line"><strong>Operation:</strong> Distance Between Points</div>
        <div class="summary-result">Result: <span class="vector-display">${result.toFixed(6)}</span></div>
      `;

      const plotButtonId = 'plotBtn_' + Math.random().toString(36).substr(2, 9);
      const plotButton = `
        <div class="plot-buttons">
          <button id="${plotButtonId}" class="btn-operation btn-viz" style="margin: 5px;">üìä Plot Points</button>
        </div>
      `;

      showResult('Point Distance', summary, steps, plotButton);

      setTimeout(() => {
        const btn = document.getElementById(plotButtonId);
        if (btn) {
          const P1Copy = P1;
          const P2Copy = P2;
          btn.onclick = () => plotOperationResult('Point Distance', null, {P1: P1Copy, P2: P2Copy});
        }
      }, 0);
    }
    
    function calculateExercise(exerciseType) {
      try {
        validateAllInputs();
        
        // Use A, B, C as u, v, w for the exercises
        const u = getVectorInput('vecA');
        const v = getVectorInput('vecB');
        const w = getVectorInput('vecC');
        
        if (!u || !v || !w) throw new Error('Please enter vectors A, B, and C to use as u, v, w');
        
        let result, steps, summary, title;
        
        switch(exerciseType) {
          case 'v-minus-w':
            result = VectorModule.vectorSubtraction(v, w);
            title = 'Vector Subtraction: v - w';
            steps = [
              {
                title: 'Step 1: Formula',
                content: `v - w = ${VectorModule.formatVector(v)} - ${VectorModule.formatVector(w)}`
              },
              {
                title: 'Step 2: Component-wise Subtraction',
                content: `${v.map((vi, i) => `${vi} - ${w[i]} = ${vi - w[i]}`).join('<br>')}`
              },
              {
                title: 'Step 3: Result',
                content: `v - w = ${VectorModule.formatVector(result)}`
              }
            ];
            summary = `
              <div class="summary-line"><strong>Vector v:</strong> ${VectorModule.formatVector(v)}</div>
              <div class="summary-line"><strong>Vector w:</strong> ${VectorModule.formatVector(w)}</div>
              <div class="summary-line"><strong>Operation:</strong> v - w</div>
              <div class="summary-result">Result: <span class="vector-display">${VectorModule.formatVector(result)}</span></div>
            `;
            break;
            
          case '6u-plus-2v':
            const sixU = VectorModule.scalarMultiplication(u, 6);
            const twoV = VectorModule.scalarMultiplication(v, 2);
            result = VectorModule.vectorAddition(sixU, twoV);
            title = 'Linear Combination: 6u + 2v';
            steps = [
              {
                title: 'Step 1: Scalar Multiplications',
                content: `6u = 6 √ó ${VectorModule.formatVector(u)} = ${VectorModule.formatVector(sixU)}<br>
                          2v = 2 √ó ${VectorModule.formatVector(v)} = ${VectorModule.formatVector(twoV)}`
              },
              {
                title: 'Step 2: Vector Addition',
                content: `6u + 2v = ${VectorModule.formatVector(sixU)} + ${VectorModule.formatVector(twoV)}<br>
                          = ${result.map((r, i) => `${sixU[i]} + ${twoV[i]} = ${r}`).join('<br>')}`
              },
              {
                title: 'Step 3: Result',
                content: `6u + 2v = ${VectorModule.formatVector(result)}`
              }
            ];
            summary = `
              <div class="summary-line"><strong>Vector u:</strong> ${VectorModule.formatVector(u)}</div>
              <div class="summary-line"><strong>Vector v:</strong> ${VectorModule.formatVector(v)}</div>
              <div class="summary-line"><strong>Operation:</strong> 6u + 2v</div>
              <div class="summary-result">Result: <span class="vector-display">${VectorModule.formatVector(result)}</span></div>
            `;
            break;
            
          case '-v-plus-u':
            const negV = VectorModule.scalarMultiplication(v, -1);
            result = VectorModule.vectorAddition(negV, u);
            title = 'Vector Addition: -v + u';
            steps = [
              {
                title: 'Step 1: Negate v',
                content: `-v = -1 √ó ${VectorModule.formatVector(v)} = ${VectorModule.formatVector(negV)}`
              },
              {
                title: 'Step 2: Add u',
                content: `-v + u = ${VectorModule.formatVector(negV)} + ${VectorModule.formatVector(u)}<br>
                          = ${result.map((r, i) => `${negV[i]} + ${u[i]} = ${r}`).join('<br>')}`
              },
              {
                title: 'Step 3: Result',
                content: `-v + u = ${VectorModule.formatVector(result)}`
              }
            ];
            summary = `
              <div class="summary-line"><strong>Vector u:</strong> ${VectorModule.formatVector(u)}</div>
              <div class="summary-line"><strong>Vector v:</strong> ${VectorModule.formatVector(v)}</div>
              <div class="summary-line"><strong>Operation:</strong> -v + u</div>
              <div class="summary-result">Result: <span class="vector-display">${VectorModule.formatVector(result)}</span></div>
            `;
            break;
            
          case '5-times-v-minus-4u':
            const fiveV = VectorModule.scalarMultiplication(v, 5);
            const fourU = VectorModule.scalarMultiplication(u, 4);
            const vMinus4U = VectorModule.vectorSubtraction(v, fourU);
            result = VectorModule.scalarMultiplication(vMinus4U, 5);
            title = 'Vector Operation: 5(v - 4u)';
            steps = [
              {
                title: 'Step 1: Calculate 4u',
                content: `4u = 4 √ó ${VectorModule.formatVector(u)} = ${VectorModule.formatVector(fourU)}`
              },
              {
                title: 'Step 2: Calculate (v - 4u)',
                content: `v - 4u = ${VectorModule.formatVector(v)} - ${VectorModule.formatVector(fourU)}<br>
                          = ${vMinus4U.map((r, i) => `${v[i]} - ${fourU[i]} = ${r}`).join('<br>')}<br>
                          = ${VectorModule.formatVector(vMinus4U)}`
              },
              {
                title: 'Step 3: Multiply by 5',
                content: `5(v - 4u) = 5 √ó ${VectorModule.formatVector(vMinus4U)}<br>
                          = ${result.map((r, i) => `5 √ó ${vMinus4U[i]} = ${r}`).join('<br>')}<br>
                          = ${VectorModule.formatVector(result)}`
              }
            ];
            summary = `
              <div class="summary-line"><strong>Vector u:</strong> ${VectorModule.formatVector(u)}</div>
              <div class="summary-line"><strong>Vector v:</strong> ${VectorModule.formatVector(v)}</div>
              <div class="summary-line"><strong>Operation:</strong> 5(v - 4u)</div>
              <div class="summary-result">Result: <span class="vector-display">${VectorModule.formatVector(result)}</span></div>
            `;
            break;
            
          case '-3-times-v-minus-8w':
            const threeV = VectorModule.scalarMultiplication(v, -3);
            const eightW = VectorModule.scalarMultiplication(w, 8);
            const vMinus8W = VectorModule.vectorSubtraction(v, eightW);
            result = VectorModule.scalarMultiplication(vMinus8W, -3);
            title = 'Vector Operation: -3(v - 8w)';
            steps = [
              {
                title: 'Step 1: Calculate 8w',
                content: `8w = 8 √ó ${VectorModule.formatVector(w)} = ${VectorModule.formatVector(eightW)}`
              },
              {
                title: 'Step 2: Calculate (v - 8w)',
                content: `v - 8w = ${VectorModule.formatVector(v)} - ${VectorModule.formatVector(eightW)}<br>
                          = ${vMinus8W.map((r, i) => `${v[i]} - ${eightW[i]} = ${r}`).join('<br>')}<br>
                          = ${VectorModule.formatVector(vMinus8W)}`
              },
              {
                title: 'Step 3: Multiply by -3',
                content: `-3(v - 8w) = -3 √ó ${VectorModule.formatVector(vMinus8W)}<br>
                          = ${result.map((r, i) => `-3 √ó ${vMinus8W[i]} = ${r}`).join('<br>')}<br>
                          = ${VectorModule.formatVector(result)}`
              }
            ];
            summary = `
              <div class="summary-line"><strong>Vector v:</strong> ${VectorModule.formatVector(v)}</div>
              <div class="summary-line"><strong>Vector w:</strong> ${VectorModule.formatVector(w)}</div>
              <div class="summary-line"><strong>Operation:</strong> -3(v - 8w)</div>
              <div class="summary-result">Result: <span class="vector-display">${VectorModule.formatVector(result)}</span></div>
            `;
            break;
            
          default:
            throw new Error('Unknown exercise type');
        }
        
        // Add plot buttons for exercises
        const plotButtonId = 'plotBtn_' + Math.random().toString(36).substr(2, 9);
        const plotButton = `
        <div class="plot-buttons">
          <button id="${plotButtonId}" class="btn-operation btn-viz" style="margin: 5px;">üìä Plot Result</button>
        </div>
        `;

        showResult(title, summary, steps, plotButton);

        setTimeout(() => {
          const btn = document.getElementById(plotButtonId);
          if (btn) {
            const titleCopy = title;
            const resultCopy = result;
            const uCopy = u;
            const vCopy = v;
            const wCopy = w;
            btn.onclick = () => plotOperationResult(titleCopy, resultCopy, {A: uCopy, B: vCopy, C: wCopy});
          }
        }, 0);
      } catch (error) {
        showError(error.message);
      }
     }
     
let ggbApplet = null;
let ggbAPI = null;
let currentMode = null;
let appletInitPromise = null;
let appletInitResolve = null;
let appletInitReject = null;
let ggbCommandsReady = false;  // Track if GeoGebra commands are loaded

const trackedGeoObjects = new Set();
const GEO_DEFAULT_VECTOR_COLOR = { r: 0, g: 100, b: 200 }; // Dark blue
const GEO_RESULT_VECTOR_COLOR = { r: 200, g: 0, b: 0 }; // Dark red  
const GEO_POINT_P1_COLOR = { r: 200, g: 100, b: 0 }; // Dark orange
const GEO_POINT_P2_COLOR = { r: 0, g: 150, b: 0 }; // Dark green

// Check if WebGL is available
function isWebGLAvailable() {
  try {
    const canvas = document.createElement('canvas');
    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
    return !!gl;
  } catch (e) {
    return false;
  }
}

// Safe command execution - waits for commands to be ready
async function safeEvalCommand(api, command, maxRetries = 20, delay = 250) {
  if (!api) return false;
  
  for (let i = 0; i < maxRetries; i++) {
    try {
      // Try asyncEvalCommand first (newer GeoGebra)
      if (typeof api.asyncEvalCommand === 'function') {
        await api.asyncEvalCommand(command);
        return true;
      }
      
      // Fall back to evalCommand
      if (typeof api.evalCommand === 'function') {
        const result = api.evalCommand(command);
        // If it didn't throw, it worked
        return result !== false;
      }
    } catch (error) {
      // Check if it's a "commands not loaded" error
      if (error.message && error.message.includes('not loaded')) {
        console.log(`Command not ready yet, retrying (${i + 1}/${maxRetries})...`);
        await new Promise(resolve => setTimeout(resolve, delay));
        continue;
      }
      // Other errors - log and return false
      console.warn('safeEvalCommand error:', error.message);
      return false;
    }
  }
  console.warn('safeEvalCommand: Max retries exceeded for command:', command);
  return false;
}

// Wait for GeoGebra to be fully ready (including commands)
function waitForGeoGebraReady(api, maxWait = 10000) {
  return new Promise((resolve) => {
    const startTime = Date.now();
    
    function check() {
      // Try a simple test command
      try {
        if (api && typeof api.evalCommand === 'function') {
          // Try to evaluate a simple expression
          api.evalCommand('a_test_var = 1');
          api.deleteObject('a_test_var');
          ggbCommandsReady = true;
          resolve(true);
          return;
        }
      } catch (e) {
        // Commands not ready yet
      }
      
      if (Date.now() - startTime < maxWait) {
        setTimeout(check, 200);
      } else {
        console.warn('GeoGebra commands did not become ready in time');
        resolve(false);
      }
    }
    
    check();
  });
}

function registerGeoObject(name) {
  if (name) {
    trackedGeoObjects.add(name);
  }
}

function deleteGeoObject(api, name) {
  if (!api || !name) {
    return;
  }

  let objectExists = true;

  if (typeof api.exists === 'function') {
    try {
      objectExists = api.exists(name);
    } catch (error) {
      objectExists = true;
    }
  } else if (typeof api.getObjectType === 'function') {
    try {
      objectExists = !!api.getObjectType(name);
    } catch (error) {
      objectExists = false;
    }
  }

  if (!objectExists) {
    console.log('deleteGeoObject: Object does not exist:', name);
    return;
  }

  try {
    if (typeof api.deleteObject === 'function') {
      console.log('deleteGeoObject: Deleting via deleteObject:', name);
      api.deleteObject(name);
    } else if (typeof api.evalCommand === 'function') {
      console.log('deleteGeoObject: Deleting via Delete() command:', name);
      api.evalCommand(`Delete(${name})`);
    }
  } catch (error) {
    console.warn('Failed to delete GeoGebra object:', name, error);
  }
}

const GEO_PROTECTED_NAME_PATTERNS = [/axis/i, /plane/i, /grid/i, /view/i, /origin/i];

function shouldPreserveGeoObject(api, name) {
  if (!name) {
    return true;
  }

  if (GEO_PROTECTED_NAME_PATTERNS.some(pattern => pattern.test(name))) {
    return true;
  }

  if (typeof api.getObjectType === 'function') {
    try {
      const type = api.getObjectType(name);
      if (!type) {
        return false;
      }
      const normalizedType = String(type).toLowerCase();
      if (normalizedType.includes('axis') || normalizedType.includes('plane') || normalizedType.includes('grid') || normalizedType.includes('view')) {
        return true;
      }
    } catch (error) {
      return false;
    }
  }

  return false;
}

function clearAllGeoGebraObjects(api) {
  if (!api) {
    return;
  }

  // First, try to delete common vector and point names directly
  const commonNames = ['VectorA', 'VectorB', 'VectorC', 'P1', 'P2', 'Result'];
  commonNames.forEach(name => deleteGeoObject(api, name));

  // Then try to delete all other objects if API supports it
  if (typeof api.getAllObjectNames === 'function') {
    try {
      let names = api.getAllObjectNames();

      if (typeof names === 'string') {
        names = names.split(/[\n,]/).map(name => name.trim()).filter(Boolean);
      }

      if (Array.isArray(names) && names.length) {
        names.forEach(name => {
          if (!shouldPreserveGeoObject(api, name)) {
            deleteGeoObject(api, name);
          }
        });
      }
    } catch (error) {
      console.warn('Failed to enumerate GeoGebra objects:', error);
    }
  }
}

function safeResetGeoGebra(api) {
  if (!api) {
    return;
  }

  try {
    if (typeof api.reset === 'function') {
      api.reset();
    } else if (ggbApplet && typeof ggbApplet.reset === 'function') {
      ggbApplet.reset();
    }
  } catch (error) {
    console.warn('Failed to reset GeoGebra applet:', error);
  }
}

function prepareGeoGebra(api) {
  if (!api) {
    console.warn('prepareGeoGebra: API not available');
    return;
  }

  console.log('prepareGeoGebra: Starting cleanup - tracked objects:', trackedGeoObjects.size);

  // First, clear all tracked objects that we created in previous plots
  const namesToRemove = trackedGeoObjects.size ? Array.from(trackedGeoObjects) : [];
  if (namesToRemove.length) {
    console.log('prepareGeoGebra: Deleting tracked objects:', namesToRemove);
    namesToRemove.forEach(name => deleteGeoObject(api, name));
  }
  trackedGeoObjects.clear();

  // Then clear all other non-protected objects
  console.log('prepareGeoGebra: Clearing all non-protected objects');
  clearAllGeoGebraObjects(api);

  // Finally, try to reset the applet for a clean slate
  console.log('prepareGeoGebra: Attempting safe reset');
  safeResetGeoGebra(api);

  console.log('prepareGeoGebra: Cleanup complete');
}

// Async version of setVectorStyle that waits for commands to be ready
async function setVectorStyleAsync(api, name, color = GEO_DEFAULT_VECTOR_COLOR, thickness = 5) {
  if (!api || !name) {
    return;
  }

  try {
    // Wait a bit for object to be created
    await new Promise(resolve => setTimeout(resolve, 100));
    
    // Check if object exists
    if (typeof api.exists === 'function' && !api.exists(name)) {
      console.warn('Vector object does not exist yet:', name);
      return;
    }
    
    // Use setColor API method directly if available (more reliable)
    if (typeof api.setColor === 'function') {
      api.setColor(name, color.r, color.g, color.b);
    } else {
      await safeEvalCommand(api, `SetColor(${name}, ${color.r}, ${color.g}, ${color.b})`);
    }
    
    // Use setLineThickness API method directly if available
    if (typeof api.setLineThickness === 'function') {
      api.setLineThickness(name, thickness);
    } else {
      await safeEvalCommand(api, `SetLineThickness(${name}, ${thickness})`);
    }
    
    console.log(`Applied style to vector:`, name);
  } catch (error) {
    console.warn('Failed to style vector:', name, error.message);
  }
}

// Async version of setPointStyle that waits for commands to be ready
async function setPointStyleAsync(api, name, color = GEO_POINT_P1_COLOR) {
  if (!api || !name) {
    return;
  }

  const selectedColor = color || GEO_POINT_P1_COLOR;

  try {
    // Wait a bit for object to be created
    await new Promise(resolve => setTimeout(resolve, 100));
    
    // Check if object exists
    if (typeof api.exists === 'function' && !api.exists(name)) {
      console.warn('Point object does not exist yet:', name);
      return;
    }
    
    // Use setColor API method directly if available (more reliable)
    if (typeof api.setColor === 'function') {
      api.setColor(name, selectedColor.r, selectedColor.g, selectedColor.b);
    } else {
      await safeEvalCommand(api, `SetColor(${name}, ${selectedColor.r}, ${selectedColor.g}, ${selectedColor.b})`);
    }
    
    // Use API methods directly if available
    if (typeof api.setPointSize === 'function') {
      api.setPointSize(name, 6);
    } else {
      await safeEvalCommand(api, `SetPointSize(${name}, 6)`);
    }
    
    if (typeof api.setPointStyle === 'function') {
      api.setPointStyle(name, 2);
    } else {
      await safeEvalCommand(api, `SetPointStyle(${name}, 2)`);
    }
    
    console.log(`Applied style to point:`, name);
  } catch (error) {
    console.warn('Failed to style point:', name, error.message);
  }
}

function setVectorStyle(api, name, color = GEO_DEFAULT_VECTOR_COLOR, thickness = 5) {
  // Call async version
  setVectorStyleAsync(api, name, color, thickness);
}

function setPointStyle(api, name, color = GEO_POINT_P1_COLOR) {
  // Call async version
  setPointStyleAsync(api, name, color);
}

// Global callback that GeoGebra calls when the applet is ready
// The API object is passed as the first argument when using appletOnLoad as a function
window.ggbOnInit = function(api) {
  console.log('GeoGebra callback triggered, API received:', !!api);
  
  // If api is passed directly (newer GeoGebra versions)
  if (api && typeof api.evalCommand === 'function') {
    console.log('API received directly in callback');
    ggbAPI = api;
    if (appletInitResolve) {
      appletInitResolve(api);
    }
    return;
  }
  
  // Fallback: try to get API from global ggbApplet
  if (appletInitResolve) {
    appletInitResolve();
  }
};

           // Fallback polling mechanism - check multiple ways to access API
           function tryGetAPI(maxRetries = 50, delay = 200) {
             return new Promise((resolve, reject) => {
               let retries = 0;
               let resolved = false;

               function checkAPI() {
                 if (resolved) return;
                 retries++;

                 try {
                   // Method 1: Check if ggbAPI was already set by callback
                   if (ggbAPI && typeof ggbAPI.evalCommand === 'function') {
                     console.log('API already available via ggbAPI');
                     resolved = true;
                     resolve(ggbAPI);
                     return;
                   }

                   // Method 2: Try window.ggbApplet global (set by GeoGebra when id matches)
                   const globalApplet = window.ggbApplet || window['ggb-element'];
                   if (globalApplet && typeof globalApplet.evalCommand === 'function') {
                     console.log('API found via global ggbApplet after', retries, 'retries');
                     ggbAPI = globalApplet;
                     resolved = true;
                     resolve(globalApplet);
                     return;
                   }

                   // Method 3: Check if applet exists and has getAppletObject
                   if (ggbApplet && typeof ggbApplet.getAppletObject === 'function') {
                     const appletObject = ggbApplet.getAppletObject();
                     if (appletObject && typeof appletObject.evalCommand === 'function') {
                       console.log('API found via getAppletObject after', retries, 'retries');
                       ggbAPI = appletObject;
                       resolved = true;
                       resolve(appletObject);
                       return;
                     }
                   }

                   // Method 4: Try document.ggbApplet 
                   if (document.ggbApplet && typeof document.ggbApplet.evalCommand === 'function') {
                     console.log('API found via document.ggbApplet after', retries, 'retries');
                     ggbAPI = document.ggbApplet;
                     resolved = true;
                     resolve(document.ggbApplet);
                     return;
                   }

                   // Method 5: Alternative - try getAPI promise
                   if (ggbApplet && typeof ggbApplet.getAPI === 'function') {
                     ggbApplet.getAPI().then(api => {
                       if (!resolved && api && typeof api.evalCommand === 'function') {
                         console.log('API found via getAPI after', retries, 'retries');
                         ggbAPI = api;
                         resolved = true;
                         resolve(api);
                       }
                     }).catch(() => {
                       // Continue with polling
                     });
                   }

                   if (retries >= maxRetries) {
                     reject(new Error('GeoGebra API not available after ' + maxRetries + ' attempts'));
                     return;
                   }

                   setTimeout(checkAPI, delay);
                 } catch (error) {
                   console.warn('Error checking API (attempt ' + retries + '):', error.message);
                   if (retries >= maxRetries) {
                     reject(new Error('Error accessing GeoGebra API: ' + error.message));
                     return;
                   }
                   setTimeout(checkAPI, delay);
                 }
               }

               checkAPI();
             });
           }

           function initGeoGebra(is3D = false) {
                  const mode = is3D ? '3D' : '2D';

                   // If mode changed, reset the applet
                   if (currentMode && currentMode !== mode) {
                     ggbApplet = null;
                     ggbAPI = null;
                     appletInitPromise = null;
                     appletInitResolve = null;
                     appletInitReject = null;
                     document.getElementById('ggb-element').innerHTML = '';
                   }

                   // If applet already exists in correct mode, return it
                   if (appletInitPromise && currentMode === mode) {
                     return appletInitPromise;
                   }

                   currentMode = mode;

                   // Get container width for responsive sizing
                   const container = document.getElementById('ggb-element');
                   const containerWidth = container.parentElement.offsetWidth - 40; // Account for padding
                   const containerHeight = 600;

                   const parameters = {
                     // Use "3d" for 3D Graphing Calculator, "graphing" for 2D
                     // See: https://geogebra.github.io/docs/reference/en/GeoGebra_App_Parameters/
                     "appName": is3D ? "3d" : "graphing",
                     "width": containerWidth,
                     "height": containerHeight,
                     "showToolBar": true,
                     "showAlgebraInput": true,
                     "showMenuBar": true,
                     "enableLabelDrags": false,
                     "enableRightClick": true,
                     "errorDialogsActive": true,
                     "useBrowserForJS": true,
                     "allowStyleBar": true,
                     "showLogging": true,  // Enable logging for debugging
                     "showZoomButtons": true,
                     "showFullscreenButton": true,
                     // Use function for appletOnLoad to receive API directly
                     "appletOnLoad": function(api) {
                       console.log('GeoGebra appletOnLoad fired, API:', !!api);
                       if (api && typeof api.evalCommand === 'function') {
                         ggbAPI = api;
                       }
                       window.ggbOnInit(api);
                     },
                     // Set an ID so we can access via window[id]
                     "id": "ggb-element"
                   };

                   try {
                     console.log('Creating GeoGebra applet for', mode);
                     ggbApplet = new GGBApplet(parameters, true);  // Use HTML5 only (true)
                     ggbApplet.inject('ggb-element');

                     // Show the container
                     document.getElementById('ggb-element').classList.add('show');

                     // Return promise that resolves when applet is loaded
                     appletInitPromise = new Promise((resolve, reject) => {
                       let callbackTriggered = false;
                       let pollTimer = null;

                       const cleanup = () => {
                         if (pollTimer) {
                           clearTimeout(pollTimer);
                           pollTimer = null;
                         }
                       };

                       const timeout = setTimeout(() => {
                         cleanup();
                         if (!callbackTriggered) {
                           reject(new Error('GeoGebra applet failed to load within 30 seconds'));
                         }
                       }, 30000);

                       appletInitResolve = (apiFromCallback) => {
                         console.log('Callback triggered, API from callback:', !!apiFromCallback);
                         callbackTriggered = true;
                         cleanup();
                         clearTimeout(timeout);

                         // If API was passed directly from callback, use it
                         if (apiFromCallback && typeof apiFromCallback.evalCommand === 'function') {
                           console.log('Using API passed directly from callback');
                           ggbAPI = apiFromCallback;
                           resolve(apiFromCallback);
                           return;
                         }

                         // If ggbAPI was already set, use it
                         if (ggbAPI && typeof ggbAPI.evalCommand === 'function') {
                           console.log('Using pre-set ggbAPI');
                           resolve(ggbAPI);
                           return;
                         }

                         // Otherwise try polling
                         tryGetAPI(20, 100).then(api => {
                           resolve(api);
                         }).catch(err => {
                           reject(new Error('Callback triggered but failed to get API: ' + err.message));
                         });
                       };

                       // Start polling as fallback after 3 seconds (give more time)
                       pollTimer = setTimeout(() => {
                         if (!callbackTriggered) {
                           console.log('Callback not triggered, starting fallback polling');
                           tryGetAPI(60, 250).then(api => {  // More retries, longer delay
                             callbackTriggered = true;
                             cleanup();
                             clearTimeout(timeout);
                             resolve(api);
                           }).catch(err => {
                             cleanup();
                             clearTimeout(timeout);
                             reject(new Error('Failed to get API via polling: ' + err.message));
                           });
                         }
                       }, 3000);

                       appletInitReject = (error) => {
                         cleanup();
                         clearTimeout(timeout);
                         reject(error);
                       };
                     });

                     return appletInitPromise;
                   } catch (error) {
                     console.error('Error creating GeoGebra applet:', error);
                     return Promise.reject(new Error('Failed to initialize GeoGebra applet: ' + error.message));
                   }
                 }

                 function handleWindowResize() {
                 // Resize the GeoGebra applet when window is resized
                 if (ggbApplet && typeof ggbApplet.setWidth === 'function' && typeof ggbApplet.setHeight === 'function') {
                 const container = document.getElementById('ggb-element');
                 const containerWidth = container.parentElement.offsetWidth - 40; // Account for padding
                 const containerHeight = 600;

                 ggbApplet.setWidth(containerWidth);
                 ggbApplet.setHeight(containerHeight);
                 console.log('Resized GeoGebra applet to', containerWidth, 'x', containerHeight);
                 }
                 }

                 // Add resize listener
                 window.addEventListener('resize', handleWindowResize);

                 function copyCommandsToClipboard(commandsText) {
       const commands = commandsText.replace(/\\n/g, '\n');
       navigator.clipboard.writeText(commands).then(() => {
         alert('‚úì Commands copied to clipboard!');
       }).catch(() => {
         alert('Failed to copy. Please manually copy the commands.');
       });
     }
     
     async function plotVectors() {
            const dim = parseInt(document.getElementById('dimension').value);
            const A = getVectorInput('vecA');
            const B = getVectorInput('vecB');
            const C = getVectorInput('vecC');
            const P1 = getVectorInput('p1');
            const P2 = getVectorInput('p2');

            if (!A && !B && !C && !P1 && !P2) {
              showError('Please enter at least one vector (A, B, C) or point (P‚ÇÅ, P‚ÇÇ) to plot');
              return;
            }

            // Check WebGL availability for 3D mode (warning only, GeoGebra may still work)
            if (dim === 3 && !isWebGLAvailable()) {
              console.warn('WebGL is not available. 3D visualization may not work properly.');
            }

            // Initialize GeoGebra applet and wait for API
            try {
              const api = await initGeoGebra(dim === 3);
              
              // Validate API before using
              if (!api) {
                throw new Error('GeoGebra API is null');
              }

              if (typeof api.evalCommand !== 'function') {
                throw new Error('GeoGebra API evalCommand method not available');
              }

              // Wait for GeoGebra commands to be fully loaded
              console.log('Waiting for GeoGebra commands to be ready...');
              await waitForGeoGebraReady(api);
              console.log('GeoGebra commands are ready');

              prepareGeoGebra(api);

              // Create all objects first, then apply styles with delay
              const createdObjects = [];

              // Add vectors as arrows from origin - use safeEvalCommand
              if (A) {
                const cmd = dim === 2 
                  ? `VectorA = Vector((0,0), (${A[0]},${A[1]}))`
                  : `VectorA = Vector((0,0,0), (${A[0]},${A[1]},${A[2]}))`;
                await safeEvalCommand(api, cmd);
                registerGeoObject('VectorA');
                createdObjects.push({ name: 'VectorA', type: 'vector', color: GEO_DEFAULT_VECTOR_COLOR });
              }

              if (B) {
                const cmd = dim === 2 
                  ? `VectorB = Vector((0,0), (${B[0]},${B[1]}))`
                  : `VectorB = Vector((0,0,0), (${B[0]},${B[1]},${B[2]}))`;
                await safeEvalCommand(api, cmd);
                registerGeoObject('VectorB');
                createdObjects.push({ name: 'VectorB', type: 'vector', color: GEO_DEFAULT_VECTOR_COLOR });
              }

              if (C) {
                const cmd = dim === 2 
                  ? `VectorC = Vector((0,0), (${C[0]},${C[1]}))`
                  : `VectorC = Vector((0,0,0), (${C[0]},${C[1]},${C[2]}))`;
                await safeEvalCommand(api, cmd);
                registerGeoObject('VectorC');
                createdObjects.push({ name: 'VectorC', type: 'vector', color: GEO_DEFAULT_VECTOR_COLOR });
              }

              // Add points
              if (P1) {
                const cmd = dim === 2 
                  ? `P1 = (${P1[0]}, ${P1[1]})`
                  : `P1 = (${P1[0]}, ${P1[1]}, ${P1[2]})`;
                await safeEvalCommand(api, cmd);
                registerGeoObject('P1');
                createdObjects.push({ name: 'P1', type: 'point', color: GEO_POINT_P1_COLOR });
              }

              if (P2) {
                const cmd = dim === 2 
                  ? `P2 = (${P2[0]}, ${P2[1]})`
                  : `P2 = (${P2[0]}, ${P2[1]}, ${P2[2]})`;
                await safeEvalCommand(api, cmd);
                registerGeoObject('P2');
                createdObjects.push({ name: 'P2', type: 'point', color: GEO_POINT_P2_COLOR });
              }

              // Apply styles after objects are created
              // Use a longer delay to ensure GeoGebra has processed the objects
              await new Promise(resolve => setTimeout(resolve, 500));
              
              for (const obj of createdObjects) {
                if (obj.type === 'vector') {
                  await setVectorStyleAsync(api, obj.name, obj.color);
                } else if (obj.type === 'point') {
                  await setPointStyleAsync(api, obj.name, obj.color);
                }
              }
              
            } catch (e) {
              console.error('Error plotting vectors:', e);
              showError('Error plotting vectors: ' + e.message);
            }

      const steps = [{
        title: 'GeoGebra Embedded Visualization',
        content: `
          <div class="alert alert-success">
            <strong>‚úì Vectors plotted in GeoGebra!</strong><br><br>
            Your vectors and points are displayed below. You can interact with the GeoGebra view:
            <ul style="margin-left: 20px; margin-top: 10px;">
              <li>Use mouse to rotate/pan the view</li>
              <li>Scroll to zoom in/out</li>
              <li>Drag objects to move them</li>
              <li>Use toolbar for additional tools</li>
            </ul>
            ${dim === 3 && !isWebGLAvailable() ? '<p class="text-warning mt-2"><strong>‚ö†Ô∏è Note:</strong> WebGL may not be fully available. 3D rendering might be limited.</p>' : ''}
          </div>
        `
      }];

      const summary = `
        <div class="summary-line"><strong>Service:</strong> GeoGebra Embedded ${dim}D</div>
        <div class="summary-line"><strong>Dimension:</strong> ${dim}D</div>
        <div class="summary-line"><strong>Status:</strong> ‚úì Plotted</div>
        ${A ? '<div class="summary-line"><strong>Vector A:</strong> ' + VectorModule.formatVector(A) + '</div>' : ''}
        ${B ? '<div class="summary-line"><strong>Vector B:</strong> ' + VectorModule.formatVector(B) + '</div>' : ''}
        ${C ? '<div class="summary-line"><strong>Vector C:</strong> ' + VectorModule.formatVector(C) + '</div>' : ''}
        ${P1 ? '<div class="summary-line"><strong>Point P‚ÇÅ:</strong> ' + VectorModule.formatVector(P1) + '</div>' : ''}
        ${P2 ? '<div class="summary-line"><strong>Point P‚ÇÇ:</strong> ' + VectorModule.formatVector(P2) + '</div>' : ''}
        <div class="summary-result">Vectors and points displayed in interactive GeoGebra view</div>
      `;

      showResult('Vector Visualization', summary, steps);
     }
    
    async function plotCoordinateSystem() {
      const dim = parseInt(document.getElementById('dimension').value);

      // Check WebGL availability for 3D mode (warning only, GeoGebra may still work)
      if (dim === 3 && !isWebGLAvailable()) {
        console.warn('WebGL is not available. 3D visualization may not work properly.');
      }

      // Initialize GeoGebra applet
      try {
        const api = await initGeoGebra(dim === 3);
        
        // Validate API before using
        if (!api) {
          throw new Error('GeoGebra API is null');
        }

        // Wait for GeoGebra commands to be ready
        await waitForGeoGebraReady(api);
        prepareGeoGebra(api);
      } catch (err) {
        console.error('Failed to initialize GeoGebra:', err);
        showError('Failed to initialize GeoGebra: ' + err.message);
        return;
      }

      const steps = [{
        title: 'Right-Handed Coordinate System',
        content: `
          <div class="alert alert-success">
            <strong>‚úì Coordinate System Ready!</strong><br><br>
            The ${dim}D right-handed coordinate system is displayed below.
            <br><br>
            ${dim === 2 ?
              '<strong>2D System:</strong> X-axis (horizontal) points right, Y-axis (vertical) points up. Positive angles are measured counterclockwise.' :
              '<strong>3D System:</strong> Right-hand rule - When you curl the fingers of your right hand from the x-axis to the y-axis, your thumb points in the direction of the z-axis (toward you).'
            }
            <br><br>
            <em>Ready to plot vectors and points!</em>
          </div>
        `
      }];

      const summary = `
        <div class="summary-line"><strong>System Type:</strong> Right-Handed Coordinate System</div>
        <div class="summary-line"><strong>Dimension:</strong> ${dim}D</div>
        <div class="summary-line"><strong>Service:</strong> GeoGebra Embedded</div>
        <div class="summary-result">‚úì Coordinate system displayed</div>
      `;

      showResult('Coordinate System', summary, steps);
    }
    
    async function plotOperationResult(operationName, result, inputs = {}) {
      const dim = parseInt(document.getElementById('dimension').value);
      
      // Check WebGL availability for 3D mode
      if (dim === 3 && !isWebGLAvailable()) {
        console.warn('WebGL not available for 3D plotting');
      }
      
      // Initialize GeoGebra applet and wait for API
      try {
        const api = await initGeoGebra(dim === 3);
        
        // Validate API before using
        if (!api) {
          throw new Error('GeoGebra API is null');
        }
        
        if (typeof api.evalCommand !== 'function') {
          throw new Error('GeoGebra API evalCommand method not available');
        }
        
        // Wait for commands to be ready
        await waitForGeoGebraReady(api);
        prepareGeoGebra(api);
        
        // Create all objects first, then apply styles with delay
        const createdObjects = [];
        
        // Add input vectors
        if (inputs.A) {
          const cmd = dim === 2 
            ? `VectorA = Vector((0,0), (${inputs.A[0]},${inputs.A[1]}))`
            : `VectorA = Vector((0,0,0), (${inputs.A[0]},${inputs.A[1]},${inputs.A[2]}))`;
          await safeEvalCommand(api, cmd);
          registerGeoObject('VectorA');
          createdObjects.push({ name: 'VectorA', type: 'vector', color: GEO_DEFAULT_VECTOR_COLOR });
        }
        
        if (inputs.B) {
          const cmd = dim === 2
            ? `VectorB = Vector((0,0), (${inputs.B[0]},${inputs.B[1]}))`
            : `VectorB = Vector((0,0,0), (${inputs.B[0]},${inputs.B[1]},${inputs.B[2]}))`;
          await safeEvalCommand(api, cmd);
          registerGeoObject('VectorB');
          createdObjects.push({ name: 'VectorB', type: 'vector', color: GEO_DEFAULT_VECTOR_COLOR });
        }
        
        if (inputs.C) {
          const cmd = dim === 2
            ? `VectorC = Vector((0,0), (${inputs.C[0]},${inputs.C[1]}))`
            : `VectorC = Vector((0,0,0), (${inputs.C[0]},${inputs.C[1]},${inputs.C[2]}))`;
          await safeEvalCommand(api, cmd);
          registerGeoObject('VectorC');
          createdObjects.push({ name: 'VectorC', type: 'vector', color: GEO_DEFAULT_VECTOR_COLOR });
        }

        // Add input points
        if (inputs.P1) {
          const cmd = dim === 2
            ? `P1 = (${inputs.P1[0]}, ${inputs.P1[1]})`
            : `P1 = (${inputs.P1[0]}, ${inputs.P1[1]}, ${inputs.P1[2]})`;
          await safeEvalCommand(api, cmd);
          registerGeoObject('P1');
          createdObjects.push({ name: 'P1', type: 'point', color: GEO_POINT_P1_COLOR });
        }

        if (inputs.P2) {
          const cmd = dim === 2
            ? `P2 = (${inputs.P2[0]}, ${inputs.P2[1]})`
            : `P2 = (${inputs.P2[0]}, ${inputs.P2[1]}, ${inputs.P2[2]})`;
          await safeEvalCommand(api, cmd);
          registerGeoObject('P2');
          createdObjects.push({ name: 'P2', type: 'point', color: GEO_POINT_P2_COLOR });
        }

        // Add result vector in red color
        if (Array.isArray(result)) {
          const cmd = dim === 2
            ? `Result = Vector((0,0), (${result[0]},${result[1]}))`
            : `Result = Vector((0,0,0), (${result[0]},${result[1]},${result[2]}))`;
          await safeEvalCommand(api, cmd);
          registerGeoObject('Result');
          createdObjects.push({ name: 'Result', type: 'vector', color: GEO_RESULT_VECTOR_COLOR });
        } else if (typeof result === 'object' && result.vec) {
          const cmd = dim === 2
            ? `Result = Vector((0,0), (${result.vec[0]},${result.vec[1]}))`
            : `Result = Vector((0,0,0), (${result.vec[0]},${result.vec[1]},${result.vec[2]}))`;
          await safeEvalCommand(api, cmd);
          registerGeoObject('Result');
          createdObjects.push({ name: 'Result', type: 'vector', color: GEO_RESULT_VECTOR_COLOR });
        }

        // Apply styles after objects are created
        await new Promise(resolve => setTimeout(resolve, 500));
        
        for (const obj of createdObjects) {
          if (obj.type === 'vector') {
            const thickness = obj.name === 'Result' ? 6 : 5;
            await setVectorStyleAsync(api, obj.name, obj.color, thickness);
          } else if (obj.type === 'point') {
            await setPointStyleAsync(api, obj.name, obj.color);
          }
        }
      } catch (e) {
        console.error('Error plotting operation result:', e);
        showError('Error plotting result: ' + e.message);
      }
      
      const steps = [{
        title: 'Operation Result Visualization',
        content: `
          <div class="alert alert-success">
            <strong>‚úì Operation result plotted!</strong><br><br>
            Input vectors are shown in blue, the result vector in red. Use the GeoGebra controls to explore the visualization.
          </div>
        `
      }];
      
      const summary = `
        <div class="summary-line"><strong>Operation:</strong> ${operationName}</div>
        <div class="summary-line"><strong>Service:</strong> GeoGebra Embedded ${dim}D</div>
        <div class="summary-line"><strong>Status:</strong> ‚úì Plotted</div>
        <div class="summary-line"><strong>Result:</strong> ${Array.isArray(result) ? VectorModule.formatVector(result) : (result.vec ? VectorModule.formatVector(result.vec) : 'Scalar')}</div>
        <div class="summary-result">Result displayed in red on GeoGebra visualization</div>
      `;
      
      showResult(`${operationName} Visualization`, summary, steps);
    }
     
     const TestRunner = (() => {
      const tests = [];

      const assert = (condition, message) => {
        if (!condition) throw new Error(message);
      };

      const assertAlmostEqual = (actual, expected, tolerance = 1e-6, message = '') => {
        if (Math.abs(actual - expected) > tolerance) {
          throw new Error(`${message}\nExpected: ${expected}, Got: ${actual}`);
        }
      };

      const assertVectorAlmostEqual = (actual, expected, tolerance = 1e-6, message = '') => {
        if (actual.length !== expected.length) {
          throw new Error(`${message}\nExpected length ${expected.length}, got ${actual.length}`);
        }
        for (let i = 0; i < actual.length; i++) {
          if (Math.abs(actual[i] - expected[i]) > tolerance) {
            throw new Error(`${message}\nAt index ${i}: expected ${expected[i]}, got ${actual[i]}`);
          }
        }
      };

      const registerTest = (name, fn) => {
        tests.push({ name, fn });
      };

      // Validation Tests
      registerTest('validateDimension - valid 2D', () => {
        assert(VectorModule.validateDimension(2) === 2, 'Should return 2 for 2D');
      });

      registerTest('validateDimension - valid 3D', () => {
        assert(VectorModule.validateDimension(3) === 3, 'Should return 3 for 3D');
      });

      registerTest('validateDimension - invalid dimension', () => {
        try {
          VectorModule.validateDimension(4);
          throw new Error('Should have thrown error');
        } catch (e) {
          assert(e.message.includes('must be 2 or 3'), 'Should have validation error');
        }
      });

      // Parse Vector Tests
      registerTest('parseVector - 2D vector string', () => {
        const result = VectorModule.parseVector('1, 2');
        assertVectorAlmostEqual(result, [1, 2], 1e-6, '2D parse');
      });

      registerTest('parseVector - 3D vector string', () => {
        const result = VectorModule.parseVector('1, 2, 3');
        assertVectorAlmostEqual(result, [1, 2, 3], 1e-6, '3D parse');
      });

      registerTest('parseVector - with decimal numbers', () => {
        const result = VectorModule.parseVector('1.5, 2.5, 3.5');
        assertVectorAlmostEqual(result, [1.5, 2.5, 3.5], 1e-6, 'Decimal parse');
      });

      registerTest('parseVector - with negative numbers', () => {
        const result = VectorModule.parseVector('-1, -2, -3');
        assertVectorAlmostEqual(result, [-1, -2, -3], 1e-6, 'Negative parse');
      });

      registerTest('parseVector - 2D auto-extend to 3D', () => {
        const result = VectorModule.parseVector('1, 2', 3);
        assertVectorAlmostEqual(result, [1, 2, 0], 1e-6, 'Should extend 2D to 3D with z=0');
      });

      registerTest('parseVector - dimension mismatch', () => {
        try {
          const result = VectorModule.parseVector('1, 2', 3);
          // Should auto-extend 2D to 3D by adding z=0
          assertVectorAlmostEqual(result, [1, 2, 0], 1e-6, 'Should auto-extend 2D to 3D');
        } catch (e) {
          throw new Error('Should have auto-extended 2D to 3D but threw error: ' + e.message);
        }
      });

      registerTest('parseVector - invalid number', () => {
        try {
          VectorModule.parseVector('1, abc, 3');
          throw new Error('Should have thrown parsing error');
        } catch (e) {
          assert(e.message.includes('Invalid number'), 'Should have parsing error');
        }
      });

      registerTest('parseVector - empty string', () => {
        try {
          VectorModule.parseVector('');
          throw new Error('Should have thrown error');
        } catch (e) {
          assert(e.message.includes('cannot be empty'), 'Should reject empty input');
        }
      });

      // Format Vector Tests
      registerTest('formatVector - integer components', () => {
        const result = VectorModule.formatVector([1, 2, 3]);
        assert(result === '(1, 2, 3)', `Should format as (1, 2, 3), got ${result}`);
      });

      registerTest('formatVector - decimal components', () => {
        const result = VectorModule.formatVector([1.5, 2.5, 3.5]);
        assert(result.includes('1.5') && result.includes('2.5') && result.includes('3.5'), 'Should include decimals');
      });

      registerTest('formatVector - negative components', () => {
        const result = VectorModule.formatVector([-1, -2, -3]);
        assert(result === '(-1, -2, -3)', `Should format negatives, got ${result}`);
      });

      // Zero Vector Tests
      registerTest('isZeroVector - true for zero vector', () => {
        assert(VectorModule.isZeroVector([0, 0, 0]), 'Should identify zero vector');
      });

      registerTest('isZeroVector - false for non-zero', () => {
        assert(!VectorModule.isZeroVector([1, 0, 0]), 'Should reject non-zero vector');
      });

      registerTest('isZeroVector - near-zero tolerance', () => {
        assert(VectorModule.isZeroVector([1e-11, 1e-11, 1e-11]), 'Should accept near-zero');
      });

      // Vector Addition Tests
      registerTest('vectorAddition - 2D', () => {
        const result = VectorModule.vectorAddition([1, 2], [3, 4]);
        assertVectorAlmostEqual(result, [4, 6], 1e-6, '2D addition');
      });

      registerTest('vectorAddition - 3D', () => {
        const result = VectorModule.vectorAddition([1, 2, 3], [4, 5, 6]);
        assertVectorAlmostEqual(result, [5, 7, 9], 1e-6, '3D addition');
      });

      registerTest('vectorAddition - with negative', () => {
        const result = VectorModule.vectorAddition([1, 2], [-1, -2]);
        assertVectorAlmostEqual(result, [0, 0], 1e-6, 'Addition with negatives');
      });

      registerTest('vectorAddition - dimension mismatch', () => {
        try {
          VectorModule.vectorAddition([1, 2], [1, 2, 3]);
          throw new Error('Should have thrown dimension error');
        } catch (e) {
          assert(e.message.includes('same dimension'), 'Expected dimension error');
        }
      });

      // Vector Subtraction Tests
      registerTest('vectorSubtraction - 2D', () => {
        const result = VectorModule.vectorSubtraction([3, 4], [1, 2]);
        assertVectorAlmostEqual(result, [2, 2], 1e-6, '2D subtraction');
      });

      registerTest('vectorSubtraction - 3D', () => {
        const result = VectorModule.vectorSubtraction([4, 5, 6], [1, 2, 3]);
        assertVectorAlmostEqual(result, [3, 3, 3], 1e-6, '3D subtraction');
      });

      registerTest('vectorSubtraction - dimension mismatch', () => {
        try {
          VectorModule.vectorSubtraction([1, 2], [1, 2, 3]);
          throw new Error('Should have thrown dimension error');
        } catch (e) {
          assert(e.message.includes('same dimension'), 'Expected dimension error');
        }
      });

      // Scalar Multiplication Tests
      registerTest('scalarMultiplication - positive scalar', () => {
        const result = VectorModule.scalarMultiplication([1, 2, 3], 2);
        assertVectorAlmostEqual(result, [2, 4, 6], 1e-6, 'Positive scalar');
      });

      registerTest('scalarMultiplication - negative scalar', () => {
        const result = VectorModule.scalarMultiplication([1, 2, 3], -1);
        assertVectorAlmostEqual(result, [-1, -2, -3], 1e-6, 'Negative scalar');
      });

      registerTest('scalarMultiplication - zero scalar', () => {
        const result = VectorModule.scalarMultiplication([1, 2, 3], 0);
        assertVectorAlmostEqual(result, [0, 0, 0], 1e-6, 'Zero scalar');
      });

      registerTest('scalarMultiplication - fractional scalar', () => {
        const result = VectorModule.scalarMultiplication([2, 4, 6], 0.5);
        assertVectorAlmostEqual(result, [1, 2, 3], 1e-6, 'Fractional scalar');
      });

      // Dot Product Tests
      registerTest('dotProduct - standard case', () => {
        const result = VectorModule.dotProduct([1, 2, 3], [4, 5, 6]);
        assertAlmostEqual(result, 32, 1e-6, 'Dot product [1,2,3]¬∑[4,5,6]');
      });

      registerTest('dotProduct - orthogonal vectors', () => {
        const result = VectorModule.dotProduct([1, 0, 0], [0, 1, 0]);
        assertAlmostEqual(result, 0, 1e-6, 'Orthogonal vectors should have dot product 0');
      });

      registerTest('dotProduct - 2D', () => {
        const result = VectorModule.dotProduct([1, 2], [3, 4]);
        assertAlmostEqual(result, 11, 1e-6, '2D dot product');
      });

      registerTest('dotProduct - dimension mismatch', () => {
        try {
          VectorModule.dotProduct([1, 2], [1, 2, 3]);
          throw new Error('Should have thrown dimension error');
        } catch (e) {
          assert(e.message.includes('same dimension'), 'Expected dimension error');
        }
      });

      // Cross Product Tests
      registerTest('crossProduct - standard case', () => {
        const result = VectorModule.crossProduct([1, 0, 0], [0, 1, 0]);
        assertVectorAlmostEqual(result, [0, 0, 1], 1e-6, 'i √ó j = k');
      });

      registerTest('crossProduct - parallel vectors', () => {
        const result = VectorModule.crossProduct([1, 2, 3], [2, 4, 6]);
        assertVectorAlmostEqual(result, [0, 0, 0], 1e-6, 'Parallel vectors cross product is zero');
      });

      registerTest('crossProduct - non-3D', () => {
        try {
          VectorModule.crossProduct([1, 2], [3, 4]);
          throw new Error('Should have thrown error');
        } catch (e) {
          assert(e.message.includes('3D'), 'Should require 3D vectors');
        }
      });

      registerTest('crossProduct - anti-commutative', () => {
        const forward = VectorModule.crossProduct([1, 2, 3], [4, 5, 6]);
        const backward = VectorModule.crossProduct([4, 5, 6], [1, 2, 3]);
        assertVectorAlmostEqual(forward.map(v => -v), backward, 1e-6, 'Cross product should be anti-commutative');
      });

      // Vector Norm Tests
      registerTest('vectorNorm - unit vector', () => {
        const result = VectorModule.vectorNorm([1, 0, 0]);
        assertAlmostEqual(result, 1, 1e-6, 'Unit vector norm');
      });

      registerTest('vectorNorm - 3-4-5 triangle', () => {
        const result = VectorModule.vectorNorm([3, 4, 0]);
        assertAlmostEqual(result, 5, 1e-6, '3-4-5 triangle norm');
      });

      registerTest('vectorNorm - 2D vector', () => {
        const result = VectorModule.vectorNorm([1, 1]);
        assertAlmostEqual(result, Math.sqrt(2), 1e-6, '2D norm');
      });

      // Angle Between Tests
      registerTest('angleBetween - perpendicular vectors', () => {
        const result = VectorModule.angleBetween([1, 0, 0], [0, 1, 0]);
        assertAlmostEqual(result.degrees, 90, 1e-4, 'Perpendicular vectors angle');
      });

      registerTest('angleBetween - same vector', () => {
        const result = VectorModule.angleBetween([1, 2, 3], [1, 2, 3]);
        assertAlmostEqual(result.degrees, 0, 1e-4, 'Same vector angle');
      });

      registerTest('angleBetween - opposite vectors', () => {
        const result = VectorModule.angleBetween([1, 0, 0], [-1, 0, 0]);
        assertAlmostEqual(result.degrees, 180, 1e-4, 'Opposite vectors angle');
      });

      registerTest('angleBetween - zero vector', () => {
        try {
          VectorModule.angleBetween([0, 0, 0], [1, 2, 3]);
          throw new Error('Should have thrown error');
        } catch (e) {
          assert(e.message.includes('zero vector'), 'Should reject zero vectors');
        }
      });

      // Orthogonal Projection Tests
      registerTest('orthogonalProjection - projection onto axis', () => {
        const result = VectorModule.orthogonalProjection([1, 2], [1, 0]);
        assertVectorAlmostEqual(result, [1, 0], 1e-6, 'Project onto x-axis');
      });

      registerTest('orthogonalProjection - projection onto self', () => {
        const result = VectorModule.orthogonalProjection([1, 2, 3], [1, 2, 3]);
        assertVectorAlmostEqual(result, [1, 2, 3], 1e-6, 'Projection onto self');
      });

      registerTest('orthogonalProjection - zero vector target', () => {
        try {
          VectorModule.orthogonalProjection([1, 2, 3], [0, 0, 0]);
          throw new Error('Should have thrown error');
        } catch (e) {
          assert(e.message.includes('zero vector'), 'Should reject zero target');
        }
      });

      // Scalar Triple Product Tests
      registerTest('scalarTripleProduct - standard case', () => {
        const result = VectorModule.scalarTripleProduct([1, 0, 0], [0, 1, 0], [0, 0, 1]);
        assertAlmostEqual(result, 1, 1e-6, 'Unit cube volume');
      });

      registerTest('scalarTripleProduct - coplanar vectors', () => {
        const result = VectorModule.scalarTripleProduct([1, 0, 0], [0, 1, 0], [1, 1, 0]);
        assertAlmostEqual(result, 0, 1e-6, 'Coplanar vectors triple product');
      });

      registerTest('scalarTripleProduct - non-3D', () => {
        try {
          VectorModule.scalarTripleProduct([1, 2], [3, 4], [5, 6]);
          throw new Error('Should have thrown error');
        } catch (e) {
          assert(e.message.includes('3D'), 'Should require 3D vectors');
        }
      });

      // Component From Points Tests
      registerTest('componentFromPoints - 3D', () => {
        const result = VectorModule.componentFromPoints([1, 2, 3], [4, 5, 6]);
        assertVectorAlmostEqual(result, [3, 3, 3], 1e-6, 'Vector from P1 to P2');
      });

      registerTest('componentFromPoints - 2D', () => {
        const result = VectorModule.componentFromPoints([0, 0], [3, 4]);
        assertVectorAlmostEqual(result, [3, 4], 1e-6, '2D vector from points');
      });

      registerTest('componentFromPoints - same point', () => {
        const result = VectorModule.componentFromPoints([1, 2, 3], [1, 2, 3]);
        assertVectorAlmostEqual(result, [0, 0, 0], 1e-6, 'Same point gives zero vector');
      });

      registerTest('componentFromPoints - dimension mismatch', () => {
        try {
          VectorModule.componentFromPoints([1, 2], [1, 2, 3]);
          throw new Error('Should have thrown error');
        } catch (e) {
          assert(e.message.includes('same dimension'), 'Expected dimension error');
        }
      });

      // Point Distance Tests
      registerTest('pointDistance - unit distance', () => {
        const result = VectorModule.pointDistance([0, 0, 0], [1, 0, 0]);
        assertAlmostEqual(result, 1, 1e-6, 'Unit distance');
      });

      registerTest('pointDistance - 3-4-5 triangle', () => {
        const result = VectorModule.pointDistance([0, 0, 0], [3, 4, 0]);
        assertAlmostEqual(result, 5, 1e-6, '3-4-5 distance');
      });

      registerTest('pointDistance - 2D', () => {
        const result = VectorModule.pointDistance([0, 0], [1, 1]);
        assertAlmostEqual(result, Math.sqrt(2), 1e-6, '2D distance');
      });

      registerTest('pointDistance - same point', () => {
        const result = VectorModule.pointDistance([5, 5, 5], [5, 5, 5]);
        assertAlmostEqual(result, 0, 1e-6, 'Same point distance');
      });

      const runTests = () => {
        const results = [];
        for (const test of tests) {
          try {
            test.fn();
            results.push({ name: test.name, passed: true, error: null });
          } catch (error) {
            results.push({ name: test.name, passed: false, error: error.message });
          }
        }
        return results;
      };

      return { runTests };
    })();

    function displayTestResults(results) {
      const testSection = document.getElementById('testSection');
      const summaryDiv = document.getElementById('testSummary');
      const resultsDiv = document.getElementById('testResults');

      testSection.classList.add('show');
      resultsDiv.innerHTML = '';

      const passed = results.filter(r => r.passed).length;
      const total = results.length;
      const percentage = Math.round((passed / total) * 100);

      let summaryClass = 'test-summary-fail';
      let summaryText = `‚ùå Tests Failed`;

      if (passed === total) {
        summaryClass = 'test-summary-pass';
        summaryText = `‚úÖ All Tests Passed`;
      } else if (passed >= total * 0.9) {
        summaryClass = 'test-summary-partial';
        summaryText = `‚ö†Ô∏è Most Tests Passed`;
      }

      summaryDiv.innerHTML = `
        <div class="test-summary ${summaryClass}">
          ${summaryText}: ${passed}/${total} tests passed (${percentage}%)
        </div>
      `;

      results.forEach(result => {
        const resultDiv = document.createElement('div');
        resultDiv.className = `test-result ${result.passed ? 'test-pass' : 'test-fail'}`;

        const nameDiv = document.createElement('div');
        nameDiv.className = 'test-name';
        nameDiv.textContent = (result.passed ? '‚úÖ' : '‚ùå') + ' ' + result.name;

        const statusDiv = document.createElement('div');
        statusDiv.className = 'test-status';
        if (result.error) {
          statusDiv.innerHTML = `<pre style="margin: 8px 0; font-size: 0.85em;">${result.error}</pre>`;
        } else {
          statusDiv.textContent = 'Passed';
        }

        resultDiv.appendChild(nameDiv);
        resultDiv.appendChild(statusDiv);
        resultsDiv.appendChild(resultDiv);
      });
    }

    function runVectorTests() {
      try {
        const results = TestRunner.runTests();
        displayTestResults(results);
      } catch (error) {
        showError(`Test runner error: ${error.message}`);
      }
    }

    window.addEventListener('load', () => {
      updatePlaceholders(3);
    });
    </script>
    </body>
    </html>
